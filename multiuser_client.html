<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ScoreLeague - Fresh Version 2025</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#3498db">
    <script>
        if ('serviceWorker' in navigator) {
            const isLocalhost = location.hostname === 'localhost' || location.hostname === '127.0.0.1';
            if (isLocalhost) {
                // Disable service worker and clear caches during local development to avoid stale assets
                try { navigator.serviceWorker.getRegistrations().then(regs => regs.forEach(r => r.unregister())); } catch (_) {}
                try { if (window.caches && caches.keys) { caches.keys().then(keys => Promise.all(keys.map(k => caches.delete(k)))); } } catch (_) {}
                console.log('Service Worker disabled on localhost; caches cleared');
            } else {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('/sw.js')
                      .then(reg => console.log('Service Worker registered', reg.scope))
                      .catch(err => console.error('Service Worker registration failed', err));
                });
            }
        }
    </script>
    <!-- Supabase Integration -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-config.js"></script>
    <!-- Public API base (injected during Netlify build) -->
    <script src="env.js"></script>
    <script src="odds-api-service.js"></script>
    <script src="scores-service.js"></script>
    
    <!-- Cache busting meta tags -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            background-attachment: fixed;
            color: #333;
            min-height: 100vh;
            position: relative;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 80%, rgba(120, 119, 198, 0.3) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 40% 40%, rgba(120, 119, 198, 0.2) 0%, transparent 50%);
            pointer-events: none;
            z-index: -1;
        }

        /* Authentication Screen Styles */
        .auth-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 50%, #f093fb 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .auth-card {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(20px);
            border-radius: 20px;
            padding: 40px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            text-align: center;
            max-width: 400px;
            width: 90%;
        }

        .auth-card h1 {
            color: #2c3e50;
            margin-bottom: 10px;
            font-size: 28px;
            font-weight: 700;
        }

        .auth-card p {
            color: #7f8c8d;
            margin-bottom: 30px;
            font-size: 16px;
        }

        .auth-input {
            width: 100%;
            padding: 15px;
            border: 2px solid #ecf0f1;
            border-radius: 12px;
            font-size: 16px;
            margin-bottom: 20px;
            transition: border-color 0.3s ease;
        }

        .auth-input:focus {
            outline: none;
            border-color: #3498db;
        }

        .auth-button {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .auth-button:hover {
            transform: translateY(-2px);
        }

        .hidden {
            display: none !important;
        }

        header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 50%, #2c3e50 100%);
            background-size: 200% 200%;
            animation: headerGradientShift 8s ease-in-out infinite;
            color: white;
            padding: 1.5rem 1rem;
            box-shadow: 
                0 4px 20px rgba(0, 0, 0, 0.15),
                0 1px 3px rgba(0, 0, 0, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            position: relative;
            overflow: hidden;
        }

        header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.1) 50%, transparent 70%);
            transform: translateX(-100%);
            animation: headerShine 3s ease-in-out infinite;
        }

        @keyframes headerGradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        @keyframes headerShine {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(100%); }
            100% { transform: translateX(100%); }
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            max-width: 1200px;
            margin: 0 auto;
        }

        .header-center h1 {
            font-size: 2rem;
            font-weight: bold;
        }

        .coins-display {
            color: #f1c40f;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.3s ease;
            position: relative;
        }

        .coins-display #coins {
            display: inline-block;
            transition: all 0.4s cubic-bezier(0.68, -0.55, 0.265, 1.55);
        }

        .coins-display.bounce #coins {
            animation: coinBounce 0.6s ease-out;
        }

        @keyframes coinBounce {
            0% { transform: scale(1); }
            25% { transform: scale(1.2) rotate(5deg); }
            50% { transform: scale(1.1) rotate(-3deg); }
            75% { transform: scale(1.15) rotate(2deg); }
            100% { transform: scale(1) rotate(0deg); }
        }

        .coins-display.decrease #coins {
            animation: coinDecrease 0.5s ease-out;
        }

        @keyframes coinDecrease {
            0% { transform: scale(1); color: #f1c40f; }
            50% { transform: scale(0.9); color: #e74c3c; }
            100% { transform: scale(1); color: #f1c40f; }
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .nav-tabs {
            display: flex;
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.95) 100%);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 24px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.1),
                0 2px 8px rgba(0, 0, 0, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        @media (max-width: 768px) {
            .nav-tabs { overflow: visible; }
        }

        .nav-tab {
            flex: 1;
            padding: 16px 12px;
            text-align: center;
            background: transparent;
            cursor: pointer;
            border: none;
            font-size: 15px;
            font-weight: 600;
            color: #2c3e50;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
        }

        .nav-tab::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .nav-tab::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 0;
            height: 3px;
            background: linear-gradient(90deg, #3498db, #2980b9);
            border-radius: 2px 2px 0 0;
            transition: width 0.3s ease;
        }

        .nav-tab span {
            position: relative;
            z-index: 1;
        }

        /* Badge for bet count */
        .badge {
            position: absolute;
            top: 4px;
            right: 14px;
            transform: translate(50%, -50%);
            z-index: 2;
            background: #e74c3c;
            color: #fff;
            border-radius: 12px;
            padding: 2px 6px;
            font-size: 11px;
            font-weight: 700;
            line-height: 1;
            min-width: 20px;
            text-align: center;
            pointer-events: none;
        }
        .badge.hidden {
            display: none;
        }

        .nav-tab.active {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.15) 0%, rgba(41, 128, 185, 0.15) 100%);
            color: #2980b9;
            font-weight: 700;
            border: 2px solid rgba(52, 152, 219, 0.3);
            box-shadow: 
                0 2px 8px rgba(52, 152, 219, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.5);
        }

        .nav-tab.active::after {
            width: 80%;
        }

        .nav-tab:hover:not(.active) {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.08) 0%, rgba(41, 128, 185, 0.08) 100%);
            color: #2980b9;
            transform: translateY(-1px);
        }

        .nav-tab:hover:not(.active)::after {
            width: 40%;
        }

        /* CRITICAL: Show matches tab by default, hide others */
        .tab-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.9) 100%);
            backdrop-filter: blur(20px);
            padding: 24px;
            border-radius: 16px;
            box-shadow: 
                0 8px 32px rgba(0, 0, 0, 0.1),
                0 2px 8px rgba(0, 0, 0, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            min-height: 400px;
            position: relative;
            overflow: hidden;
        }

        .tab-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 10% 20%, rgba(52, 152, 219, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 90% 80%, rgba(155, 89, 182, 0.05) 0%, transparent 50%);
            pointer-events: none;
        }

        /* Hide all tabs except matches initially */
        #betslip-tab, #mybets-tab, #social-tab {
            display: none;
        }
        
        /* Social Tab Styles */
        .social-nav {
            display: flex;
            background: rgba(255, 255, 255, 0.9);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 8px;
            margin-bottom: 24px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.1);
        }
        
        .social-nav-btn {
            flex: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px 16px;
            background: transparent;
            border: none;
            border-radius: 12px;
            font-size: 14px;
            font-weight: 600;
            color: #7f8c8d;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }
        
        .social-nav-btn:hover {
            background: rgba(52, 152, 219, 0.1);
            color: #2980b9;
            transform: translateY(-1px);
        }
        
        .social-nav-btn.active {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        .social-nav-icon {
            font-size: 16px;
        }
        
        .social-section {
            display: none;
            opacity: 0;
            transform: translateY(20px);
            transition: all 0.4s ease;
        }
        
        .social-section.active {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }
        
        .social-header {
            text-align: center;
            margin-bottom: 32px;
        }
        
        .social-header h2 {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 8px;
        }
        
        .social-subtitle {
            color: #7f8c8d;
            font-size: 16px;
            font-weight: 500;
        }
        
        /* Tournament Dashboard Styles */
        .tournament-dashboard {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.95) 100%);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 24px;
            margin-bottom: 32px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(52, 152, 219, 0.1);
        }
        
        .tournament-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid rgba(52, 152, 219, 0.1);
        }
        
        .tournament-header h3 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, #2c3e50 0%, #3498db 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin: 0;
        }
        
        .week-timer {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }
        
        .disciplines-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 32px;
        }
        
        .discipline-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.9) 0%, rgba(248, 249, 250, 0.9) 100%);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
            border: 1px solid rgba(52, 152, 219, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }
        
        .discipline-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 4px;
            background: linear-gradient(90deg, #3498db 0%, #2980b9 100%);
        }
        
        .discipline-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.15);
        }
        
        .discipline-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 16px;
        }
        
        .discipline-icon {
            font-size: 24px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1) 0%, rgba(41, 128, 185, 0.1) 100%);
            border-radius: 12px;
        }
        
        .discipline-name {
            font-size: 16px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 4px;
        }
        
        .discipline-points {
            font-size: 14px;
            color: #3498db;
            font-weight: 600;
        }
        
        .discipline-leader {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            background: rgba(52, 152, 219, 0.05);
            border-radius: 12px;
            border: 1px solid rgba(52, 152, 219, 0.1);
        }
        
        .leader-info {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .leader-avatar {
            font-size: 20px;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-radius: 50%;
        }
        
        .leader-name {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .leader-value {
            font-weight: 700;
            color: #27ae60;
            font-size: 16px;
        }
        
        .no-leader {
            color: #7f8c8d;
            font-style: italic;
            text-align: center;
            width: 100%;
        }
        
        .coin-allocations {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1) 0%, rgba(39, 174, 96, 0.1) 100%);
            border-radius: 16px;
            padding: 20px;
            border: 1px solid rgba(46, 204, 113, 0.2);
        }
        
        .coin-allocations h4 {
            margin: 0 0 16px 0;
            font-size: 18px;
            font-weight: 700;
            color: #27ae60;
        }
        
        .allocation-preview {
            display: grid;
            gap: 12px;
        }
        
        .allocation-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            border: 1px solid rgba(46, 204, 113, 0.1);
        }
        
        .coin-amount {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .base-coins {
            color: #7f8c8d;
            font-weight: 500;
        }
        
        .bonus-coins {
            color: #f39c12;
            font-weight: 700;
            background: rgba(243, 156, 18, 0.1);
            padding: 2px 8px;
            border-radius: 8px;
            font-size: 12px;
        }
        
        .total-coins {
            color: #27ae60;
            font-weight: 700;
            font-size: 16px;
        }
        
        /* Tournament Selection Modal Styles */
        .bet-summary {
            margin-bottom: 24px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1) 0%, rgba(41, 128, 185, 0.1) 100%);
            border-radius: 16px;
            border: 1px solid rgba(52, 152, 219, 0.2);
        }
        
        .bet-summary h4 {
            margin: 0 0 12px 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 700;
        }
        
        .bet-summary-card {
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            padding: 16px;
            border: 1px solid rgba(52, 152, 219, 0.1);
        }
        
        .bet-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .bet-stake {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .bet-result {
            font-weight: 700;
            padding: 4px 12px;
            border-radius: 8px;
            font-size: 14px;
        }
        
        .bet-result.win {
            background: rgba(39, 174, 96, 0.1);
            color: #27ae60;
        }
        
        .bet-result.loss {
            background: rgba(231, 76, 60, 0.1);
            color: #e74c3c;
        }
        
        .tournament-options h4 {
            margin: 0 0 16px 0;
            color: #2c3e50;
            font-size: 16px;
            font-weight: 700;
        }
        
        .tournament-checkboxes {
            display: grid;
            gap: 12px;
            margin-bottom: 24px;
        }
        
        .tournament-checkbox {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 16px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 12px;
            border: 1px solid rgba(52, 152, 219, 0.1);
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .tournament-checkbox:hover {
            background: rgba(52, 152, 219, 0.05);
            border-color: rgba(52, 152, 219, 0.3);
            transform: translateY(-1px);
        }
        
        .tournament-checkbox input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin: 0;
        }
        
        .tournament-info {
            flex: 1;
        }
        
        .tournament-name {
            display: block;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 4px;
        }
        
        .tournament-duration {
            display: block;
            font-size: 14px;
            color: #7f8c8d;
        }
        
        .weekly-bonus-info {
            margin-bottom: 24px;
        }
        
        .info-card {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 20px;
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1) 0%, rgba(39, 174, 96, 0.1) 100%);
            border-radius: 16px;
            border: 1px solid rgba(46, 204, 113, 0.2);
        }
        
        .info-icon {
            font-size: 24px;
            width: 48px;
            height: 48px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.2) 0%, rgba(39, 174, 96, 0.2) 100%);
            border-radius: 12px;
        }
        
        .info-text {
            flex: 1;
        }
        
        .info-text strong {
            display: block;
            color: #27ae60;
            font-size: 16px;
            font-weight: 700;
            margin-bottom: 4px;
        }
        
        .info-text p {
            margin: 0;
            color: #7f8c8d;
            font-size: 14px;
        }
        
        .modal-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
        }
        
        .btn-secondary {
            padding: 12px 24px;
            background: rgba(149, 165, 166, 0.1);
            color: #7f8c8d;
            border: 1px solid rgba(149, 165, 166, 0.3);
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .btn-secondary:hover {
            background: rgba(149, 165, 166, 0.2);
            color: #2c3e50;
        }
        
        .btn-primary {
            padding: 12px 24px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }
        
        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(52, 152, 219, 0.4);
        }
        
        /* Checkbox styling */
        .checkbox-label {
            display: flex;
            align-items: center;
            gap: 8px;
            cursor: pointer;
        }
        
        .checkbox-label input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin: 0;
        }
        
        .checkmark {
            width: 20px;
            height: 20px;
            border: 2px solid #3498db;
            border-radius: 4px;
            position: relative;
            transition: all 0.3s ease;
        }
        
        .checkbox-label input[type="checkbox"]:checked + .checkmark {
            background: #3498db;
        }
        
        .checkbox-label input[type="checkbox"]:checked + .checkmark::after {
            content: '✓';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 12px;
            font-weight: bold;
        }

        /* Ensure matches tab is always visible initially */
        #matches-tab {
            display: block;
        }

        .match-card {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid rgba(52, 152, 219, 0.1);
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.08);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .match-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3498db, #2ecc71, #f39c12);
            opacity: 0;
            transition: opacity 0.3s ease;
        }

        .match-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.12);
        }

        .match-card:hover::before {
            opacity: 1;
        }

        .match-header {
            margin-bottom: 20px;
        }

        .teams-display {
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 12px;
            gap: 20px;
        }

        .team {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            flex: 1;
            max-width: 120px;
        }

        .team-logo {
            font-size: 32px;
            filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
            transition: transform 0.3s ease;
        }

        .match-card:hover .team-logo {
            transform: scale(1.1);
        }

        .team-name {
            font-weight: 600;
            font-size: 16px;
            color: #2c3e50;
            text-align: center;
            line-height: 1.2;
        }

        .vs-divider {
            font-weight: bold;
            color: #7f8c8d;
            font-size: 14px;
            padding: 8px 12px;
            background: linear-gradient(135deg, #ecf0f1, #bdc3c7);
            border-radius: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            transition: all 0.3s ease;
        }

        .match-card:hover .vs-divider {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            transform: scale(1.05);
        }

        .match-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            border-top: 1px solid rgba(52, 152, 219, 0.1);
        }

        .match-time {
            font-weight: 600;
            color: #27ae60;
            font-size: 14px;
        }

        .match-league {
            font-size: 14px;
            color: #7f8c8d;
            font-weight: 500;
        }

        .match-teams {
            font-size: 1.2rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .match-time {
            color: #7f8c8d;
            font-size: 0.9rem;
        }

        .market-section {
            margin-bottom: 15px;
        }

        .market-title {
            font-weight: bold;
            margin-bottom: 8px;
            color: #34495e;
        }

        .market-odds {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .odds-button {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid #e1e8ed;
            padding: 10px 16px;
            margin: 3px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
            position: relative;
            overflow: hidden;
        }

        .odds-button::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.4), transparent);
            transition: left 0.5s ease;
        }

        .odds-button:hover {
            background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%);
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            border-color: #4F46E5;
        }

        .odds-button:hover::before {
            left: 100%;
        }

        .odds-button.selected {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-color: #4F46E5;
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.35);
            transform: translateY(-1px);
        }

        .odds-button.selected::before {
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
        }

        .odds-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 6px rgba(0,0,0,0.1);
        }

        .odds-button.pulse {
            animation: oddsPulse 0.4s ease-out;
        }

        @keyframes oddsPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); box-shadow: 0 0 20px rgba(52, 152, 219, 0.4); }
            100% { transform: scale(1); }
        }

        .odds-button.success {
            animation: oddsSuccess 0.6s ease-out;
        }

        @keyframes oddsSuccess {
            0% { transform: scale(1); background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%); }
            25% { transform: scale(1.1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); }
        }

        /* Profile Button Styling */
        .profile-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 14px;
            margin-left: 10px;
            transition: all 0.3s ease;
        }

        .profile-btn:hover {
            background: #2980b9;
            transform: translateY(-1px);
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
        }

        .header-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            gap: 5px;
        }

        /* Modal Styling */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4) 0%, rgba(44, 62, 80, 0.6) 100%);
            backdrop-filter: blur(10px);
        }

        .modal-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.9) 100%);
            backdrop-filter: blur(20px);
            margin: 8% auto;
            padding: 32px;
            border-radius: 20px;
            width: 90%;
            max-width: 500px;
            position: relative;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.3),
                0 8px 24px rgba(0, 0, 0, 0.15),
                inset 0 1px 0 rgba(255, 255, 255, 0.8);
            border: 1px solid rgba(255, 255, 255, 0.2);
            animation: modalSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            overflow: hidden;
        }

        .modal-content::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: 
                radial-gradient(circle at 20% 20%, rgba(52, 152, 219, 0.1) 0%, transparent 50%),
                radial-gradient(circle at 80% 80%, rgba(155, 89, 182, 0.1) 0%, transparent 50%);
            pointer-events: none;
        }

        @keyframes modalSlideIn {
            from {
                opacity: 0;
                transform: translateY(-50px) scale(0.9);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }

        .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            position: absolute;
            right: 15px;
            top: 10px;
            cursor: pointer;
            transition: color 0.3s;
        }

        .close:hover {
            color: #e74c3c;
        }

        .stat-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 0;
            border-bottom: 1px solid #ecf0f1;
            font-size: 16px;
        }

        .stat-item:last-child {
            border-bottom: none;
        }

        .stat-item span:first-child {
            font-weight: 600;
            color: #2c3e50;
        }

        .stat-item span:last-child {
            color: #27ae60;
            font-weight: bold;
        }

        /* Message styling */
        .message {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: white;
            font-weight: bold;
            z-index: 1001;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .message.show {
            transform: translateX(0);
        }

        .message.success {
            background: #27ae60;
        }

        .message.error {
            background: #e74c3c;
        }
        /* Mobile: move toast from top to bottom to avoid covering header */
        @media (max-width: 768px) {
            .message {
                top: auto;
                left: 12px;
                right: 12px;
                bottom: calc(80px + env(safe-area-inset-bottom));
                transform: translateY(120%);
                transition: transform 0.3s ease;
            }
            .message.show { transform: translateY(0); }
        }

        /* Success Ripple Effect */
        .success-ripple {
            position: fixed;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(39, 174, 96, 0.3) 0%, transparent 70%);
            pointer-events: none;
            z-index: 1000;
            animation: rippleExpand 0.8s ease-out forwards;
        }

        @keyframes rippleExpand {
            0% {
                width: 0;
                height: 0;
                opacity: 1;
            }
            100% {
                width: 300px;
                height: 300px;
                opacity: 0;
            }
        }

        /* Enhanced Loading Spinner */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 2000;
            backdrop-filter: blur(2px);
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(52, 152, 219, 0.3);
            border-top: 4px solid #3498db;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            background: white;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loading-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            margin-top: 80px;
            color: white;
            font-weight: 600;
            font-size: 16px;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.5);
        }

        /* Professional Bet Slip Styles */
        #bet-slip-content {
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .bet-slip-empty {
            text-align: center;
            padding: 40px 20px;
            color: #888;
        }
        
        .bet-slip-empty-icon {
            font-size: 48px;
            margin-bottom: 10px;
            opacity: 0.5;
        }
        
        .bet-slip-item {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 12px;
            position: relative;
            border: 1px solid rgba(255,255,255,0.1);
            transition: all 0.3s ease;
        }
        
        .bet-slip-item:hover {
            background: rgba(255,255,255,0.08);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
        }
        
        .bet-slip-remove {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #ff4444;
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            transition: all 0.2s ease;
        }
        
        .bet-slip-remove:hover {
            background: #ff6666;
            transform: scale(1.1);
        }
        
        .bet-slip-item-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
        }
        
        .bet-slip-selection {
            font-weight: 600;
            color: #4CAF50;
            font-size: 14px;
        }
        
        .bet-slip-odds {
            background: #4CAF50;
            color: white;
            padding: 4px 10px;
            border-radius: 20px;
            font-weight: bold;
            font-size: 14px;
        }
        
        .bet-slip-match {
            color: #aaa;
            font-size: 12px;
            margin-bottom: 10px;
        }
        
        .bet-slip-stake {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .bet-slip-stake-input {
            background: rgba(255,255,255,0.1);
            border: 1px solid rgba(255,255,255,0.2);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            width: 100px;
            font-size: 14px;
            transition: all 0.2s ease;
        }
        
        .bet-slip-stake-input:focus {
            background: rgba(255,255,255,0.15);
            border-color: #4CAF50;
            outline: none;
        }
        
        .bet-slip-returns {
            text-align: right;
            color: #4CAF50;
            font-weight: 600;
            font-size: 14px;
        }
        
        .bet-slip-summary {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            padding: 15px;
            margin-top: 20px;
            border: 1px solid rgba(255,255,255,0.1);
        }
        
        .bet-slip-total {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 14px;
        }
        
        .bet-slip-total-label {
            color: #aaa;
        }
        
        .bet-slip-total-value {
            color: white;
            font-weight: 600;
        }
        
        .bet-slip-potential-win {
            display: flex;
            justify-content: space-between;
            padding-top: 10px;
            border-top: 1px solid rgba(255,255,255,0.1);
            margin-bottom: 15px;
        }
        
        .bet-slip-potential-win span:first-child {
            color: #aaa;
            font-size: 14px;
        }
        
        .bet-slip-potential-win span:last-child {
            color: #4CAF50;
            font-size: 18px;
            font-weight: bold;
        }
        
        .bet-slip-actions {
            display: flex;
            gap: 10px;
        }
        
        .bet-slip-clear-btn {
            background: rgba(255,255,255,0.1);
            color: #aaa;
            border: 1px solid rgba(255,255,255,0.2);
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s ease;
            font-weight: 600;
        }
        
        .bet-slip-clear-btn:hover {
            background: rgba(255,255,255,0.15);
            color: white;
        }
        
        .bet-slip-place-btn {
            flex: 1;
            background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            font-size: 16px;
            transition: all 0.2s ease;
            position: relative;
            overflow: hidden;
        }
        
        .bet-slip-place-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(76, 175, 80, 0.4);
        }
        
        .bet-slip-place-btn:active {
            transform: translateY(0);
        }
        
        .bet-slip-place-btn:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        
        /* Bet Type Toggle Switch */
        .bet-type-toggle {
            margin: 10px 0;
        }
        
        .bet-type-switch {
            position: relative;
            display: inline-block;
            width: 100%;
            height: 32px;
        }
        
        .bet-type-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .bet-type-switch .slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            transition: .4s;
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
        }
        
        .bet-type-switch .slider:before {
            position: absolute;
            content: "";
            height: 24px;
            width: 45%;
            left: 4px;
            bottom: 4px;
            background-color: white;
            transition: .4s;
            border-radius: 12px;
        }
        
        .bet-type-switch input:checked + .slider:before {
            transform: translateX(0);
        }
        
        .bet-type-switch input:not(:checked) + .slider:before {
            transform: translateX(100%);
        }
        
        .bet-type-switch .label-single,
        .bet-type-switch .label-combi {
            font-size: 12px;
            font-weight: 600;
            color: white;
            z-index: 1;
            position: relative;
        }
        
        .bet-slip-section {
            background: rgba(255,255,255,0.05);
            border-radius: 10px;
            padding: 15px;
            margin: 10px 0;
        }
        
        .bet-slip-section h4 {
            margin: 0 0 10px 0;
            color: #4CAF50;
            font-size: 14px;
            font-weight: 600;
        }
        
        .bet-type-btn:hover:not(.active) {
            background: rgba(255,255,255,0.1);
            color: white;
        }
        
        .enhanced-bet-slip {
            background: var(--card-bg);
            border-radius: 12px;
            padding: 1.5rem;
        }
        
        .bet-slip-header {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            padding: 16px;
            border-radius: 12px 12px 0 0;
            margin-bottom: 16px;
        }

        .bet-slip-header h3 {
            margin: 0 0 8px 0;
            font-size: 18px;
            font-weight: 600;
        }

        .bet-progress {
            background: rgba(255, 255, 255, 0.2);
            height: 6px;
            border-radius: 3px;
            overflow: hidden;
        }

        .bet-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #f1c40f, #f39c12);
            border-radius: 3px;
            transition: width 0.5s ease;
            animation: progressPulse 2s ease-in-out infinite;
        }

        @keyframes progressPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .bet-items {
            margin-bottom: 16px;
        }

        .enhanced-bet-item {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid rgba(52, 152, 219, 0.1);
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 12px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.05);
            transition: all 0.3s ease;
            animation: betItemSlideIn 0.4s ease-out forwards;
            opacity: 0;
            transform: translateX(-20px);
        }

        @keyframes betItemSlideIn {
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .enhanced-bet-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .bet-match {
            font-weight: 600;
            color: #2c3e50;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .bet-selection {
            color: #7f8c8d;
            font-size: 13px;
            margin-bottom: 8px;
        }

        .bet-odds-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .bet-odds-label {
            font-size: 12px;
            color: #95a5a6;
        }

        .bet-odds-value {
            font-weight: 600;
            color: #27ae60;
            font-size: 14px;
        }

        .remove-bet-btn {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .remove-bet-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(231, 76, 60, 0.3);
        }

        .combined-odds-section {
            margin-bottom: 16px;
        }

        .combined-odds-card {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            padding: 16px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(243, 156, 18, 0.3);
            transition: all 0.3s ease;
        }

        .combined-odds-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(243, 156, 18, 0.4);
        }

        .combined-odds-label {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 4px;
        }

        .combined-odds-value {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        }

        .enhanced-stake-section {
            background: linear-gradient(135deg, #ffffff 0%, #f8f9fa 100%);
            border: 1px solid rgba(52, 152, 219, 0.1);
            border-radius: 10px;
            padding: 16px;
            margin-bottom: 16px;
        }

        .stake-header {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
            font-size: 16px;
        }

        .current-stake-display {
            font-size: 20px;
            font-weight: bold;
            color: #f39c12;
            text-align: center;
            margin-bottom: 12px;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
        }

        .quick-stakes-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .enhanced-quick-stake {
            background: linear-gradient(135deg, #3498db, #2980b9);
            color: white;
            border: none;
            padding: 8px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        .enhanced-quick-stake:hover {
            transform: translateY(-1px);
            box-shadow: 0 3px 8px rgba(52, 152, 219, 0.3);
        }

        .enhanced-stake-input {
            width: 100%;
            padding: 12px;
            border: 2px solid #ecf0f1;
            border-radius: 8px;
            font-size: 16px;
            text-align: center;
            transition: all 0.3s ease;
        }

        .enhanced-stake-input:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 10px rgba(52, 152, 219, 0.2);
        }

        .potential-win-section {
            margin-bottom: 16px;
        }

        .potential-win-card {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            padding: 16px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 12px rgba(39, 174, 96, 0.3);
            transition: all 0.3s ease;
        }

        .potential-win-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(39, 174, 96, 0.4);
        }

        .potential-win-label {
            font-size: 14px;
            opacity: 0.9;
            margin-bottom: 4px;
        }

        .potential-win-value {
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
            margin-bottom: 4px;
        }

        .potential-profit {
            font-size: 12px;
            opacity: 0.9;
        }

        .enhanced-place-bet-btn {
            width: 100%;
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
            border: none;
            padding: 16px;
            border-radius: 10px;
            font-size: 18px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        .enhanced-place-bet-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(231, 76, 60, 0.4);
        }

        .enhanced-place-bet-btn:active {
            transform: translateY(0);
        }

        .bet-btn-icon {
            font-size: 20px;
        }

        .bet-btn-text {
            font-size: 16px;
        }

        /* Mobile-First Responsive Enhancements */
        @media (max-width: 768px) {
            .container {
                padding: 16px 12px;
            }

            .header-content {
                padding: 0 12px;
            }

            .header-content h1 {
                font-size: 20px;
            }

            .coins-display {
                font-size: 14px;
            }

            .profile-btn {
                padding: 6px 12px;
                font-size: 12px;
            }

            /* Enhanced Mobile Navigation */
            .nav-tabs {
                margin-bottom: 16px;
                border-radius: 8px;
            }

            .nav-tab {
                padding: 14px 8px;
                font-size: 13px;
                min-height: 48px;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            /* Mobile Match Cards */
            .tab-content {
                padding: 16px;
                border-radius: 12px;
            }

            .match-card {
                padding: 20px 16px;
                margin-bottom: 16px;
                border-radius: 10px;
            }

            .teams-display {
                gap: 12px;
                margin-bottom: 10px;
            }

            .team {
                max-width: 100px;
                gap: 6px;
            }

            .team-logo {
                font-size: 28px;
            }

            .team-name {
                font-size: 14px;
            }

            .vs-divider {
                font-size: 12px;
                padding: 6px 10px;
            }

            .match-info {
                padding: 6px 0;
            }

            .match-time, .match-league {
                font-size: 12px;
            }

            /* Mobile Betting Options */
            .market-section {
                margin-bottom: 12px;
            }

            .market-title {
                font-size: 14px;
                margin-bottom: 8px;
            }

            .market-odds {
                gap: 6px;
                flex-wrap: wrap;
            }

            .odds-button {
                padding: 12px 14px;
                font-size: 13px;
                min-height: 44px;
                min-width: 80px;
                flex: 1;
                margin: 2px;
            }

            /* Mobile Bet Slip */
            .bet-slip-header {
                padding: 12px;
                border-radius: 8px 8px 0 0;
            }

            .bet-slip-header h3 {
                font-size: 16px;
            }

            .enhanced-bet-item {
                padding: 12px;
                margin-bottom: 8px;
            }

            .bet-match {
                font-size: 13px;
            }

            .bet-selection {
                font-size: 12px;
            }

            .combined-odds-card, .potential-win-card {
                padding: 12px;
            }

            .combined-odds-value, .potential-win-value {
                font-size: 20px;
            }

            .enhanced-stake-section {
                padding: 12px;
            }

            .current-stake-display {
                font-size: 18px;
            }

            .quick-stakes-grid {
                gap: 6px;
            }

            .enhanced-quick-stake {
                padding: 10px 6px;
                font-size: 12px;
                min-height: 40px;
            }

            .enhanced-stake-input {
                padding: 10px;
                font-size: 14px;
            }

            .enhanced-place-bet-btn {
                padding: 14px;
                font-size: 16px;
                min-height: 52px;
            }

            /* Mobile Modal */
            .modal-content {
                margin: 5% auto;
                padding: 20px;
                width: 95%;
                border-radius: 12px;
            }

            .stat-item {
                padding: 10px 0;
                font-size: 14px;
            }

            /* Mobile Rankings */
            #rankings-content .stat-item {
                padding: 12px 0;
                font-size: 14px;
            }
        }

        /* Large Mobile / Small Tablet */
        @media (max-width: 480px) {
            .header-content h1 {
                font-size: 18px;
            }

            .nav-tab {
                padding: 12px 6px;
                font-size: 12px;
            }

            .team {
                max-width: 80px;
            }

            .team-logo {
                font-size: 24px;
            }

            .team-name {
                font-size: 12px;
            }

            .odds-button {
                padding: 10px 8px;
                font-size: 12px;
                min-width: 70px;
            }

            .market-odds {
                justify-content: center;
            }

            .enhanced-quick-stake {
                padding: 8px 4px;
                font-size: 11px;
            }
        }

        /* Touch Improvements */
        @media (hover: none) and (pointer: coarse) {
            .odds-button:hover {
                transform: none;
            }

            .odds-button:active {
                transform: scale(0.98);
                background: linear-gradient(135deg, #e9ecef 0%, #dee2e6 100%);
            }

            .nav-tab:hover:not(.active) {
                transform: none;
            }

            .nav-tab:active {
                transform: scale(0.98);
            }

            .enhanced-quick-stake:hover {
                transform: none;
            }

            .enhanced-quick-stake:active {
                transform: scale(0.95);
            }

            .enhanced-place-bet-btn:hover {
                transform: none;
            }

            .enhanced-place-bet-btn:active {
                transform: scale(0.98);
            }
        }

        /* Professional My Bets Styling */
        .empty-bets-state {
            text-align: center;
            padding: 60px 20px;
            color: #7f8c8d;
        }

        .empty-bets-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.7;
        }

        .empty-bets-title {
            font-size: 24px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .empty-bets-subtitle {
            font-size: 16px;
            opacity: 0.8;
        }

        .my-bets-header {
            margin-bottom: 24px;
            padding-bottom: 16px;
            border-bottom: 2px solid rgba(52, 152, 219, 0.1);
        }

        .my-bets-header h3 {
            margin: 0 0 8px 0;
            font-size: 22px;
            font-weight: 600;
            color: #2c3e50;
        }

        .bets-summary {
            font-size: 14px;
            color: #7f8c8d;
            font-weight: 500;
        }

        .bet-history-cards {
            display: flex;
            flex-direction: column;
            gap: 16px;
        }

        .professional-bet-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.9) 100%);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            border: 1px solid rgba(52, 152, 219, 0.1);
            box-shadow: 
                0 4px 12px rgba(0, 0, 0, 0.08),
                0 2px 4px rgba(0, 0, 0, 0.04);
            overflow: hidden;
            transition: all 0.3s ease;
            animation: betCardSlideIn 0.5s ease-out forwards;
            opacity: 0;
            transform: translateY(20px);
        }

        @keyframes betCardSlideIn {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .professional-bet-card:hover {
            transform: translateY(-2px);
            box-shadow: 
                0 8px 25px rgba(0, 0, 0, 0.12),
                0 4px 8px rgba(0, 0, 0, 0.06);
        }

        .bet-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 16px 20px;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.05) 0%, rgba(41, 128, 185, 0.05) 100%);
            border-bottom: 1px solid rgba(52, 152, 219, 0.1);
        }

        .bet-card-title {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .bet-id {
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .bet-date {
            font-size: 12px;
            color: #7f8c8d;
            font-weight: 500;
        }

        .bet-status-badge {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 6px 12px;
            border-radius: 20px;
            color: white;
            font-size: 12px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        .status-icon {
            font-size: 14px;
        }

        .bet-card-content {
            padding: 20px;
        }

        .bet-selections {
            margin-bottom: 16px;
        }

        .bet-selection-item {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.03) 0%, rgba(41, 128, 185, 0.03) 100%);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 8px;
            border-left: 3px solid #3498db;
        }

        .bet-selection-item:last-child {
            margin-bottom: 0;
        }

        .selection-match {
            font-weight: 600;
            color: #2c3e50;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .selection-details {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .selection-text {
            font-size: 13px;
            color: #7f8c8d;
        }

        .selection-odds {
            font-size: 13px;
            font-weight: 600;
            color: #27ae60;
            background: rgba(39, 174, 96, 0.1);
            padding: 2px 8px;
            border-radius: 12px;
        }

        .bet-card-footer {
            border-top: 1px solid rgba(52, 152, 219, 0.1);
            padding-top: 16px;
        }

        .bet-financial-info {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 16px;
        }

        .bet-stake, .bet-odds, .bet-potential {
            text-align: center;
            padding: 8px;
            border-radius: 8px;
            background: rgba(52, 152, 219, 0.05);
        }

        .bet-potential.won {
            background: rgba(39, 174, 96, 0.1);
        }

        .bet-potential.lost {
            background: rgba(231, 76, 60, 0.1);
        }

        .bet-financial-info .label {
            display: block;
            font-size: 11px;
            color: #7f8c8d;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .bet-financial-info .value {
            display: block;
            font-size: 14px;
            font-weight: 600;
            color: #2c3e50;
        }

        .bet-potential.won .value {
            color: #27ae60;
        }

        .bet-potential.lost .value {
            color: #e74c3c;
        }

        /* Mobile Responsive for Bet Cards */
        @media (max-width: 768px) {
            .professional-bet-card {
                border-radius: 8px;
            }

            .bet-card-header {
                padding: 12px 16px;
            }

            .bet-card-content {
                padding: 16px;
            }

            .bet-financial-info {
                grid-template-columns: 1fr;
                gap: 8px;
            }

            .bet-stake, .bet-odds, .bet-potential {
                display: flex;
                justify-content: space-between;
                align-items: center;
                text-align: left;
                padding: 8px 12px;
            }

            .bet-financial-info .label {
                margin-bottom: 0;
            }
        }

        /* Enhanced Profile Modal Styling */
        .enhanced-modal-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.9) 100%);
            backdrop-filter: blur(20px);
            margin: 2% auto;
            padding: 0;
            border: 1px solid rgba(52, 152, 219, 0.2);
            border-radius: 20px;
            width: 90%;
            max-width: 600px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 
                0 20px 60px rgba(0, 0, 0, 0.15),
                0 8px 25px rgba(0, 0, 0, 0.1);
            animation: modalSlideIn 0.4s ease-out;
        }

        .profile-header {
            text-align: center;
            padding: 30px 30px 20px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border-radius: 20px 20px 0 0;
        }

        .profile-avatar {
            font-size: 48px;
            margin-bottom: 12px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }

        .profile-header h2 {
            margin: 0 0 8px 0;
            font-size: 24px;
            font-weight: 600;
        }

        .profile-subtitle {
            font-size: 14px;
            opacity: 0.9;
            font-weight: 400;
        }

        .balance-showcase {
            text-align: center;
            padding: 25px;
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1) 0%, rgba(46, 204, 113, 0.1) 100%);
            margin: 20px;
            border-radius: 15px;
            border: 2px solid rgba(39, 174, 96, 0.2);
        }

        .balance-label {
            font-size: 14px;
            color: #27ae60;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 8px;
        }

        .balance-amount {
            font-size: 36px;
            font-weight: 700;
            color: #27ae60;
            margin-bottom: 4px;
            text-shadow: 0 2px 4px rgba(39, 174, 96, 0.2);
        }

        .balance-suffix {
            font-size: 16px;
            color: #7f8c8d;
            font-weight: 500;
        }

        .achievements-section {
            padding: 0 25px 20px;
        }

        .achievements-section h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #2c3e50;
            font-weight: 600;
        }

        .achievement-badges {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
        }

        .achievement-badge {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
            box-shadow: 0 3px 8px rgba(243, 156, 18, 0.3);
            animation: badgeGlow 2s ease-in-out infinite alternate;
        }

        @keyframes badgeGlow {
            from { box-shadow: 0 3px 8px rgba(243, 156, 18, 0.3); }
            to { box-shadow: 0 3px 15px rgba(243, 156, 18, 0.5); }
        }

        .achievement-badge.premium {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
            box-shadow: 0 3px 8px rgba(155, 89, 182, 0.3);
        }

        .achievement-badge.premium:hover {
            box-shadow: 0 3px 15px rgba(155, 89, 182, 0.5);
        }

        .positive-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            padding: 0 25px 20px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.8) 0%, rgba(248, 249, 250, 0.6) 100%);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px 15px;
            text-align: center;
            border: 1px solid rgba(52, 152, 219, 0.1);
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .stat-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 3px;
            background: linear-gradient(90deg, #3498db, #2980b9);
        }

        .stat-card.success-stat::before {
            background: linear-gradient(90deg, #27ae60, #2ecc71);
        }

        .stat-card.highlight-stat::before {
            background: linear-gradient(90deg, #f39c12, #e67e22);
        }

        .stat-card.streak-stat::before {
            background: linear-gradient(90deg, #e74c3c, #c0392b);
        }

        .stat-card.odds-stat::before {
            background: linear-gradient(90deg, #9b59b6, #8e44ad);
        }

        .stat-card.combined-odds-stat::before {
            background: linear-gradient(90deg, #16a085, #1abc9c);
        }

        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.1);
        }

        .stat-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #2c3e50;
            margin-bottom: 4px;
        }

        .stat-label {
            font-size: 12px;
            color: #7f8c8d;
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .progress-section {
            padding: 0 25px 20px;
        }

        .progress-section h3 {
            margin: 0 0 15px 0;
            font-size: 18px;
            color: #2c3e50;
            font-weight: 600;
        }

        .progress-item {
            background: rgba(52, 152, 219, 0.05);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(52, 152, 219, 0.1);
        }

        .progress-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            font-weight: 600;
            color: #2c3e50;
        }

        .progress-bar-container {
            background: rgba(52, 152, 219, 0.1);
            border-radius: 10px;
            height: 8px;
            overflow: hidden;
            margin-bottom: 8px;
        }

        .progress-bar {
            background: linear-gradient(90deg, #3498db, #2980b9);
            height: 100%;
            border-radius: 10px;
            transition: width 0.8s ease;
            position: relative;
        }

        .progress-bar::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.3), transparent);
            animation: shimmer 2s infinite;
        }

        @keyframes shimmer {
            0% { transform: translateX(-100%); }
            100% { transform: translateX(100%); }
        }

        .progress-label {
            font-size: 12px;
            color: #7f8c8d;
            font-style: italic;
        }

        .profile-footer {
            padding: 20px 25px 25px;
            text-align: center;
        }

        .motivational-message {
            background: linear-gradient(135deg, rgba(46, 204, 113, 0.1) 0%, rgba(39, 174, 96, 0.1) 100%);
            color: #27ae60;
            padding: 15px 20px;
            border-radius: 12px;
            font-weight: 500;
            border: 1px solid rgba(39, 174, 96, 0.2);
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.02); }
        }

        /* Mobile Responsive for Enhanced Profile Modal */
        @media (max-width: 768px) {
            .enhanced-modal-content {
                width: 95%;
                margin: 5% auto;
                border-radius: 15px;
            }

            .profile-header {
                padding: 25px 20px 15px;
                border-radius: 15px 15px 0 0;
            }

            .profile-avatar {
                font-size: 40px;
            }

            .profile-header h2 {
                font-size: 20px;
            }

            .balance-showcase {
                margin: 15px;
                padding: 20px;
            }

            .balance-amount {
                font-size: 28px;
            }

            .positive-stats-grid {
                grid-template-columns: repeat(2, 1fr);
                gap: 10px;
                padding: 0 15px 15px;
            }

            .stat-card {
                padding: 15px 10px;
            }

            .stat-icon {
                font-size: 20px;
            }

            .stat-value {
                font-size: 20px;
            }

            .achievements-section,
            .progress-section {
                padding: 0 15px 15px;
            }

            .profile-footer {
                padding: 15px;
            }
        }

        /* Private League System Styling */
        .leagues-header {
            text-align: center;
            margin-bottom: 30px;
        }

        .leagues-header h2 {
            margin: 0 0 8px 0;
            font-size: 28px;
            font-weight: 600;
            color: #2c3e50;
        }

        .leagues-subtitle {
            color: #7f8c8d;
            font-size: 16px;
            margin: 0;
        }

        .league-actions {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-bottom: 40px;
        }

        .create-league-btn, .join-league-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 15px 25px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .create-league-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .join-league-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
        }

        .create-league-btn:hover, .join-league-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.15);
        }

        .btn-icon {
            font-size: 18px;
        }

        .my-leagues-section {
            margin-bottom: 30px;
        }

        .my-leagues-section h3 {
            margin: 0 0 20px 0;
            font-size: 22px;
            font-weight: 600;
            color: #2c3e50;
        }

        .leagues-list {
            display: grid;
            gap: 15px;
        }

        .league-card {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.9) 100%);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 20px;
            border: 1px solid rgba(52, 152, 219, 0.1);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.08);
            transition: all 0.3s ease;
            cursor: pointer;
        }

        .league-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.12);
        }

        .league-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .league-name {
            font-size: 18px;
            font-weight: 600;
            color: #2c3e50;
        }

        .league-role {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            color: white;
            padding: 4px 12px;
            border-radius: 15px;
            font-size: 12px;
            font-weight: 600;
        }

        .league-role.admin {
            background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%);
        }

        .league-stats-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .league-stat {
            text-align: center;
        }

        .league-stat-value {
            font-size: 16px;
            font-weight: 600;
            color: #3498db;
        }

        .league-stat-label {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .empty-leagues {
            text-align: center;
            padding: 60px 20px;
            color: #7f8c8d;
        }

        .empty-leagues-icon {
            font-size: 64px;
            margin-bottom: 16px;
            opacity: 0.7;
        }

        .empty-leagues-title {
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 8px;
        }

        .empty-leagues-subtitle {
            font-size: 14px;
            opacity: 0.8;
        }

        /* League Modal Styling */
        .league-modal {
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(5px);
            display: flex;
            justify-content: center;
            align-items: center;
            animation: fadeIn 0.3s ease;
        }

        .league-modal-content {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.95) 0%, rgba(248, 249, 250, 0.9) 100%);
            backdrop-filter: blur(20px);
            border-radius: 15px;
            width: 90%;
            max-width: 500px;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.15);
            animation: slideIn 0.3s ease;
        }

        .league-modal-content.large {
            max-width: 700px;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(-50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 25px;
            border-bottom: 1px solid rgba(52, 152, 219, 0.1);
        }

        .modal-header h3 {
            margin: 0;
            font-size: 20px;
            font-weight: 600;
            color: #2c3e50;
        }

        .modal-body {
            padding: 25px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #2c3e50;
        }

        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid rgba(52, 152, 219, 0.1);
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            background: rgba(255, 255, 255, 0.8);
        }

        .form-group input:focus, .form-group textarea:focus, .form-group select:focus {
            outline: none;
            border-color: #3498db;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .input-help {
            font-size: 12px;
            color: #7f8c8d;
            margin-top: 5px;
        }

        .league-settings {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            background: rgba(52, 152, 219, 0.05);
            border-radius: 8px;
            font-size: 14px;
        }

        .setting-icon {
            font-size: 16px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
            padding: 20px 25px;
            border-top: 1px solid rgba(52, 152, 219, 0.1);
        }

        .modal-footer button {
            padding: 10px 20px;
            border: none;
            border-radius: 8px;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .cancel-btn {
            background: #ecf0f1;
            color: #7f8c8d;
        }

        .cancel-btn:hover {
            background: #d5dbdb;
        }

        .create-btn, .join-btn, .close-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
        }

        .create-btn:hover, .join-btn:hover, .close-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .leave-league-btn {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
            color: white;
        }

        .leave-league-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(231, 76, 60, 0.3);
        }

        /* League Details Styling */
        .league-info-section {
            margin-bottom: 25px;
        }

        .league-code-display {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 15px;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1) 0%, rgba(41, 128, 185, 0.1) 100%);
            border-radius: 10px;
            margin-bottom: 20px;
        }

        .code-label {
            font-weight: 600;
            color: #2c3e50;
        }

        .code-value {
            font-family: 'Courier New', monospace;
            font-size: 18px;
            font-weight: 700;
            color: #3498db;
            background: white;
            padding: 5px 10px;
            border-radius: 5px;
            letter-spacing: 2px;
        }

        .copy-code-btn {
            background: #3498db;
            color: white;
            border: none;
            padding: 5px 10px;
            border-radius: 5px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.3s ease;
        }

        .copy-code-btn:hover {
            background: #2980b9;
        }

        .league-stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 10px;
            border: 1px solid rgba(52, 152, 219, 0.1);
        }

        .stat-value {
            font-size: 24px;
            font-weight: 700;
            color: #3498db;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 12px;
            color: #7f8c8d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .league-leaderboard-section, .league-members-section {
            margin-bottom: 25px;
        }

        .league-leaderboard-section h4, .league-members-section h4 {
            margin: 0 0 15px 0;
            font-size: 16px;
            font-weight: 600;
            color: #2c3e50;
        }

        .league-leaderboard, .league-members {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .leaderboard-item, .member-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 15px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            border: 1px solid rgba(52, 152, 219, 0.1);
        }

        .member-info {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .member-avatar {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-weight: 600;
            font-size: 14px;
        }

        .member-name {
            font-weight: 600;
            color: #2c3e50;
        }

        .member-role {
            font-size: 12px;
            color: #7f8c8d;
        }

        .member-score {
            font-weight: 600;
            color: #27ae60;
        }

        /* Mobile Responsive for Leagues */
        @media (max-width: 768px) {
            .league-actions {
                flex-direction: column;
                align-items: center;
            }

            .create-league-btn, .join-league-btn {
                width: 100%;
                max-width: 300px;
            }

            .league-modal-content {
                width: 95%;
                margin: 10px;
            }

            .modal-header, .modal-body, .modal-footer {
                padding: 15px 20px;
            }

            .league-stats {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .modal-footer {
                flex-direction: column;
            }

            .modal-footer button {
                width: 100%;
            }
        }

        /* Data Management Section Styling */
        .data-management-section {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.05) 0%, rgba(41, 128, 185, 0.05) 100%);
            border-radius: 12px;
            padding: 20px;
            margin: 20px 0;
            border: 1px solid rgba(52, 152, 219, 0.1);
        }

        .data-management-section h3 {
            color: #2c3e50;
            margin-bottom: 16px;
            font-size: 18px;
            font-weight: 600;
        }

        .data-management-info {
            display: grid;
            grid-template-columns: 1fr;
            gap: 8px;
            margin-bottom: 16px;
            background: rgba(255, 255, 255, 0.5);
            padding: 12px;
            border-radius: 8px;
        }

        .data-version-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 14px;
        }

        .data-label {
            color: #7f8c8d;
            font-weight: 500;
        }

        .data-value {
            color: #2c3e50;
            font-weight: 600;
            font-family: 'Courier New', monospace;
        }

        .data-management-actions {
            display: flex;
            gap: 12px;
            margin-bottom: 16px;
            flex-wrap: wrap;
        }

        .data-btn {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.3s ease;
            flex: 1;
            min-width: 140px;
            justify-content: center;
        }

        .export-btn {
            background: linear-gradient(135deg, #27ae60 0%, #2ecc71 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(46, 204, 113, 0.3);
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(46, 204, 113, 0.4);
        }

        .import-btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            box-shadow: 0 2px 8px rgba(52, 152, 219, 0.3);
        }

        .import-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.4);
        }

        .data-management-help {
            background: rgba(241, 196, 15, 0.1);
            border-left: 3px solid #f1c40f;
            padding: 12px;
            border-radius: 0 8px 8px 0;
        }

        .data-management-help p {
            margin: 0;
            font-size: 13px;
            color: #7f8c8d;
            line-height: 1.4;
        }

        @media (max-width: 768px) {
            .data-management-actions {
                flex-direction: column;
            }
            
            .data-btn {
                min-width: auto;
                width: 100%;
            }
        }

        /* Sticky Mobile Bet Bar */
        .mobile-betbar {
            position: fixed;
            left: 0;
            right: 0;
            bottom: 0;
            background: linear-gradient(90deg, #4F46E5 0%, #7C3AED 100%);
            color: #ffffff;
            padding: 10px 12px;
            padding-bottom: calc(10px + env(safe-area-inset-bottom));
            box-shadow: 0 -6px 20px rgba(0,0,0,0.25);
            z-index: 999;
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
        }
        .mobile-betbar .bar-content {
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 10px;
            max-width: 980px;
            margin: 0 auto;
        }
        .mobile-betbar .bar-summary {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 700;
        }
        .mobile-betbar .bar-count {
            background: #ffffff;
            color: #4F46E5;
            min-width: 26px;
            height: 26px;
            border-radius: 999px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 0 6px;
            font-size: 13px;
        }
        .mobile-betbar .bar-text {
            font-size: 14px;
        }
        .mobile-betbar .bar-meta {
            display: flex;
            flex-direction: column;
            gap: 2px;
            font-size: 12px;
            opacity: 0.95;
        }
        .mobile-betbar .bar-odds,
        .mobile-betbar .bar-stake {
            font-weight: 600;
        }
        .mobile-betbar .bar-cta {
            background: #ffffff;
            color: #4F46E5;
            padding: 8px 12px;
            border-radius: 10px;
            font-weight: 700;
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        @media (min-width: 769px) {
            .mobile-betbar { display: none !important; }
        }

    </style>
</head>
<body>
    <!-- Authentication Screen -->
    <div id="authScreen" class="auth-screen">
        <div class="auth-card">
            <h1>⚽ ScoreLeague</h1>
            <p>Join the ultimate social betting experience</p>
            <input type="text" id="usernameInput" placeholder="Enter username" required>
            <input type="password" id="passwordInput" placeholder="Password (for online mode)" style="margin-top: 10px;">
            <button onclick="login()">Join Game</button>
            <div style="margin-top: 10px; font-size: 12px; color: #7f8c8d;">
                <em>Password optional - leave blank for demo mode</em>
            </div>
        </div>
    </div>

    <!-- Main App (hidden until authenticated) -->
    <div id="mainApp" class="hidden">
    <header>
        <div class="header-content">
            <div class="header-left"></div>
            <div class="header-center">
                <h1>⚽ ScoreLeague</h1>
            </div>
            <div class="header-right">
                <div class="coins-display">💰 <span id="coins">1000</span> coins</div>
                <button class="profile-btn" onclick="showProfile()">👤 Profile</button>
            </div>
        </div>
    </header>

    <div class="container">
        <nav class="nav-tabs">
            <button class="nav-tab active" onclick="showTab('matches')"><span>⚽ Matches</span></button>
            <button class="nav-tab" id="betslip-tab-btn" onclick="showTab('betslip')" style="position: relative;">
                <span>🎯 Bet Slip</span>
                <span id="betslip-badge" class="badge hidden">0</span>
            </button>
            <button class="nav-tab" onclick="showTab('mybets')" style="display:none;"><span>📋 My Bets</span></button>
            <button class="nav-tab" onclick="showTab('social')"><span>🏆 Social</span></button>
        </nav>
        
        <!-- Sticky mobile Bet Bar (appears when selections exist and not on bet slip) -->
        <div id="mobile-betbar" class="mobile-betbar hidden" onclick="openBetSlipFromBar()">
            <div class="bar-content">
                <div class="bar-summary">
                    <span id="betbar-count" class="bar-count">0</span>
                    <span id="betbar-text" class="bar-text">Auswahlen</span>
                </div>
                <div class="bar-meta">
                    <span id="betbar-odds" class="bar-odds"></span>
                    <span id="betbar-stake" class="bar-stake"></span>
                </div>
                <div class="bar-cta">Wettschein öffnen</div>
            </div>
        </div>

        <!-- MATCHES TAB - VISIBLE BY DEFAULT -->
        <div id="matches-tab" class="tab-content">
            <div class="matches-header">
                <h2 id="matches-title">⚽ Loading Matches...</h2>
                <button id="refresh-matches" class="refresh-btn" onclick="loadRealMatches()" style="display: none;">🔄 Refresh</button>
                <div id="admin-auto-controls" style="display:none; margin-top:8px;">
                    <label style="display:flex; gap:6px; align-items:center; font-size:12px;">
                        <input type="checkbox" id="toggle-auto-fill"> Auto-fill scores
                    </label>
                    <label style="display:flex; gap:6px; align-items:center; font-size:12px;">
                        <input type="checkbox" id="toggle-auto-settle"> Auto-settle finished
                    </label>
                </div>
            </div>
            <div id="matches-container">
                <!-- Matches will be populated here by JavaScript -->
            </div>

            <!-- 2. BUNDESLIGA MATCHES -->
            <div style="margin: 20px 0; padding: 10px; background: #f0f0f0; border-radius: 8px;">
                <h3 style="color: #333; margin-bottom: 15px;">⚽ 2. Bundesliga</h3>
            </div>

            <div class="match-card">
                <div class="match-header">
                    <div class="teams-display">
                        <div class="team">
                            <span class="team-logo">⚫</span>
                            <span class="team-name">FC Nürnberg</span>
                        </div>
                        <div class="vs-divider">VS</div>
                        <div class="team">
                            <span class="team-logo">🔵</span>
                            <span class="team-name">Darmstadt 98</span>
                        </div>
                    </div>
                    <div class="match-info">
                        <span class="match-time">⏰ Friday 18:30</span>
                        <span class="match-league">🏆 2. Bundesliga</span>
                    </div>
                </div>
                
                <div class="market-section">
                    <div class="market-title">Match Result (1X2)</div>
                    <div class="market-odds">
                        <button class="odds-button" onclick="toggleBet('nue-dar-1', 'FC Nürnberg vs Darmstadt', 'FC Nürnberg Win', 2.87, this, event)">1 (2.87)</button>
                        <button class="odds-button" onclick="toggleBet('nue-dar-x', 'FC Nürnberg vs Darmstadt', 'Draw', 3.40, this, event)">X (3.40)</button>
                        <button class="odds-button" onclick="toggleBet('nue-dar-2', 'FC Nürnberg vs Darmstadt', 'Darmstadt Win', 2.50, this, event)">2 (2.50)</button>
                    </div>
                </div>
                
                <div class="market-section">
                    <div class="market-title">Double Chance</div>
                    <div class="market-odds">
                        <button class="odds-button" onclick="toggleBet('nue-dar-1x', 'FC Nürnberg vs Darmstadt', 'FC Nürnberg or Draw', 1.57, this, event)">1X (1.57)</button>
                        <button class="odds-button" onclick="toggleBet('nue-dar-12', 'FC Nürnberg vs Darmstadt', 'FC Nürnberg or Darmstadt', 1.30, this, event)">12 (1.30)</button>
                        <button class="odds-button" onclick="toggleBet('nue-dar-x2', 'FC Nürnberg vs Darmstadt', 'Draw or Darmstadt', 1.44, this, event)">X2 (1.44)</button>
                    </div>
                </div>
            </div>

            <div class="match-card">
                <div class="match-header">
                    <div class="teams-display">
                        <div class="team">
                            <span class="team-logo">🟢</span>
                            <span class="team-name">SC Preußen Münster</span>
                        </div>
                        <div class="vs-divider">VS</div>
                        <div class="team">
                            <span class="team-logo">🔵</span>
                            <span class="team-name">SC Paderborn 07</span>
                        </div>
                    </div>
                    <div class="match-info">
                        <span class="match-time">⏰ Friday 18:30</span>
                        <span class="match-league">🏆 2. Bundesliga</span>
                    </div>
                </div>
                
                <div class="market-section">
                    <div class="market-title">Match Result (1X2)</div>
                    <div class="market-odds">
                        <button class="odds-button" onclick="toggleBet('mue-pad-1', 'SC Preußen Münster vs SC Paderborn', 'Münster Win', 4.20, this, event)">1 (4.20)</button>
                        <button class="odds-button" onclick="toggleBet('mue-pad-x', 'SC Preußen Münster vs SC Paderborn', 'Draw', 3.20, this, event)">X (3.20)</button>
                        <button class="odds-button" onclick="toggleBet('mue-pad-2', 'SC Preußen Münster vs SC Paderborn', 'Paderborn Win', 1.95, this, event)">2 (1.95)</button>
                    </div>
                </div>
                
                <div class="market-section">
                    <div class="market-title">Total Goals</div>
                    <div class="market-odds">
                        <button class="odds-button" onclick="toggleBet('mue-pad-over', 'SC Preußen Münster vs SC Paderborn', 'Over 2.5 Goals', 2.10, this, event)">Over 2.5 (2.10)</button>
                        <button class="odds-button" onclick="toggleBet('mue-pad-under', 'SC Preußen Münster vs SC Paderborn', 'Under 2.5 Goals', 1.70, this, event)">Under 2.5 (1.70)</button>
                    </div>
                </div>
            </div>

            <div class="match-card">
                <div class="match-header">
                    <div class="teams-display">
                        <div class="team">
                            <span class="team-logo">⚪</span>
                            <span class="team-name">Karlsruher SC</span>
                        </div>
                        <div class="vs-divider">VS</div>
                        <div class="team">
                            <span class="team-logo">🔴</span>
                            <span class="team-name">1. FC Köln</span>
                        </div>
                    </div>
                    <div class="match-info">
                        <span class="match-time">⏰ Saturday 13:00</span>
                        <span class="match-league">🏆 2. Bundesliga</span>
                    </div>
                </div>
                
                <div class="market-section">
                    <div class="market-title">Match Result (1X2)</div>
                    <div class="market-odds">
                        <button class="odds-button" onclick="toggleBet('kar-koe-1', 'Karlsruher SC vs 1. FC Köln', 'Karlsruhe Win', 2.65, this, event)">1 (2.65)</button>
                        <button class="odds-button" onclick="toggleBet('kar-koe-x', 'Karlsruher SC vs 1. FC Köln', 'Draw', 3.30, this, event)">X (3.30)</button>
                        <button class="odds-button" onclick="toggleBet('kar-koe-2', 'Karlsruher SC vs 1. FC Köln', 'Köln Win', 2.70, this, event)">2 (2.70)</button>
                    </div>
                </div>
            </div>

            </div> <!-- End matches-container -->
        </div>

        <!-- BET SLIP TAB -->
        <div id="betslip-tab" class="tab-content">
            <style>
                /* Mobile-friendly bet slip styles */
                .bet365-betslip {
                    background: #f0f0f0;
                    border-radius: 8px;
                    padding: 0;
                    margin-top: 10px;
                }
                
                .betslip-header {
                    background: white;
                    padding: 12px;
                    border-bottom: 1px solid #ddd;
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                
                .betslip-count {
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                    font-weight: 600;
                    color: #333;
                }
                
                .count-badge {
                    background: #4F46E5;
                    color: white;
                    width: 24px;
                    height: 24px;
                    border-radius: 50%;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 14px;
                    font-weight: bold;
                }
                
                /* Bet slip options and items */
                .betslip-options {
                    color: #4F46E5;
                    font-size: 14px;
                    cursor: pointer;
                }
                
                .betslip-items {
                    background: white;
                    padding: 12px;
                }
                
                .singles-header {
                    padding: 12px;
                    color: #666;
                    font-size: 12px;
                    border-bottom: 1px solid #eee;
                }
                .bets-subheader {
                    padding: 8px 12px;
                    color: #666;
                    font-size: 12px;
                    border-bottom: 1px solid #eee;
                    background: #fafafa;
                }
                .bet-item.combi {
                    background: #f9fafb;
                }
                
                .bet-item {
                    border-bottom: 1px solid #eee;
                    padding: 12px;
                    position: relative;
                    cursor: pointer;
                    overflow: hidden;
                }
                
                .bet-item:last-child {
                    border-bottom: none;
                }
                
                /* Focused single bet row */
                .bet-item:focus-within {
                    background: #f3f6ff;
                    border-left: 3px solid #4F46E5;
                }
                /* Programmatic focus state to ensure consistent visuals */
                .bet-item.row-focused {
                    background: #f3f6ff;
                    border-left: 3px solid #4F46E5;
                }
                .bet-item .stake-input { cursor: text; }
                
                .bet-remove {
                    position: absolute;
                    left: 8px;
                    top: 12px;
                    width: 20px;
                    height: 20px;
                    background: none;
                    border: none;
                    color: #999;
                    font-size: 18px;
                    cursor: pointer;
                    padding: 0;
                    line-height: 1;
                }
                
                .bet-info {
                    margin-left: 30px;
                    display: grid;
                    grid-template-columns: 1fr auto;
                    align-items: flex-start;
                    column-gap: 12px;
                }
                
                .bet-details { flex: 1; }
                .bet-details {
                    flex: 1;
                    display: flex;
                    flex-direction: column;
                    gap: 3px;
                    min-width: 0; /* allow flex item to shrink to avoid pushing stake input out */
                }
                
                .bet-team {
                    color: #4F46E5;
                    font-weight: 600;
                    font-size: 14px;
                    margin-bottom: 0;
                    line-height: 1.25;
                }
                
                .bet-market {
                    color: #666;
                    font-size: 12px;
                    margin-bottom: 0;
                    line-height: 1.2;
                }
                
                .bet-match-info {
                    color: #999;
                    font-size: 11px;
                    line-height: 1.2;
                }
                
                /* Market tags (e.g., DC, 1X2) */
                .market-tag {
                    display: inline-block;
                    margin-left: 6px;
                    padding: 1px 6px;
                    font-size: 10px;
                    line-height: 1.4;
                    border-radius: 999px;
                    background: #eef2ff;
                    color: #4F46E5;
                    border: 1px solid #c7d2fe;
                    vertical-align: middle;
                }
                .market-tag.double_chance {
                    background: #ede9fe;
                    color: #6d28d9;
                    border-color: #ddd6fe;
                }
                
                .bet-odds-stake {
                    display: grid;
                    grid-auto-flow: column;
                    align-items: center;
                    column-gap: 8px;
                }
                
                .bet-odds {
                    font-weight: 600;
                    font-size: 14px;
                    color: #333;
                    margin-top: 0;
                    line-height: 30px; /* match input height for perfect baseline */
                }
                
                .stake-input-group {
                    position: relative;
                    display: flex;
                    flex-direction: column;
                    width: 72px; /* fixed column so it fits on narrow screens */
                }
                
                .stake-input {
                    width: 72px;
                    padding: 6px 8px;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    text-align: right;
                    font-size: 13px;
                    height: 30px;
                }
                
                .potential-win {
                    display: block;
                    font-size: 11px;
                    color: #666;
                    margin-top: 4px;
                    text-align: right;
                    line-height: 1.2;
                }
                /* Place potential win under the right column in bet-info grid */
                .bet-info > .potential-win { grid-column: 2; justify-self: end; margin-top: 6px; }
                
                /* Quick stake buttons */
                .quick-stakes {
                    padding: 8px;
                    background: white;
                    border-top: 1px solid #eee;
                    display: flex;
                    gap: 6px;
                    overflow-x: auto;
                }
                
                .stake-btn {
                    min-width: 50px;
                    padding: 8px 12px;
                    background: #f5f5f5;
                    border: 1px solid #ddd;
                    border-radius: 4px;
                    font-size: 13px;
                    font-weight: 500;
                    color: #333;
                    cursor: pointer;
                    transition: all 0.2s;
                    white-space: nowrap;
                }
                
                .stake-btn:hover {
                    background: #e8e8e8;
                    border-color: #999;
                }
                
                .stake-btn:active {
                    transform: scale(0.95);
                }
                
                /* Active (selected) quick stake state */
                .stake-btn.active {
                    background: #4F46E5;
                    border-color: #4F46E5;
                    color: #fff;
                }
                /* Active state in combo section (on purple gradient) */
                .combo-section .combo-btn.active {
                    background: #fff !important;
                    color: #4F46E5 !important;
                    border-color: #fff !important;
                }
                
                /* Combination bet section */
                .combo-section {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    color: #fff;
                    margin: 10px 0;
                    padding: 12px;
                    border-radius: 12px;
                    box-shadow: 0 6px 16px rgba(79,70,229,0.25);
                    border: 0;
                }
                
                .combo-header {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 8px;
                }
                
                .combo-title {
                    color: #fff;
                    font-weight: 700;
                    font-size: 16px;
                }
                
                .combo-odds {
                    font-weight: 700;
                    font-size: 20px;
                    color: #fff;
                }
                
                .combo-stake-row {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                }
                
                .combo-stake-input {
                    flex: 1;
                    padding: 10px 12px;
                    border: 1px solid rgba(255,255,255,0.35);
                    border-radius: 8px;
                    font-size: 16px;
                    text-align: center;
                    background: rgba(255,255,255,0.9);
                    color: #1f2937;
                }
                
                .combo-potential {
                    font-size: 16px;
                    color: #fff;
                    margin-top: 8px;
                    font-weight: 600;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 6px;
                    padding-bottom: 12px;
                }
                
                /* Place bet button */
                .place-bet-section {
                    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
                    padding: 12px;
                    position: sticky;
                    bottom: 0;
                    z-index: 10;
                    border-top-left-radius: 12px;
                    border-top-right-radius: 12px;
                    box-shadow: 0 -6px 16px rgba(79,70,229,0.2);
                    padding-bottom: calc(12px + env(safe-area-inset-bottom));
                }
                
                .place-bet-btn {
                    width: 100%;
                    padding: 12px;
                    background: #fff;
                    color: #4F46E5;
                    border: none;
                    border-radius: 10px;
                    font-size: 16px;
                    font-weight: 600;
                    cursor: pointer;
                    transition: all 0.2s;
                }
                
                .place-bet-btn:hover {
                    transform: translateY(-1px);
                    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
                }
                
                .place-bet-btn:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }
                
                .bet-totals {
                    display: flex;
                    justify-content: space-between;
                    margin-top: 8px;
                    padding-top: 8px;
                    border-top: 1px solid rgba(255,255,255,0.3);
                    color: white;
                    font-size: 14px;
                }
                
                /* Combo section interior padding override */
                .combo-inner {
                    padding: 0 12px;
                }
                
                /* Make quick-stakes look like glass chips on gradient */
                .combo-section .quick-stakes {
                    background: transparent;
                    border: none;
                    padding: 8px 0 10px;
                }
                .combo-section .stake-btn {
                    background: rgba(255,255,255,0.2);
                    color: #fff;
                    border: 1px solid rgba(255,255,255,0.35);
                    border-radius: 999px;
                }
                
                /* Singles quick stakes wrapper */
                .singles-quick-wrap {
                    padding: 12px;
                    background: #f9f9f9;
                }
                
                @media (max-width: 480px) {
                    .stake-input {
                        width: 60px;
                    }
                    
                    .quick-stakes {
                        justify-content: space-between;
                    }
                    
                    .stake-btn {
                        flex: 1;
                        min-width: 40px;
                        padding: 8px 6px;
                        font-size: 12px;
                    }
                    /* Tighten mobile spacing for cleaner slip rows */
                    .bet-item { padding: 10px; }
                    .bet-odds-stake { column-gap: 6px; }
                    .bet-team { font-size: 13px; }
                    .bet-market { font-size: 11px; }
                }
            /* Bet Slip nav count bubble */
        #betslip-tab-btn { position: relative; overflow: visible; }
        #betslip-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            min-width: 18px;
            height: 18px;
            padding: 0 6px;
            border-radius: 999px;
            background: linear-gradient(135deg, #7C3AED, #4F46E5);
            color: #fff;
            font-size: 11px;
            font-weight: 700;
            line-height: 18px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 2px 8px rgba(79,70,229,.3);
            z-index: 10;
            pointer-events: none;
            transform: none; /* Override generic .badge transform */
        }
        .nav-tab { overflow: visible; }
        .badge { display: inline-flex; align-items: center; justify-content: center; }
        .badge.hidden { display: none !important; }
        @media (max-width: 768px) {
            #betslip-badge {
                top: 2px;
                right: 4px;
                min-width: 20px;
                height: 20px;
                font-size: 12px;
                line-height: 20px;
            }
        }
        </style>
            
            <div id="bet-slip-content" class="bet365-betslip">
                <!-- Content will be dynamically generated -->
                <div class="betslip-empty" style="padding: 40px; text-align: center; color: #666;">
                    <p style="font-size: 14px;">Noch keine Wetten ausgewählt</p>
                    <p style="font-size: 12px; margin-top: 8px;">Klicken Sie auf die Quoten, um Wetten hinzuzufügen</p>
                </div>
            </div>
        </div>

        <!-- MY BETS TAB -->
        <div id="mybets-tab" class="tab-content">
            <h2>📋 My Bets</h2>
            <div id="my-bets-content">
                <p>No bets placed yet.</p>
            </div>
        </div>

        <!-- SOCIAL TAB (Combined Rankings & Leagues) -->
        <div id="social-tab" class="tab-content">
            <!-- Social Sub-Navigation -->
            <div class="social-nav">
                <button class="social-nav-btn active" onclick="showSocialSection('global')">
                    <span class="social-nav-icon">🌍</span>
                    <span class="social-nav-text">Global Rankings</span>
                </button>
                <button class="social-nav-btn" onclick="showSocialSection('leagues')">
                    <span class="social-nav-icon">👥</span>
                    <span class="social-nav-text">Private Leagues</span>
                </button>
            </div>
            
            <!-- Global Rankings Section -->
            <div id="social-global" class="social-section active">
                <div class="social-header">
                    <h2>🏆 Global Leaderboard</h2>
                    <p class="social-subtitle">See how you rank against players worldwide</p>
                </div>
                <div id="rankings-list" class="rankings-list">
                    <!-- Dynamically populated -->
                </div>
            </div>
            
            <!-- Private Leagues Section -->
            <div id="social-leagues" class="social-section">
                <div class="social-header">
                    <h2>👥 Private Leagues</h2>
                    <p class="social-subtitle">Compete with friends in private betting leagues</p>
                </div>
                
                <!-- League Actions -->
                <div class="league-actions">
                    <button class="create-league-btn" onclick="showCreateLeague()">
                        <span class="btn-icon">🏆</span>
                        <span class="btn-text">Create League</span>
                    </button>
                    <button class="join-league-btn" onclick="showJoinLeague()">
                        <span class="btn-icon">🎯</span>
                        <span class="btn-text">Join League</span>
                    </button>
                </div>
                
                <!-- My Leagues List -->
                <div class="my-leagues-section">
                    <h3>🏅 My Leagues</h3>
                    <div id="my-leagues-list" class="leagues-list">
                        <!-- Dynamically populated -->
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Create League Modal -->
        <div id="createLeagueModal" class="league-modal" style="display: none;">
            <div class="league-modal-content">
                <div class="modal-header">
                    <h3>🏆 Create New League</h3>
                    <span class="close" onclick="closeCreateLeague()">&times;</span>
                </div>
                <div class="modal-body">
                        <div class="form-group">
                            <label for="leagueName">League Name</label>
                            <input type="text" id="leagueName" placeholder="Enter league name (e.g., 'Champions Circle')" maxlength="30">
                        </div>
                        <div class="form-group">
                            <label for="leagueDescription">Description (Optional)</label>
                            <textarea id="leagueDescription" placeholder="Describe your league..." maxlength="100"></textarea>
                        </div>

                        <div class="form-group">
                            <label class="checkbox-label">
                                <input type="checkbox" id="weeklyBonusEnabled" checked>
                                <span class="checkmark"></span>
                                Include in weekly bonus competitions (recommended)
                            </label>
                        </div>
                        <div class="form-group">
                            <label>League Settings</label>
                            <div class="league-settings">
                                <div class="setting-item">
                                    <span>Max Members: 10</span>
                                    <span class="setting-icon">👥</span>
                                </div>
                                <div class="setting-item">
                                    <span>Private League</span>
                                    <span class="setting-icon">🔒</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="cancel-btn" onclick="closeCreateLeague()">Cancel</button>
                        <button class="create-btn" onclick="createLeague()">Create League</button>
                    </div>
                </div>
            </div>
            
            <!-- Join League Modal -->
            <div id="joinLeagueModal" class="league-modal" style="display: none;">
                <div class="league-modal-content">
                    <div class="modal-header">
                        <h3>🎯 Join League</h3>
                        <span class="close" onclick="closeJoinLeague()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <div class="form-group">
                            <label for="leagueCode">League Code</label>
                            <input type="text" id="leagueCode" placeholder="Enter 6-digit league code" maxlength="6">
                            <div class="input-help">Ask your friend for their league code</div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="cancel-btn" onclick="closeJoinLeague()">Cancel</button>
                        <button class="join-btn" onclick="joinLeague()">Join League</button>
                    </div>
                </div>
            </div>
            
            <!-- League Details Modal -->
            <div id="leagueDetailsModal" class="league-modal" style="display: none;">
                <div class="league-modal-content large">
                    <div class="modal-header">
                        <h3 id="leagueDetailsTitle">🏆 League Name</h3>
                        <span class="close" onclick="closeLeagueDetails()">&times;</span>
                    </div>
                    <div class="modal-body">
                        <!-- League Info -->
                        <div class="league-info-section">
                            <div class="league-code-display">
                                <span class="code-label">League Code:</span>
                                <span class="code-value" id="leagueCodeDisplay">ABC123</span>
                                <button class="copy-code-btn" onclick="copyLeagueCode()">📋 Copy</button>
                            </div>
                            <div class="league-stats">
                                <div class="stat-item">
                                    <span class="stat-value" id="leagueMemberCount">1</span>
                                    <span class="stat-label">Members</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-value" id="leagueWeeksActive">0</span>
                                    <span class="stat-label">Weeks Active</span>
                                </div>
                                <div class="stat-item">
                                    <span class="stat-value" id="leagueTotalBets">0</span>
                                    <span class="stat-label">Total Bets</span>
                                </div>
                            </div>
                        </div>
                        
                        <!-- League Leaderboard -->
                        <div class="league-leaderboard-section">
                            <h4>🏅 League Standings</h4>
                            <div id="leagueLeaderboard" class="league-leaderboard">
                                <!-- Dynamically populated -->
                            </div>
                        </div>
                        
                        <!-- League Members -->
                        <div class="league-members-section">
                            <h4>👥 Members</h4>
                            <div id="leagueMembers" class="league-members">
                                <!-- Dynamically populated -->
                            </div>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <button class="leave-league-btn" onclick="leaveLeague()" style="display: none;">Leave League</button>
                        <button class="close-btn" onclick="closeLeagueDetails()">Close</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="rankings-tab" class="tab-content">
            <h2>🏆 Leaderboard</h2>
            <div id="rankings-content">
                <div class="stat-item">
                    <span><strong>1. ProBetter</strong></span>
                    <span>2,450 coins</span>
                </div>
                <div class="stat-item">
                    <span><strong>2. LuckyPunter</strong></span>
                    <span>1,890 coins</span>
                </div>
                <div class="stat-item">
                    <span><strong>3. You</strong></span>
                    <span><span id="coins-ranking">1000</span> coins</span>
                </div>
                <div class="stat-item">
                    <span>4. FootballFan</span>
                    <span>850 coins</span>
                </div>
                <div class="stat-item">
                    <span>5. BetMaster</span>
                    <span>720 coins</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Profile Modal -->
    <div id="profileModal" class="modal">
        <div class="enhanced-modal-content">
            <span class="close" onclick="closeProfile()">&times;</span>
            
            <!-- Profile Header -->
            <div class="profile-header">
                <div class="profile-avatar">🏆</div>
                <h2>Your Betting Journey</h2>
                <div class="profile-subtitle">Celebrating Your Wins & Achievements</div>
            </div>
            
            <!-- Current Balance Highlight -->
            <div class="balance-showcase">
                <div class="balance-label">Current Balance</div>
                <div class="balance-amount" id="profile-coins">1000</div>
                <div class="balance-suffix">coins</div>
            </div>
            
            <!-- Achievement Badges -->
            <div class="achievements-section">
                <h3>🎖️ Your Achievements</h3>
                <div class="achievement-badges" id="achievement-badges">
                    <!-- Dynamically populated -->
                </div>
            </div>
            
            <!-- Positive Statistics Grid -->
            <div class="positive-stats-grid">
                <div class="stat-card success-stat">
                    <div class="stat-icon">💰</div>
                    <div class="stat-value" id="profile-total-winnings">0</div>
                    <div class="stat-label">Total Winnings</div>
                </div>
                
                <div class="stat-card highlight-stat">
                    <div class="stat-icon">🎯</div>
                    <div class="stat-value" id="profile-biggest-win">0</div>
                    <div class="stat-label">Biggest Single Win</div>
                </div>
                
                <div class="stat-card streak-stat">
                    <div class="stat-icon">🔥</div>
                    <div class="stat-value" id="profile-current-streak">0</div>
                    <div class="stat-label">Current Win Streak</div>
                </div>
                
                <div class="stat-card odds-stat">
                    <div class="stat-icon">⚡</div>
                    <div class="stat-value" id="profile-best-odds">1.0</div>
                    <div class="stat-label">Best Odds Hit</div>
                </div>
                
                <div class="stat-card wins-stat">
                    <div class="stat-icon">✅</div>
                    <div class="stat-value" id="profile-successful-bets">0</div>
                    <div class="stat-label">Successful Bets</div>
                </div>
                
                <div class="stat-card milestone-stat">
                    <div class="stat-icon">🏅</div>
                    <div class="stat-value" id="profile-milestones">0</div>
                    <div class="stat-label">Milestones Reached</div>
                </div>
                
                <div class="stat-card combined-odds-stat">
                    <div class="stat-icon">🔄</div>
                    <div class="stat-value" id="profile-total-combined-odds">0.0</div>
                    <div class="stat-label">Total Combined Odds</div>
                </div>
            </div>
            
            <!-- Odds API Key Section -->
            <div class="api-key-section">
                <h3>🔑 Odds API Key</h3>
                <p class="small-note">Provide your personal key from <a href="https://the-odds-api.com" target="_blank">the-odds-api.com</a> to avoid shared rate limits.</p>
                <input type="text" id="api-key-input" placeholder="Enter API key" style="width:100%;padding:8px;border-radius:6px;border:1px solid #ccc;" />
                <button style="margin-top:8px;padding:8px 16px;border:none;background:#4F46E5;color:#fff;border-radius:6px;cursor:pointer;" onclick="saveApiKey()">Save Key</button>
                <div id="api-key-status" style="font-size:12px;color:#4F46E5;margin-top:4px;"></div>
            </div>
            
            <!-- Progress Section -->
            <div class="progress-section">
                <h3>📈 Your Progress</h3>
                <div class="progress-item">
                    <div class="progress-header">
                        <span>Next Achievement</span>
                        <span id="next-achievement-progress">0/100</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-bar" id="achievement-progress-bar"></div>
                    </div>
                    <div class="progress-label" id="next-achievement-label">Reach 100 total winnings</div>
                </div>
            </div>
            
            <!-- Data Management Section -->
            <div class="data-management-section">
                <h3>💾 Data Management</h3>
                <div class="data-management-info">
                    <div class="data-version-info">
                        <span class="data-label">App Version:</span>
                        <span class="data-value" id="app-version-display">1.0.0</span>
                    </div>
                    <div class="data-version-info">
                        <span class="data-label">Data Version:</span>
                        <span class="data-value" id="data-version-display">1.0</span>
                    </div>
                    <div class="data-version-info">
                        <span class="data-label">Last Updated:</span>
                        <span class="data-value" id="last-updated-display">-</span>
                    </div>
                </div>
                
                <div class="data-management-actions">
                    <button class="data-btn export-btn" onclick="exportGameData()">
                        <span class="btn-icon">📤</span>
                        <span class="btn-text">Export Data</span>
                    </button>
                    
                    <button class="data-btn import-btn" onclick="triggerImportData()">
                        <span class="btn-icon">📥</span>
                        <span class="btn-text">Import Data</span>
                    </button>
                    
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleImportData(event)">
                </div>
                
                <div class="data-management-help">
                    <p>💡 <strong>Testing Tip:</strong> Export your data weekly to backup your progress!</p>
                </div>
            </div>
            
            <!-- Motivational Footer -->
            <div class="profile-footer">
                <div class="motivational-message" id="motivational-message">
                    🌟 Keep up the great work! Your betting skills are improving!
                </div>
            </div>
        </div>
    </div>

    <!-- Message container -->
    <div id="message" class="message"></div>

    
    <script>
        // =============================================================================
        // VERSIONED DATA SYSTEM & MIGRATION FRAMEWORK
        // =============================================================================
        
        const APP_VERSION = "1.0.0";
        const DATA_VERSION = "1.0";
        
        // Data structure versioning and migration system
        const DataManager = {
            // Current data schema
            defaultSchema: {
                version: DATA_VERSION,
                appVersion: APP_VERSION,
                createdAt: new Date().toISOString(),
                lastUpdated: new Date().toISOString(),
                
                // Core game data (protected during updates)
                userData: {
                    coins: 1000,
                    totalBetsPlaced: 0,
                    stats: {
                        totalWinnings: 0,
                        biggestWin: 0,
                        currentStreak: 0,
                        successfulBets: 0,
                        bestOdds: 1.0,
                        totalCombinedOdds: 0.0
                    }
                },
                
                // League and tournament data (protected)
                leagues: [],
                tournaments: {},
                
                // Betting data (protected)
                bets: [],
                betSlip: [],
                currentStake: 0,
                
                // Match and results data
                matches: [],
                matchResults: {},
                
                // Feature flags (safe to modify)
                features: {
                    weeklyBonusCompetitions: true,
                    realTimeSync: false,
                    enhancedStats: true,
                    mobileOptimizations: true
                }
            },
            
            // Migration functions for different versions
            migrations: {
                "0.9": function(data) {
                    console.log('📦 Migrating data from v0.9 to v1.0');
                    // Add new fields with defaults
                    if (!data.features) data.features = this.defaultSchema.features;
                    if (!data.userData.stats.totalCombinedOdds) data.userData.stats.totalCombinedOdds = 0.0;
                    data.version = "1.0";
                    return data;
                },
                
                "1.0": function(data) {
                    // Future migration placeholder
                    console.log('📦 Data already at latest version v1.0');
                    return data;
                }
            },
            
            // Initialize or migrate existing data
            initialize: function() {
                console.log('🔧 Initializing ScoreLeague Data Manager v' + APP_VERSION);
                
                // Check for existing data
                const existingData = this.loadFromStorage();
                
                if (existingData) {
                    console.log('📂 Found existing data version:', existingData.version || 'unknown');
                    return this.migrateData(existingData);
                } else {
                    console.log('🆕 Creating fresh data structure');
                    const freshData = JSON.parse(JSON.stringify(this.defaultSchema));
                    this.saveToStorage(freshData);
                    return freshData;
                }
            },
            
            // Migrate data to current version
            migrateData: function(data) {
                const currentVersion = data.version || "0.9";
                
                if (currentVersion === DATA_VERSION) {
                    console.log('✅ Data is current version:', DATA_VERSION);
                    data.lastUpdated = new Date().toISOString();
                    data.appVersion = APP_VERSION;
                    return data;
                }
                
                console.log('🔄 Migrating data from', currentVersion, 'to', DATA_VERSION);
                
                // Apply migration if available
                if (this.migrations[currentVersion]) {
                    data = this.migrations[currentVersion].call(this, data);
                    data.lastUpdated = new Date().toISOString();
                    data.appVersion = APP_VERSION;
                    
                    // Save migrated data
                    this.saveToStorage(data);
                    console.log('✅ Migration completed successfully');
                } else {
                    console.warn('⚠️ No migration available for version', currentVersion);
                }
                
                return data;
            },
            
            // Load data from localStorage with error handling
            loadFromStorage: function() {
                try {
                    const stored = localStorage.getItem('scoreLeagueData');
                    return stored ? JSON.parse(stored) : null;
                } catch (error) {
                    console.error('❌ Error loading data from storage:', error);
                    return null;
                }
            },
            
            // Save data to localStorage with error handling
            saveToStorage: function(data) {
                try {
                    data.lastUpdated = new Date().toISOString();
                    localStorage.setItem('scoreLeagueData', JSON.stringify(data));
                    console.log('💾 Data saved successfully');
                    return true;
                } catch (error) {
                    console.error('❌ Error saving data to storage:', error);
                    return false;
                }
            },
            
            // Export data for backup
            exportData: function() {
                const data = this.loadFromStorage();
                if (data) {
                    const exportData = {
                        ...data,
                        exportedAt: new Date().toISOString(),
                        exportVersion: APP_VERSION
                    };
                    
                    const blob = new Blob([JSON.stringify(exportData, null, 2)], {
                        type: 'application/json'
                    });
                    
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `scoreLeague_backup_${new Date().toISOString().split('T')[0]}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    console.log('📤 Data exported successfully');
                    return true;
                }
                return false;
            },
            
            // Import data from backup
            importData: function(file) {
                return new Promise((resolve, reject) => {
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const importedData = JSON.parse(e.target.result);
                            console.log('📥 Importing data version:', importedData.version || 'unknown');
                            
                            // Migrate imported data if needed
                            const migratedData = this.migrateData(importedData);
                            
                            // Save imported data
                            this.saveToStorage(migratedData);
                            
                            console.log('✅ Data imported and migrated successfully');
                            resolve(migratedData);
                        } catch (error) {
                            console.error('❌ Error importing data:', error);
                            reject(error);
                        }
                    };
                    reader.readAsText(file);
                });
            }
        };
        
        // Initialize the data system
        const gameData = DataManager.initialize();
        
        // Global variables - IMPORTANT: These must be in the global scope
        window.betSlip = gameData.betSlip || [];
        window.coins = gameData.userData.coins || 1000;
        window.currentStake = gameData.currentStake || 0;
        window.totalBetsPlaced = gameData.userData.totalBetsPlaced || 0;
        window.currentBettingMode = 'personal'; // 'personal' or league ID

        console.log('🚀 COMPLETE ScoreLeague Version', APP_VERSION, 'Loaded!', new Date());
        console.log('📊 Game data initialized:', gameData.version, '- Features enabled:', Object.keys(gameData.features).filter(f => gameData.features[f]));
        
        // Function to fetch live odds from The Odds API
        async function fetchLiveOdds() {
            try {
                // Check if the odds API service is available
                if (typeof window.oddsAPIService === 'undefined') {
                    console.log('Odds API service not loaded, using demo matches');
                    return null;
                }
                
                // Fetch odds for multiple leagues
                const [
                    premierLeagueOdds,
                    bundesliga2Odds,
                    bundesligaOdds,
                    championsLeagueOdds,
                    laLigaOdds,
                    serieAOdds
                ] = await Promise.all([
                    window.oddsAPIService.getOdds('soccer_epl', 'uk', 'h2h,totals'),
                    window.oddsAPIService.getOdds('soccer_germany_bundesliga2', 'uk', 'h2h,totals'),
                    window.oddsAPIService.getOdds('soccer_germany_bundesliga', 'uk', 'h2h,totals'),
                    window.oddsAPIService.getOdds('soccer_uefa_champs_league', 'uk', 'h2h,totals'),
                    window.oddsAPIService.getOdds('soccer_spain_la_liga', 'uk', 'h2h,totals'),
                    window.oddsAPIService.getOdds('soccer_italy_serie_a', 'uk', 'h2h,totals')
                ]);
                
                // Process all leagues with proper names
                const allOdds = [
                    { data: premierLeagueOdds, name: 'Premier League' },
                    { data: bundesliga2Odds, name: '2. Bundesliga' },
                    { data: bundesligaOdds, name: 'Bundesliga' },
                    { data: championsLeagueOdds, name: 'Champions League' },
                    { data: laLigaOdds, name: 'La Liga' },
                    { data: serieAOdds, name: 'Serie A' }
                ];
                
                // Track leagues with no available odds so the UI can show a helpful note
                const missingLeagues = allOdds
                    .filter(l => !Array.isArray(l.data) || l.data.length === 0)
                    .map(l => l.name);
                try { window._emptyLeagues = missingLeagues; } catch (_) {}
                
                const matches = [];
                
                allOdds.forEach(league => {
                    if (league.data && Array.isArray(league.data)) {
                        league.data.forEach(match => {
                            if (match.bookmakers && match.bookmakers.length > 0) {
                                const h2h = match.bookmakers[0].markets.find(m => m.key === 'h2h');
                                if (h2h && h2h.outcomes) {
                                    matches.push({
                                        id: match.id,
                                        homeTeam: match.home_team,
                                        awayTeam: match.away_team,
                                        kickoff: new Date(match.commence_time).toLocaleString(),
                                        league: league.name,
                                        odds: {
                                            home: h2h.outcomes.find(o => o.name === match.home_team)?.price || 2.0,
                                            draw: h2h.outcomes.find(o => o.name === 'Draw')?.price || 3.5,
                                            away: h2h.outcomes.find(o => o.name === match.away_team)?.price || 3.0
                                        }
                                    });
                                }
                            }
                        });
                    }
                });
                
                if (matches.length > 0) {
                    console.log(`Live odds loaded: ${matches.length} matches from multiple leagues`);
                    return matches;
                }
                
                return null;
            } catch (error) {
                console.error('Error fetching live odds:', error);
                return null;
            }
        }
        
        // Initialize live odds on page load
        async function initializeLiveOdds() {
            const liveMatches = await fetchLiveOdds();
            if (liveMatches && liveMatches.length > 0) {
                console.log(`Loaded ${liveMatches.length} live matches with real odds`);
                // Update the matches display with live data
                renderLiveMatches(liveMatches);
            } else {
                // No live odds available for requested leagues – add a small non-intrusive banner
                try { renderNoOddsMessage(); } catch (_) {}
            }
        }
        
        // Render a small banner when there are no live odds for requested leagues
        function renderNoOddsMessage() {
            const container = document.getElementById('matches-container');
            const title = document.getElementById('matches-title');
            if (!container) return;
            if (title && !title.textContent) {
                title.textContent = '⚽ Live Matches';
            }
            // Avoid duplicates
            const existing = document.getElementById('no-odds-banner');
            if (existing) existing.remove();
            const missing = Array.isArray(window._emptyLeagues) ? window._emptyLeagues.filter(Boolean) : [];
            const msg = missing.length > 0
                ? `No live odds available right now for: ${missing.join(', ')}.`
                : 'No live odds available right now.';
            const banner = document.createElement('div');
            banner.id = 'no-odds-banner';
            banner.setAttribute('role', 'status');
            banner.style.cssText = 'margin:8px 0; padding:10px; border:1px dashed #3a4157; background:#131a28; color:#b8c7e0; border-radius:6px; font-size:13px;';
            banner.textContent = `${msg} Showing demo or saved matches if available.`;
            container.prepend(banner);
        }
        
        // Render live matches with real odds
        function renderLiveMatches(matches) {
            const matchesContainer = document.getElementById('matches-container');
            if (!matchesContainer) return;
            try { console.log('[renderLiveMatches] IS_ADMIN=', !!window.IS_ADMIN); } catch (_) {}
            const __gate = beginRender('live');
            if (!__gate.allowed) return;
            const __savedAdminInputs = mergeAdminSavedInputs(captureAdminInputs());
            const __activeAdminElId = captureActiveAdminElement();
            const matchesHTML = matches.map(match => {
                const sid = safeId(match.id);
                const adminUI = window.IS_ADMIN ? `
                    <div class="admin-settle" style="margin-top:8px; padding-top:8px; border-top:1px dashed #ccc;">
                        <div style="font-weight:600; font-size:12px; margin-bottom:6px;">Admin: Final Score & Settle</div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <input id="settle-home-${sid}" type="number" min="0" placeholder="${match.homeTeam} goals" style="width:60px; padding:4px;" />
                            <span>:</span>
                            <input id="settle-away-${sid}" type="number" min="0" placeholder="${match.awayTeam} goals" style="width:60px; padding:4px;" />
                            <button id="settle-btn-${sid}" class="odds-button" style="padding:6px 10px;" onclick="adminSettleForCard('${match.id}')">Settle</button>
                        </div>
                    </div>
                ` : '';
                return `
                <div class="match-card real-match" data-match-id="${match.id}" data-status="live" data-home-team="${match.homeTeam}" data-away-team="${match.awayTeam}">
                    <div class="match-header">
                        <span class="match-league">${match.league}</span>
                        <span class="match-time">${match.kickoff}</span>
                    </div>
                    <div class="match-teams">
                        <span class="home-team">${match.homeTeam}</span>
                        <span class="vs">vs</span>
                        <span class="away-team">${match.awayTeam}</span>
                    </div>
                    <div class="match-markets">
                        <div class="market-section">
                            <div class="market-title">Match Result (1X2)</div>
                            <div class="market-odds">
                                <button class="odds-button" onclick="toggleBet('${match.id}-1', '${match.homeTeam} vs ${match.awayTeam}', '${match.homeTeam} Win', ${match.odds.home}, this, event)">
                                    1 (${match.odds.home.toFixed(2)})
                                </button>
                                <button class="odds-button" onclick="toggleBet('${match.id}-x', '${match.homeTeam} vs ${match.awayTeam}', 'Draw', ${match.odds.draw}, this, event)">
                                    X (${match.odds.draw.toFixed(2)})
                                </button>
                                <button class="odds-button" onclick="toggleBet('${match.id}-2', '${match.homeTeam} vs ${match.awayTeam}', '${match.awayTeam} Win', ${match.odds.away}, this, event)">
                                    2 (${match.odds.away.toFixed(2)})
                                </button>
                            </div>
                        </div>
                        <div class="market-section">
                            <div class="market-title">Doppelte Chance</div>
                            <div class="market-odds">
                                <button class="odds-button" onclick="toggleBet('${match.id}-1x', '${match.homeTeam} vs ${match.awayTeam}', '${match.homeTeam} oder Unentschieden', ${(1/((1/Number(match.odds.home)) + (1/Number(match.odds.draw)))).toFixed(2)}, this, event)">
                                    1X (${(1/((1/Number(match.odds.home)) + (1/Number(match.odds.draw)))).toFixed(2)})
                                </button>
                                <button class="odds-button" onclick="toggleBet('${match.id}-12', '${match.homeTeam} vs ${match.awayTeam}', '${match.homeTeam} oder ${match.awayTeam}', ${(1/((1/Number(match.odds.home)) + (1/Number(match.odds.away)))).toFixed(2)}, this, event)">
                                    12 (${(1/((1/Number(match.odds.home)) + (1/Number(match.odds.away)))).toFixed(2)})
                                </button>
                                <button class="odds-button" onclick="toggleBet('${match.id}-x2', '${match.homeTeam} vs ${match.awayTeam}', 'Unentschieden oder ${match.awayTeam}', ${(1/((1/Number(match.odds.draw)) + (1/Number(match.odds.away)))).toFixed(2)}, this, event)">
                                    X2 (${(1/((1/Number(match.odds.draw)) + (1/Number(match.odds.away)))).toFixed(2)})
                                </button>
                            </div>
                        </div>
                    </div>
                    ${adminUI}
                </div>
                `;
            }).join('');
            
            matchesContainer.innerHTML = `
                <h3>🔴 Live Matches (${matches.length} available)</h3>
                ${matchesHTML}
            `;
            window._lastRender = { source: 'live', data: (Array.isArray(matches) ? matches.slice() : matches) };
            restoreAdminInputs(__savedAdminInputs);
            restoreActiveAdminElement(__activeAdminElId);
            try { scheduleAutoFillScan(); } catch (_) {}
        }
        
        // =============================================================================
        // DATA PERSISTENCE HELPERS
        // =============================================================================
        
        // Save current state to versioned data structure
        function saveGameState() {
            gameData.betSlip = betSlip;
            gameData.userData.coins = coins;
            gameData.currentStake = currentStake;
            gameData.userData.totalBetsPlaced = totalBetsPlaced;
            
            return DataManager.saveToStorage(gameData);
        }
        
        // Update user stats safely
        function updateUserStats(newStats) {
            Object.assign(gameData.userData.stats, newStats);
            saveGameState();
        }
        
        // Feature flag checker
        function isFeatureEnabled(featureName) {
            return gameData.features[featureName] || false;
        }
        
        function showTab(tabName) {
            console.log('Switching to tab:', tabName);
            // Track current tab for mobile bet bar visibility
            window.currentTab = tabName;
            
            // Hide all tabs with animation
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
                tab.classList.remove('active');
            });
            
            // Remove active class from all nav tabs
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab with animation
            const selectedTab = document.getElementById(tabName + '-tab');
            selectedTab.style.display = 'block';
            setTimeout(() => {
                selectedTab.classList.add('active');
            }, 10);
            
            // Add active class to the corresponding nav button
            const navBtn = document.querySelector(`.nav-tab[onclick*="showTab('${tabName}')"]`);
            if (navBtn) navBtn.classList.add('active');
            
            // Update content if needed - temporarily disable updateMyBets to prevent error
            if (tabName === 'mybets') {
                // updateMyBets(); // Disabled to prevent toFixed error
            } else if (tabName === 'social') {
                updateRankings();
                updateMyLeagues();
            }
            // Always refresh bet slip content on entry so auto Open Bets behavior applies
            if (tabName === 'betslip') {
                try { if (typeof updateBetSlip === 'function') updateBetSlip(); } catch (_) {}
            }
            // Update mobile bet bar visibility/state on tab change
            if (typeof updateBetBar === 'function') updateBetBar();
        }
        
        // Social Tab Section Switching
        function showSocialSection(sectionName) {
            // Update navigation buttons
            document.querySelectorAll('.social-nav-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Hide all social sections with fade out
            document.querySelectorAll('.social-section').forEach(section => {
                section.classList.remove('active');
            });
            
            // Show selected section with fade in
            setTimeout(() => {
                const targetSection = document.getElementById(`social-${sectionName}`);
                if (targetSection) {
                    targetSection.classList.add('active');
                }
                
                // Update active nav button
                const activeBtn = document.querySelector(`[onclick="showSocialSection('${sectionName}')"]`);
                if (activeBtn) {
                    activeBtn.classList.add('active');
                }
            }, 200);
            
            // Update content based on section
            if (sectionName === 'global') {
                updateRankings();
            } else if (sectionName === 'leagues') {
                updateMyLeagues();
            }
        }
        
        // Private League System Functions
        // currentUser will be set by authentication system
        
        function updateMyLeagues() {
            const myLeaguesList = document.getElementById('my-leagues-list');
            const userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
            
            if (userLeagues.length === 0) {
                myLeaguesList.innerHTML = `
                    <div class="empty-leagues">
                        <div class="empty-leagues-icon">👥</div>
                        <div class="empty-leagues-title">No Leagues Yet</div>
                        <div class="empty-leagues-subtitle">Create or join a league to compete with friends!</div>
                    </div>
                `;
                return;
            }
            
            let html = '';
            userLeagues.forEach(league => {
                const memberCount = league.members ? league.members.length : 1;
                const isAdmin = league.adminId === currentUser.id;
                
                html += `
                    <div class="league-card" onclick="showLeagueDetails('${league.id}')">
                        <div class="league-card-header">
                            <div class="league-name">${league.name}</div>
                            <div class="league-role ${isAdmin ? 'admin' : ''}">${isAdmin ? 'Admin' : 'Member'}</div>
                        </div>
                        <div class="league-stats-row">
                            <div class="league-stat">
                                <div class="league-stat-value">${memberCount}</div>
                                <div class="league-stat-label">Members</div>
                            </div>
                            <div class="league-stat">
                                <div class="league-stat-value">${league.competitionType}</div>
                                <div class="league-stat-label">Type</div>
                            </div>
                            <div class="league-stat">
                                <div class="league-stat-value">${league.totalBets || 0}</div>
                                <div class="league-stat-label">Total Bets</div>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            myLeaguesList.innerHTML = html;
        }
        
        function showCreateLeague() {
            document.getElementById('createLeagueModal').style.display = 'flex';
        }
        
        function closeCreateLeague() {
            document.getElementById('createLeagueModal').style.display = 'none';
            // Clear form
            document.getElementById('leagueName').value = '';
            document.getElementById('leagueDescription').value = '';
            document.getElementById('competitionType').value = 'weekly';
        }
        
        function createLeague() {
            const name = document.getElementById('leagueName').value.trim();
            const description = document.getElementById('leagueDescription').value.trim();
            const weeklyBonusEnabled = document.getElementById('weeklyBonusEnabled').checked;
            
            if (!name) {
                showMessage('Please enter a league name!', 'error');
                return;
            }
            
            // Generate unique league code
            const leagueCode = generateLeagueCode();
            
            const newLeague = {
                id: 'league_' + Date.now(),
                name: name,
                description: description,
                weeklyBonusEnabled: weeklyBonusEnabled,
                code: leagueCode,
                adminId: currentUser.id,
                members: [{
                    id: currentUser.id,
                    name: currentUser.name,
                    avatar: currentUser.avatar,
                    role: 'admin',
                    score: 0,
                    totalWinnings: 0,
                    successfulBets: 0
                }],
                createdAt: new Date().toISOString(),
                totalBets: 0,
                weeksActive: 0
            };
            
            // Save to localStorage
            const userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
            userLeagues.push(newLeague);
            localStorage.setItem('userLeagues', JSON.stringify(userLeagues));
            
            // Save league globally
            const allLeagues = JSON.parse(localStorage.getItem('allLeagues') || '{}');
            allLeagues[leagueCode] = newLeague;
            localStorage.setItem('allLeagues', JSON.stringify(allLeagues));
            
            closeCreateLeague();
            updateMyLeagues();
            showMessage(`League "${name}" created! Code: ${leagueCode}`, 'success');
        }
        
        function generateLeagueCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        
        function showJoinLeague() {
            document.getElementById('joinLeagueModal').style.display = 'flex';
        }
        
        function closeJoinLeague() {
            document.getElementById('joinLeagueModal').style.display = 'none';
            document.getElementById('leagueCode').value = '';
        }
        
        function joinLeague() {
            const code = document.getElementById('leagueCode').value.trim().toUpperCase();
            
            if (!code) {
                showMessage('Please enter a league code!', 'error');
                return;
            }
            
            if (code.length !== 6) {
                showMessage('League code must be 6 characters!', 'error');
                return;
            }
            
            // Check if league exists
            const allLeagues = JSON.parse(localStorage.getItem('allLeagues') || '{}');
            const league = allLeagues[code];
            
            if (!league) {
                showMessage('League not found! Check the code and try again.', 'error');
                return;
            }
            
            // Check if already a member
            const isAlreadyMember = league.members.some(member => member.id === currentUser.id);
            if (isAlreadyMember) {
                showMessage('You are already a member of this league!', 'error');
                return;
            }
            
            // Check if league is full
            if (league.members.length >= 10) {
                showMessage('This league is full (max 10 members)!', 'error');
                return;
            }
            
            // Add user to league
            const newMember = {
                id: currentUser.id,
                name: currentUser.name,
                avatar: currentUser.avatar,
                role: 'member',
                score: 0,
                totalWinnings: 0,
                successfulBets: 0,
                joinedAt: new Date().toISOString()
            };
            
            league.members.push(newMember);
            
            // Update league in global storage
            allLeagues[code] = league;
            localStorage.setItem('allLeagues', JSON.stringify(allLeagues));
            
            // Add to user's leagues
            const userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
            userLeagues.push(league);
            localStorage.setItem('userLeagues', JSON.stringify(userLeagues));
            
            closeJoinLeague();
            updateMyLeagues();
            showMessage(`Successfully joined "${league.name}"!`, 'success');
        }
        
        function showLeagueDetails(leagueId) {
            const userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
            const league = userLeagues.find(l => l.id === leagueId);
            
            if (!league) return;
            
            // Initialize tournament data if not exists
            if (!league.tournament) {
                league.tournament = {
                    currentWeek: getCurrentWeekNumber(),
                    weeklyResults: {},
                    seasonPoints: {},
                    coinAllocations: {}
                };
                // Initialize member tournament data
                league.members.forEach(member => {
                    league.tournament.seasonPoints[member.id] = 0;
                    league.tournament.coinAllocations[member.id] = 100; // Base coins
                });
                updateLeagueStorage(league);
            }
            
            // Update modal content
            document.getElementById('leagueDetailsTitle').textContent = `🏆 ${league.name}`;
            document.getElementById('leagueCodeDisplay').textContent = league.code;
            document.getElementById('leagueMemberCount').textContent = league.members.length;
            document.getElementById('leagueWeeksActive').textContent = league.weeksActive || 0;
            document.getElementById('leagueTotalBets').textContent = league.totalBets || 0;
            
            // Update tournament dashboard
            updateTournamentDashboard(league);
            
            // Update leaderboard with tournament data
            updateLeagueLeaderboard(league);
            
            // Update members list
            updateLeagueMembers(league);
            
            // Show/hide leave button (can't leave if admin)
            const leaveBtn = document.querySelector('.leave-league-btn');
            if (league.adminId === currentUser.id) {
                leaveBtn.style.display = 'none';
            } else {
                leaveBtn.style.display = 'inline-block';
                leaveBtn.onclick = () => leaveLeague(leagueId);
            }
            
            document.getElementById('leagueDetailsModal').style.display = 'flex';
        }
        
        function getCurrentWeekNumber() {
            const now = new Date();
            const startOfYear = new Date(now.getFullYear(), 0, 1);
            const pastDaysOfYear = (now - startOfYear) / 86400000;
            return Math.ceil((pastDaysOfYear + startOfYear.getDay() + 1) / 7);
        }
        
        function updateTournamentDashboard(league) {
            const currentWeek = getCurrentWeekNumber();
            const weeklyData = league.tournament.weeklyResults[currentWeek] || {};
            
            // Calculate current week standings for each discipline
            const disciplines = {
                coins: { name: 'Most Coins Earned', points: 100, icon: '💰' },
                biggestOdds: { name: 'Biggest Single Odds', points: 75, icon: '🚀' },
                addedOdds: { name: 'Most Added-Up Odds', points: 50, icon: '📈' }
            };
            
            let tournamentHTML = `
                <div class="tournament-dashboard">
                    <div class="tournament-header">
                        <h3>🏆 Week ${currentWeek} Tournament</h3>
                        <div class="week-timer">Resets Monday</div>
                    </div>
                    <div class="disciplines-grid">
            `;
            
            Object.entries(disciplines).forEach(([key, discipline]) => {
                const leaders = getWeeklyLeaders(league, key, currentWeek);
                const leader = leaders[0];
                
                tournamentHTML += `
                    <div class="discipline-card">
                        <div class="discipline-header">
                            <span class="discipline-icon">${discipline.icon}</span>
                            <div>
                                <div class="discipline-name">${discipline.name}</div>
                                <div class="discipline-points">${discipline.points} points</div>
                            </div>
                        </div>
                        <div class="discipline-leader">
                            ${leader ? `
                                <div class="leader-info">
                                    <span class="leader-avatar">${leader.avatar}</span>
                                    <span class="leader-name">${leader.name}</span>
                                </div>
                                <div class="leader-value">${formatDisciplineValue(key, leader.value)}</div>
                            ` : '<div class="no-leader">No activity yet</div>'}
                        </div>
                    </div>
                `;
            });
            
            tournamentHTML += `
                    </div>
                    <div class="coin-allocations">
                        <h4>💰 Next Week's Coins</h4>
                        <div class="allocation-preview">
                            ${generateCoinAllocationPreview(league)}
                        </div>
                    </div>
                </div>
            `;
            
            // Insert tournament dashboard before leaderboard
            const leaderboard = document.getElementById('leagueLeaderboard');
            const existingDashboard = document.querySelector('.tournament-dashboard');
            if (existingDashboard) {
                existingDashboard.remove();
            }
            leaderboard.insertAdjacentHTML('beforebegin', tournamentHTML);
        }
        
        function getWeeklyLeaders(league, discipline, week) {
            const weeklyData = league.tournament.weeklyResults[week] || {};
            const results = [];
            
            league.members.forEach(member => {
                const memberData = weeklyData[member.id] || { coinsEarned: 0, biggestOdds: 0, addedOdds: 0 };
                let value = 0;
                
                switch(discipline) {
                    case 'coins':
                        value = memberData.coinsEarned;
                        break;
                    case 'biggestOdds':
                        value = memberData.biggestOdds;
                        break;
                    case 'addedOdds':
                        value = memberData.addedOdds;
                        break;
                }
                
                if (value > 0) {
                    results.push({ ...member, value });
                }
            });
            
            return results.sort((a, b) => b.value - a.value);
        }
        
        function formatDisciplineValue(discipline, value) {
            switch(discipline) {
                case 'coins':
                    return `+${value} coins`;
                case 'biggestOdds':
                    return `${value.toFixed(2)}x`;
                case 'addedOdds':
                    return `${value.toFixed(2)} total`;
                default:
                    return value;
            }
        }
        
        function generateCoinAllocationPreview(league) {
            const currentWeek = getCurrentWeekNumber();
            const allocations = league.tournament.coinAllocations || {};
            
            let html = '';
            league.members.forEach(member => {
                const baseCoins = 100;
                const bonusCoins = allocations[member.id] - baseCoins || 0;
                const totalCoins = allocations[member.id] || baseCoins;
                
                html += `
                    <div class="allocation-item">
                        <div class="member-info">
                            <span class="member-avatar">${member.avatar}</span>
                            <span class="member-name">${member.name}</span>
                        </div>
                        <div class="coin-amount">
                            <span class="base-coins">${baseCoins}</span>
                            ${bonusCoins > 0 ? `<span class="bonus-coins">+${bonusCoins}</span>` : ''}
                            <span class="total-coins">${totalCoins} coins</span>
                        </div>
                    </div>
                `;
            });
            
            return html;
        }
        
        function updateLeagueStorage(league) {
            // Update in user's leagues
            const userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
            const leagueIndex = userLeagues.findIndex(l => l.id === league.id);
            if (leagueIndex > -1) {
                userLeagues[leagueIndex] = league;
                localStorage.setItem('userLeagues', JSON.stringify(userLeagues));
            }
            
            // Update in global leagues
            const allLeagues = JSON.parse(localStorage.getItem('allLeagues') || '{}');
            allLeagues[league.code] = league;
            localStorage.setItem('allLeagues', JSON.stringify(allLeagues));
        }
        
        function checkWeeklyReset() {
            const userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
            const currentWeek = getCurrentWeekNumber();
            
            userLeagues.forEach(league => {
                if (!league.tournament) return;
                
                // Check if we need to reset for new week
                if (league.tournament.currentWeek < currentWeek) {
                    // Calculate and distribute coin bonuses for previous week
                    calculateWeeklyRewards(league, league.tournament.currentWeek);
                    
                    // Update to current week
                    league.tournament.currentWeek = currentWeek;
                    
                    // Update league storage
                    updateLeagueStorage(league);
                    
                    console.log(`League ${league.name} reset for week ${currentWeek}`);
                }
            });
        }
        
        function calculateWeeklyRewards(league, completedWeek) {
            const weeklyData = league.tournament.weeklyResults[completedWeek] || {};
            const disciplines = ['coins', 'biggestOdds', 'addedOdds'];
            const points = { coins: 100, biggestOdds: 75, addedOdds: 50 };
            
            // Calculate winners for each discipline
            const winners = {};
            
            disciplines.forEach(discipline => {
                const rankings = [];
                
                Object.entries(weeklyData).forEach(([userId, data]) => {
                    let value = 0;
                    switch(discipline) {
                        case 'coins':
                            value = data.coinsEarned || 0;
                            break;
                        case 'biggestOdds':
                            value = data.biggestOdds || 0;
                            break;
                        case 'addedOdds':
                            value = data.addedOdds || 0;
                            break;
                    }
                    
                    if (value > 0) {
                        rankings.push({ userId, value });
                    }
                });
                
                // Sort by value (highest first)
                rankings.sort((a, b) => b.value - a.value);
                winners[discipline] = rankings;
            });
            
            // Calculate total points for each member
            const memberPoints = {};
            league.members.forEach(member => {
                memberPoints[member.id] = 0;
            });
            
            disciplines.forEach(discipline => {
                const disciplineWinners = winners[discipline];
                if (disciplineWinners.length > 0) {
                    // Award points to winner
                    memberPoints[disciplineWinners[0].userId] += points[discipline];
                }
            });
            
            // Sort members by total points
            const finalRankings = Object.entries(memberPoints)
                .map(([userId, totalPoints]) => ({ userId, totalPoints }))
                .sort((a, b) => b.totalPoints - a.totalPoints);
            
            // Calculate coin allocations for next week
            const newAllocations = {};
            
            league.members.forEach(member => {
                newAllocations[member.id] = 100; // Base coins
            });
            
            // Award bonus coins to top performers
            if (finalRankings.length >= 1 && finalRankings[0].totalPoints > 0) {
                newAllocations[finalRankings[0].userId] += 25; // 1st place bonus
            }
            if (finalRankings.length >= 2 && finalRankings[1].totalPoints > 0) {
                newAllocations[finalRankings[1].userId] += 15; // 2nd place bonus
            }
            if (finalRankings.length >= 3 && finalRankings[2].totalPoints > 0) {
                newAllocations[finalRankings[2].userId] += 10; // 3rd place bonus
            }
            
            // Award underdog bonus to bottom 3 (if league has 6+ members)
            if (league.members.length >= 6) {
                const bottomThree = finalRankings.slice(-3);
                bottomThree.forEach(member => {
                    newAllocations[member.userId] += 10; // Underdog bonus
                });
            }
            
            // Update season points
            finalRankings.forEach(member => {
                if (!league.tournament.seasonPoints[member.userId]) {
                    league.tournament.seasonPoints[member.userId] = 0;
                }
                league.tournament.seasonPoints[member.userId] += member.totalPoints;
            });
            
            // Store new coin allocations
            league.tournament.coinAllocations = newAllocations;
            
            // Store weekly results summary
            if (!league.tournament.weeklyWinners) {
                league.tournament.weeklyWinners = {};
            }
            
            league.tournament.weeklyWinners[completedWeek] = {
                disciplines: winners,
                finalRankings: finalRankings,
                coinAllocations: { ...newAllocations }
            };
        }
        
        // Initialize tournament system on page load
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                checkWeeklyReset();
                // Check for weekly reset every minute
                setInterval(checkWeeklyReset, 60000);
            }, 1000);
        });
        
        // Tournament Selection Modal Functions
        function showTournamentSelectionModal(betRecord) {
            const userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
            
            if (userLeagues.length === 0) {
                // No leagues to add to, just skip
                return;
            }
            
            // Update bet summary
            const betSummary = document.getElementById('betSummaryContent');
            const resultText = betRecord.isWin ? `WON +${betRecord.coinsEarned} coins` : 'LOST';
            const resultClass = betRecord.isWin ? 'win' : 'loss';
            
            betSummary.innerHTML = `
                <div class="bet-summary-card">
                    <div class="bet-details">
                        <span class="bet-stake">${betRecord.stake} coins @ ${betRecord.combinedOdds.toFixed(2)}x</span>
                        <span class="bet-result ${resultClass}">${resultText}</span>
                    </div>
                </div>
            `;
            
            // Update tournament checkboxes
            const checkboxContainer = document.getElementById('tournamentCheckboxes');
            let checkboxHTML = '';
            
            userLeagues.forEach(league => {
                checkboxHTML += `
                    <label class="tournament-checkbox">
                        <input type="checkbox" value="${league.id}" checked>
                        <span class="checkmark"></span>
                        <div class="tournament-info">
                            <span class="tournament-name">${league.name}</span>
                            <span class="tournament-duration">${getDurationText(league.competitionDuration || 'season')}</span>
                        </div>
                    </label>
                `;
            });
            
            checkboxContainer.innerHTML = checkboxHTML;
            
            // Show modal
            document.getElementById('tournamentSelectionModal').style.display = 'flex';
        }
        
        function getDurationText(duration) {
            switch(duration) {
                case '4weeks': return '4 Week Championship';
                case '8weeks': return '8 Week Championship';
                case 'season': return 'Full Season';
                case 'custom': return 'Custom Duration';
                default: return 'Championship';
            }
        }
        
        function closeTournamentSelection() {
            document.getElementById('tournamentSelectionModal').style.display = 'none';
        }
        
        function skipTournaments() {
            closeTournamentSelection();
        }
        
        function addToSelectedTournaments() {
            const betRecord = window.currentBetRecord;
            if (!betRecord) return;
            
            // Get selected leagues
            const selectedLeagues = [];
            document.querySelectorAll('#tournamentCheckboxes input[type="checkbox"]:checked').forEach(checkbox => {
                selectedLeagues.push(checkbox.value);
            });
            
            // Check if weekly bonus is included
            const includeWeeklyBonus = document.getElementById('weeklyBonusInclude').checked;
            
            // Update tournament stats for selected leagues
            if (selectedLeagues.length > 0 || includeWeeklyBonus) {
                updateTournamentStats(betRecord, selectedLeagues, includeWeeklyBonus);
            }
            
            closeTournamentSelection();
            
            // Show confirmation message
            const leagueCount = selectedLeagues.length;
            const bonusText = includeWeeklyBonus ? ' + Weekly Bonus' : '';
            if (leagueCount > 0 || includeWeeklyBonus) {
                showMessage(`🏆 Bet added to ${leagueCount} tournament(s)${bonusText}!`, 'success');
            }
        }
        
        // Update tournament stats function with league selection
        function updateTournamentStats(betRecord, selectedLeagues = [], includeWeeklyBonus = true) {
            const userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
            const currentWeek = getCurrentWeekNumber();
            
            // Update selected leagues
            userLeagues.forEach(league => {
                if (!selectedLeagues.includes(league.id)) return;
                if (!league.tournament) return;
                
                // Initialize weekly data if not exists
                if (!league.tournament.weeklyResults[currentWeek]) {
                    league.tournament.weeklyResults[currentWeek] = {};
                }
                
                // Initialize user data for this week if not exists
                if (!league.tournament.weeklyResults[currentWeek][currentUser.id]) {
                    league.tournament.weeklyResults[currentWeek][currentUser.id] = {
                        coinsEarned: 0,
                        biggestOdds: 0,
                        addedOdds: 0,
                        totalBets: 0,
                        winningBets: 0
                    };
                }
                
                const weeklyData = league.tournament.weeklyResults[currentWeek][currentUser.id];
                
                // Update statistics based on bet outcome
                if (betRecord.isWin) {
                    // Update coins earned (profit only)
                    weeklyData.coinsEarned += betRecord.coinsEarned;
                    
                    // Update biggest single odds if this is bigger
                    if (betRecord.combinedOdds > weeklyData.biggestOdds) {
                        weeklyData.biggestOdds = betRecord.combinedOdds;
                    }
                    
                    // Add to total added-up odds
                    weeklyData.addedOdds += betRecord.combinedOdds;
                    
                    weeklyData.winningBets++;
                }
                
                weeklyData.totalBets++;
                
                // Update league storage
                updateLeagueStorage(league);
            });
            
            // Update weekly bonus competition if included
            if (includeWeeklyBonus) {
                updateWeeklyBonusStats(betRecord);
            }
            
            // Also update global storage
            const allLeagues = JSON.parse(localStorage.getItem('allLeagues') || '{}');
            userLeagues.forEach(league => {
                if (allLeagues[league.code]) {
                    allLeagues[league.code] = league;
                }
            });
            localStorage.setItem('allLeagues', JSON.stringify(allLeagues));
        }
        
        function updateWeeklyBonusStats(betRecord) {
            // Store weekly bonus stats separately for cross-league competition
            const currentWeek = getCurrentWeekNumber();
            const weeklyBonusStats = JSON.parse(localStorage.getItem('weeklyBonusStats') || '{}');
            
            if (!weeklyBonusStats[currentWeek]) {
                weeklyBonusStats[currentWeek] = {};
            }
            
            if (!weeklyBonusStats[currentWeek][currentUser.id]) {
                weeklyBonusStats[currentWeek][currentUser.id] = {
                    coinsEarned: 0,
                    biggestOdds: 0,
                    addedOdds: 0,
                    totalBets: 0,
                    winningBets: 0
                };
            }
            
            const weeklyData = weeklyBonusStats[currentWeek][currentUser.id];
            
            if (betRecord.isWin) {
                weeklyData.coinsEarned += betRecord.coinsEarned;
                if (betRecord.combinedOdds > weeklyData.biggestOdds) {
                    weeklyData.biggestOdds = betRecord.combinedOdds;
                }
                weeklyData.addedOdds += betRecord.combinedOdds;
                weeklyData.winningBets++;
            }
            
            weeklyData.totalBets++;
            
            localStorage.setItem('weeklyBonusStats', JSON.stringify(weeklyBonusStats));
        }
        
        function updateLeagueLeaderboard(league) {
            const leaderboard = document.getElementById('leagueLeaderboard');
            
            // Sort members by score (total winnings for now)
            const sortedMembers = [...league.members].sort((a, b) => (b.totalWinnings || 0) - (a.totalWinnings || 0));
            
            let html = '';
            sortedMembers.forEach((member, index) => {
                const position = index + 1;
                const positionIcon = position === 1 ? '🥇' : position === 2 ? '🥈' : position === 3 ? '🥉' : `#${position}`;
                
                html += `
                    <div class="leaderboard-item">
                        <div class="member-info">
                            <span style="font-size: 16px; margin-right: 8px;">${positionIcon}</span>
                            <div class="member-avatar">${member.avatar}</div>
                            <div>
                                <div class="member-name">${member.name}</div>
                                <div class="member-role">${member.role}</div>
                            </div>
                        </div>
                        <div class="member-score">${member.totalWinnings || 0} coins</div>
                    </div>
                `;
            });
            
            if (html === '') {
                html = '<div style="text-align: center; color: #7f8c8d; padding: 20px;">No betting activity yet</div>';
            }
            
            leaderboard.innerHTML = html;
        }
        
        function updateLeagueMembers(league) {
            const membersContainer = document.getElementById('leagueMembers');
            
            let html = '';
            league.members.forEach(member => {
                html += `
                    <div class="member-item">
                        <div class="member-info">
                            <div class="member-avatar">${member.avatar}</div>
                            <div>
                                <div class="member-name">${member.name}</div>
                                <div class="member-role">${member.role}</div>
                            </div>
                        </div>
                        <div class="member-score">${member.successfulBets || 0} wins</div>
                    </div>
                `;
            });
            
            membersContainer.innerHTML = html;
        }
        
        function copyLeagueCode() {
            const codeValue = document.getElementById('leagueCodeDisplay').textContent;
            
            if (navigator.clipboard) {
                navigator.clipboard.writeText(codeValue).then(() => {
                    showMessage('League code copied to clipboard!', 'success');
                });
            } else {
                // Fallback for older browsers
                const textArea = document.createElement('textarea');
                textArea.value = codeValue;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showMessage('League code copied!', 'success');
            }
        }
        
        function closeLeagueDetails() {
            document.getElementById('leagueDetailsModal').style.display = 'none';
        }
        
        function leaveLeague(leagueId) {
            if (confirm('Are you sure you want to leave this league?')) {
                // Remove from user's leagues
                let userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
                const leagueIndex = userLeagues.findIndex(l => l.id === leagueId);
                
                if (leagueIndex > -1) {
                    const league = userLeagues[leagueIndex];
                    
                    // Remove user from league members
                    league.members = league.members.filter(member => member.id !== currentUser.id);
                    
                    // Update global league storage
                    const allLeagues = JSON.parse(localStorage.getItem('allLeagues') || '{}');
                    allLeagues[league.code] = league;
                    localStorage.setItem('allLeagues', JSON.stringify(allLeagues));
                    
                    // Remove from user's leagues
                    userLeagues.splice(leagueIndex, 1);
                    localStorage.setItem('userLeagues', JSON.stringify(userLeagues));
                    
                    closeLeagueDetails();
                    updateMyLeagues();
                    showMessage('Left league successfully!', 'success');
                }
            }
        }
        
        // Make toggleBet globally accessible
        window.toggleBet = function(betId, match, selection, odds, button, event) {
            // Ensure betSlip array exists
            if (!window.betSlip) {
                window.betSlip = [];
            }
            // Track previous selection count for combo-first UX
            const prevLength = window.betSlip.length;
            // Prevent event bubbling to avoid double-triggers
            if (event) {
                event.stopPropagation();
                event.preventDefault();
            }
            // Coerce odds to a number in case it was passed as a string
            odds = Number(odds);
            
            // Immediate visual feedback (guard if button is provided)
            if (button && button.style) {
                button.style.transform = 'scale(0.95)';
                setTimeout(() => { try { button.style.transform = ''; } catch (_) {} }, 100);
            }
            
            console.log('toggleBet called:', { betId, match, selection, odds });
            const existingBetIndex = window.betSlip.findIndex(bet => bet.id === betId);
            
            if (existingBetIndex > -1) {
                // Remove bet
                window.betSlip.splice(existingBetIndex, 1);
                if (button && button.classList) button.classList.remove('selected');
                // Also clear selected state on any duplicate odds buttons referencing the same betId
                document.querySelectorAll('.odds-button').forEach(btn => {
                    const oc = btn.getAttribute('onclick') || '';
                    if (oc.includes(betId)) {
                        btn.classList.remove('selected');
                    }
                });
            } else {
                // Extract match ID from betId (e.g., 'mc-liv-1' -> 'mc-liv')
                const matchId = betId.split('-').slice(0, -1).join('-');
                // Determine market type for the new selection
                const betType = getBetType(betId);
                
                // Remove any existing bets in the SAME market group for this match (e.g., only one of 1/X/2 or 1X/12/X2)
                const sameGroupBets = window.betSlip.filter(bet => {
                    const existingMatchId = bet.id.split('-').slice(0, -1).join('-');
                    return existingMatchId === matchId && getBetType(bet.id) === betType;
                });
                sameGroupBets.forEach(existingBet => {
                    const idx = window.betSlip.findIndex(b => b.id === existingBet.id);
                    if (idx > -1) {
                        window.betSlip.splice(idx, 1);
                        document.querySelectorAll('.odds-button').forEach(btn => {
                            if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(existingBet.id)) {
                                btn.classList.remove('selected');
                            }
                        });
                    }
                });
                
                // Check for conflicting bet types (can't have both match result and double chance)
                const conflictingBets = window.betSlip.filter(bet => {
                    const bMatchId = bet.id.split('-').slice(0, -1).join('-');
                    const bType = getBetType(bet.id);
                    return bMatchId === matchId && areConflictingTypes(betType, bType);
                });
                
                // Remove conflicting bets
                conflictingBets.forEach(conflictBet => {
                    const idx = window.betSlip.findIndex(b => b.id === conflictBet.id);
                    if (idx > -1) {
                        window.betSlip.splice(idx, 1);
                        document.querySelectorAll('.odds-button').forEach(btn => {
                            if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(conflictBet.id)) {
                                btn.classList.remove('selected');
                            }
                        });
                    }
                });
                
                // Add new bet with stake starting at 0
                window.betSlip.push({
                    id: betId,
                    match: match,
                    selection: selection,
                    odds: odds,
                    stake: 0,  // Start at 0 so user must choose amount
                    type: 'single'  // Default to single bet
                });
                if (button && button.classList) button.classList.add('selected');
            }
            
            // No combo hint toast; rely on the sticky mobile Bet Bar to guide users
            // Set focus intent after additions so we can focus stake input post-render
            const newLength = window.betSlip.length;
            if (newLength > prevLength) {
                if (newLength > 1) {
                    window._focusAfterRender = { input: 'combo' };
                } else {
                    window._focusAfterRender = { input: 'single', index: 0 };
                }
            }

            updateBetSlip();
        };
        
        // Helper function to determine bet type
        function getBetType(betId) {
            const suffix = betId.split('-').pop();
            if (['1', 'x', '2'].includes(suffix)) return 'match_result';
            if (['1x', '12', 'x2'].includes(suffix)) return 'double_chance';
            if (['over', 'under'].includes(suffix)) return 'total_goals';
            if (['yes', 'no'].includes(suffix)) return 'btts';
            return 'unknown';
        }

        // Human-readable market label for display in Open/Recent bets
        function displayMarketLabel(market) {
            const m = String(market || '').toLowerCase();
            if (m === 'match_result') return '1X2';
            if (m === 'double_chance') return 'Double Chance';
            if (m === 'total_goals') return 'Over/Under';
            if (m === 'btts' || m === 'both_teams') return 'Beide treffen';
            return market || '—';
        }

        // Expand/collapse details for an open bet card
        window.toggleOpenBetDetails = function(detailsId) {
            try {
                const el = document.getElementById(detailsId);
                if (!el) return;
                const hidden = (el.style.display === '' || el.style.display === 'none');
                el.style.display = hidden ? 'block' : 'none';
                const caret = document.querySelector(`[data-caret-for="${detailsId}"]`);
                if (caret) caret.style.transform = hidden ? 'rotate(180deg)' : '';
            } catch (_) { /* noop */ }
        }

        // Selection code -> display label
        function selectionLabelFromCode(code) {
            const c = String(code || '').toLowerCase();
            if (c === 'home' || c === '1') return 'HOME';
            if (c === 'draw' || c === 'x') return 'DRAW';
            if (c === 'away' || c === '2') return 'AWAY';
            if (c === '1x') return '1X';
            if (c === '12') return '12';
            if (c === 'x2') return 'X2';
            if (c === 'over') return 'OVER';
            if (c === 'under') return 'UNDER';
            if (c === 'yes') return 'YES';
            if (c === 'no') return 'NO';
            return (code || '').toString().toUpperCase();
        }

        // Inverse: selection code -> betId suffix
        function suffixFromSelectionCode(code) {
            const c = String(code || '').toLowerCase();
            if (c === 'home' || c === '1') return '1';
            if (c === 'draw' || c === 'x') return 'x';
            if (c === 'away' || c === '2') return '2';
            if (c === '1x') return '1x';
            if (c === '12') return '12';
            if (c === 'x2') return 'x2';
            if (c === 'over') return 'over';
            if (c === 'under') return 'under';
            if (c === 'yes') return 'yes';
            if (c === 'no') return 'no';
            return '';
        }

        // Re-bet quickly from Open Bets
        window.rebetFromOpen = function(matchId, matchStr, selectionCode, odds) {
            try {
                const suffix = suffixFromSelectionCode(selectionCode);
                if (!matchId || !suffix) return;
                const betId = `${matchId}-${suffix}`;
                const label = selectionLabelFromCode(selectionCode);
                const o = Number(odds) || 1;
                // focus single stake after rendering
                window._focusAfterRender = { input: 'single', index: 0 };
                window.toggleBet(betId, matchStr, label, o, null, null);
                try {
                    showTab('betslip');
                    if (typeof window.setBetSlipView === 'function') {
                        window.setBetSlipView('slip');
                    } else {
                        window.betslipViewMode = 'slip';
                        if (typeof updateBetSlip === 'function') updateBetSlip();
                    }
                } catch (_) {}
            } catch (_) { /* ignore */ }
        }
        
        // Helper function to check if two bet types conflict
        function areConflictingTypes(type1, type2) {
            // Match result and double chance conflict with each other
            const conflictingPairs = [
                ['match_result', 'double_chance'],
                ['double_chance', 'match_result']
            ];
            return conflictingPairs.some(pair => pair[0] === type1 && pair[1] === type2);
        }

        // Sticky mobile Bet Bar updater (hoisted)
        function updateBetBar() {
            try {
                const bar = document.getElementById('mobile-betbar');
                if (!bar) return;
                const count = (window.betSlip && window.betSlip.length) ? window.betSlip.length : 0;
                const betslipTab = document.getElementById('betslip-tab');
                const isBetSlipActive = (betslipTab && betslipTab.classList.contains('active')) || window.currentTab === 'betslip';
                if (!count || isBetSlipActive) {
                    bar.classList.add('hidden');
                    return;
                }
                const combiOdds = (window.betSlip || []).reduce((t, b) => t * (Number(b.odds) || 1), 1);
                const totalSinglesStake = (window.betSlip || []).reduce((t, b) => t + (Number(b.stake) || 0), 0);
                const combiStakeActive = (count > 1) ? (Number(window.combiStake) || 0) : 0;
                const totalStake = totalSinglesStake + combiStakeActive;

                const countEl = document.getElementById('betbar-count');
                const textEl = document.getElementById('betbar-text');
                const oddsEl = document.getElementById('betbar-odds');
                const stakeEl = document.getElementById('betbar-stake');
                if (countEl) countEl.textContent = String(count);
                if (textEl) textEl.textContent = (count > 1 ? 'Auswahlen • Kombi' : 'Auswahl');
                if (oddsEl) {
                    if (count > 1) oddsEl.textContent = `Kombi: ${combiOdds.toFixed(2)}x`;
                    else if (count === 1) oddsEl.textContent = `Quote: ${(Number(window.betSlip[0].odds) || 0).toFixed(2)}x`;
                    else oddsEl.textContent = '';
                }
                if (stakeEl) stakeEl.textContent = (totalStake > 0 ? `Einsatz: ${totalStake.toFixed(0)}` : '');
                bar.classList.remove('hidden');
            } catch (e) {
                console.warn('updateBetBar error', e);
            }
        }

        // Open bet slip from the mobile bar and focus combo stake
        function openBetSlipFromBar() {
            showTab('betslip');
            // Ensure content is up-to-date and auto-mode applies
            try { if (typeof updateBetSlip === 'function') updateBetSlip(); } catch (_) {}
            setTimeout(() => {
                const input = document.getElementById('combo-stake');
                if (input) {
                    input.focus();
                    if (input.type && input.type !== 'number') {
                        const end = input.value.length;
                        try { if (input.setSelectionRange) input.setSelectionRange(end, end); } catch (_) {}
                    }
                } else {
                    const cont = document.getElementById('bet-slip-content');
                    if (cont && cont.scrollIntoView) cont.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 50);
        }

        function updateBetSlip() {
            const container = document.getElementById('bet-slip-content');
            // Ensure Bet Slip tab has a badge element, even if markup varies
            let tabBtn = document.getElementById('betslip-tab-btn');
            if (!tabBtn) {
                // Fallback: find button by onclick attribute containing 'betslip'
                tabBtn = document.querySelector(".nav-tab[onclick*=\"showTab('betslip')\"]");
                if (tabBtn && !tabBtn.id) tabBtn.id = 'betslip-tab-btn';
            }
            if (tabBtn) {
                let badgeEl = tabBtn.querySelector('.badge');
                if (!badgeEl) {
                    badgeEl = document.createElement('span');
                    badgeEl.className = 'badge hidden';
                    badgeEl.id = 'betslip-badge';
                    tabBtn.style.position = 'relative';
                    tabBtn.appendChild(badgeEl);
                }
                if (window.betSlip.length > 0) {
                    const __count = window.betSlip.length;
                    badgeEl.textContent = (__count > 99) ? '99+' : __count;
                    try { badgeEl.setAttribute('aria-label', `${__count} Auswahlen`); } catch (_) {}
                    badgeEl.classList.remove('hidden');
                } else {
                    badgeEl.classList.add('hidden');
                }
            }
            
            // Inline Recent/Open Bets mode toggle
            let mode = (window.betslipViewMode === 'recent' || window.betslipViewMode === 'open') ? window.betslipViewMode : 'slip';
            // Smart defaulting logic:
            // - If the slip is empty, default to Open (and mark that this was auto-applied)
            // - If the slip now has selections and we previously auto-applied Open, switch back to Slip automatically
            if (window.betSlip.length === 0) {
                if (mode !== 'recent') {
                    mode = 'open';
                    window._betslipAutoOpenApplied = true;
                }
            } else {
                if (window._betslipAutoOpenApplied && mode === 'open') {
                    mode = 'slip';
                }
                window._betslipAutoOpenApplied = false;
            }
            // Persist the resolved mode so future updates and polling behave consistently
            window.betslipViewMode = mode;
            // Stop Open Bets polling if leaving the Open view
            if (mode !== 'open' && window._openBetsPoll) {
                try { clearInterval(window._openBetsPoll); } catch (_) {}
                window._openBetsPoll = null;
            }
            if (mode === 'recent') {
                // Render a compact Recent Bets view inside the bet slip tab
                const sinceDays = 7;
                const backBtnRecent = (window.betSlip.length > 0)
                    ? `<button onclick="window.setBetSlipView && window.setBetSlipView('slip')" style="background:#4F46E5; color:#fff; border:none; padding:6px 10px; border-radius:6px; cursor:pointer;">Zum Wettschein</button>`
                    : '';
                const header = `
                    <div class="betslip-header">
                        <div class="betslip-count">
                            <span class="count-badge" style="background: #4F46E5;">📄</span>
                            <span>MEINE WETTEN</span>
                        </div>
                        <div class="betslip-options" style="display:flex; gap:8px; align-items:center;">
                            ${backBtnRecent}
                        </div>
                    </div>`;
                const subnav = `
                    <div class="betslip-subnav" style="display:flex; align-items:center; gap:8px; margin:6px 0 12px 0;">
                        <button class="toggle-chip" onclick="window.setBetSlipView && window.setBetSlipView('open')" style="background:#E5E7EB; color:#111827; border:none; padding:6px 10px; border-radius:20px; cursor:pointer;">OFFEN</button>
                        <button class="toggle-chip active" onclick="window.setBetSlipView && window.setBetSlipView('recent')" style="background:#4F46E5; color:#fff; border:none; padding:6px 10px; border-radius:20px; cursor:pointer;">ABGERECHNET</button>
                    </div>`;
                const body = `
                    <div id="recent-bets-inline" style="margin-top:10px;">
                        <div style="padding:16px; color:#6b7280;">Laden...</div>
                    </div>`;
                container.innerHTML = header + subnav + body;
                setTimeout(() => { if (typeof window.loadRecentBetsInline === 'function') window.loadRecentBetsInline(); }, 0);
                return;
            }
            if (mode === 'open') {
                // Render a compact Open Bets (pending) view inside the bet slip tab
                const backBtnOpen = (window.betSlip.length > 0)
                    ? `<button onclick="window.setBetSlipView && window.setBetSlipView('slip')" style="background:#4F46E5; color:#fff; border:none; padding:6px 10px; border-radius:6px; cursor:pointer;">Zum Wettschein</button>`
                    : '';
                const header = `
                    <div class="betslip-header">
                        <div class="betslip-count">
                            <span class="count-badge" style="background: #F59E0B;">⏳</span>
                            <span>MEINE WETTEN</span>
                        </div>
                        <div class="betslip-options" style="display:flex; gap:8px; align-items:center;">
                            ${backBtnOpen}
                            <button id="open-bets-refresh-btn" onclick="(window.loadOpenBetsInline && window.loadOpenBetsInline(true))" style="background:#F59E0B; color:#111827; border:none; padding:6px 10px; border-radius:6px; cursor:pointer;">Aktualisieren</button>
                            <span id="open-bets-last-updated" style="font-size:12px; color:#6b7280;"></span>
                        </div>
                    </div>`;
                const subnav = `
                    <div class="betslip-subnav" style="display:flex; align-items:center; gap:8px; margin:6px 0 12px 0;">
                        <button class="toggle-chip active" onclick="window.setBetSlipView && window.setBetSlipView('open')" style="background:#4F46E5; color:#fff; border:none; padding:6px 10px; border-radius:20px; cursor:pointer;">OFFEN</button>
                        <button class="toggle-chip" onclick="window.setBetSlipView && window.setBetSlipView('recent')" style="background:#E5E7EB; color:#111827; border:none; padding:6px 10px; border-radius:20px; cursor:pointer;">ABGERECHNET</button>
                    </div>`;
                const body = `
                    <div id="open-bets-inline" style="margin-top:10px;">
                        <div style="padding:16px; color:#6b7280;">Laden...</div>
                    </div>`;
                container.innerHTML = header + subnav + body;
                setTimeout(() => { if (typeof window.loadOpenBetsInline === 'function') window.loadOpenBetsInline(); }, 0);
                // Start polling while Open view is active
                try { if (window._openBetsPoll) clearInterval(window._openBetsPoll); } catch (_) {}
                window._openBetsPoll = setInterval(() => {
                    try {
                        if (window.betslipViewMode === 'open' && typeof window.loadOpenBetsInline === 'function') {
                            window.loadOpenBetsInline();
                        }
                    } catch (_) { /* ignore */ }
                }, 30000);
                return;
            }
            
            if (window.betSlip.length === 0) {
                container.innerHTML = `
                    <div class="betslip-empty" style="padding: 40px; text-align: center; color: #666;">
                        <p style="font-size: 14px;">Noch keine Wetten ausgewählt</p>
                        <p style="font-size: 12px; margin-top: 8px;">Klicken Sie auf die Quoten, um Wetten hinzuzufügen</p>
                        <div style="margin-top: 14px; display:flex; gap:8px; justify-content:center; flex-wrap:wrap;">
                            <button onclick="window.setBetSlipView && window.setBetSlipView('open')" style="background:#F59E0B; color:#111827; border:none; padding:8px 12px; border-radius:6px; cursor:pointer;">Offene Wetten anzeigen</button>
                            <button onclick="window.setBetSlipView && window.setBetSlipView('recent')" style="background:#4F46E5; color:#fff; border:none; padding:8px 12px; border-radius:6px; cursor:pointer;">Abgeschlossene Wetten anzeigen</button>
                        </div>
                    </div>
                `;
                return;
            }

            // Calculate combination odds
            const combiOdds = window.betSlip.reduce((total, bet) => total * bet.odds, 1);
            const renderProminentCombi = window.betSlip.length > 1;
            let html = `
                <div class="betslip-header">
                    <div class="betslip-count">
                        <span class="count-badge" style="background: #4F46E5;">${window.betSlip.length}</span>
                        <span>WETTEN</span>
                    </div>
                    <span class="betslip-options" onclick="clearAllBets()">Alle löschen</span>
                </div>
                <div class="betslip-subnav" style="display:flex; align-items:center; gap:8px; margin:6px 0 12px 0;">
                    <button class="toggle-chip active" onclick="window.setBetSlipView && window.setBetSlipView('slip')" style="background:#4F46E5; color:#fff; border:none; padding:6px 10px; border-radius:20px; cursor:pointer;">WETTEN</button>
                    <button class="toggle-chip" onclick="window.setBetSlipView && window.setBetSlipView('open')" style="background:#E5E7EB; color:#111827; border:none; padding:6px 10px; border-radius:20px; cursor:pointer; display:inline-flex; align-items:center; gap:6px;">MEINE WETTEN <span id="meine-wetten-count-badge" style="display:none; background:#F59E0B; color:#111827; border-radius:10px; padding:0 6px; font-size:11px; line-height:18px; min-width:18px; text-align:center;">0</span></button>
                </div>
            `;

            // If more than 1 selection, show combination bet FIRST (prominent position)
            if (renderProminentCombi) {
                // Initialize combiStake to 0 if not set (user must choose amount)
                if (window.combiStake === undefined) {
                    window.combiStake = 0;
                }
                const combiStake = window.combiStake;
                const combiPotential = (combiStake * combiOdds).toFixed(2);
                html += `
                    <div class="combo-section">
                        <div class="combo-header">
                            <span class="combo-title">
                                🎯 KOMBI-WETTE (${window.betSlip.length}er)
                            </span>
                            <span class="combo-odds">${combiOdds.toFixed(2)}</span>
                        </div>
                        <div class="combo-hint" style="margin: 6px 0 2px; font-size: 12px; color: #6b7280;">
                            💡 Höhere Auszahlung mit Kombi – Einsatz hier setzen
                        </div>
                        <div class="combo-inner">
                            <div class="combo-stake-row">
                                <input type="number" 
                                       class="combo-stake-input"
                                       id="combo-stake"
                                       value="${combiStake}" 
                                       min="0" 
                                       max="${(window.getCurrentCoins ? window.getCurrentCoins() : window.coins)}"
                                       placeholder="Einsatz"
                                       oninput="updateCombiStake(this.value, true)">
                            </div>
                            <div class="quick-stakes" id="combo-quick-stakes">
                                <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===0 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===0 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(0)">0</button>
                                <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===10 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===10 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(10)">10</button>
                                <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===25 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===25 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(25)">25</button>
                                <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===50 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===50 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(50)">50</button>
                                <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===100 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===100 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(100)">100</button>
                                <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===250 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===250 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(250)">250</button>
                                <button class="stake-btn combo-btn ${window.selectedCombiQuickStake==='MAX' ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake==='MAX' ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiMaxStake()">MAX</button>
                            </div>
                            <div class="combo-potential">
                                💰 Möglicher Gewinn: <span id="combo-potential-amount">${combiPotential}</span> coins
                            </div>
                        </div>
                    </div>
                `;
            }

            // Add bet items container, then combo (if any), then singles
            html += '<div class="betslip-items">';
            if (!renderProminentCombi && window.betSlip.length > 1) {
                if (window.combiStake === undefined) { window.combiStake = 0; }
                const combiStake = window.combiStake;
                const combiPotential = (combiStake * combiOdds).toFixed(2);
                html += '<div class="bets-subheader">Kombis</div>';
                html += `
                    <div class="bet-item combi">
                        <div class="bet-info">
                            <div class="bet-details">
                                <div class="bet-team">Kombi-Wette (${window.betSlip.length}er)</div>
                                <div class="bet-market">Kombiquote</div>
                                <div class="bet-match-info">Alle Auswahlen</div>
                            </div>
                            <div class="bet-odds-stake">
                                <span class="bet-odds">${combiOdds.toFixed(2)}</span>
                                <div class="stake-input-group">
                                    <input type="number" 
                                           class="stake-input"
                                           id="combo-stake"
                                           value="${combiStake}" 
                                           min="0" 
                                           max="${(window.getCurrentCoins ? window.getCurrentCoins() : window.coins)}"
                                           placeholder="0"
                                           inputmode="numeric"
                                           step="1"
                                           oninput="updateCombiStake(this.value, true)">
                                </div>
                            </div>
                            <span class="potential-win">Gewinn: <span id="combo-potential-amount">${combiPotential}</span> coins</span>
                        </div>
                        <div class="quick-stakes" id="combo-quick-stakes">
                            <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===0 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===0 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(0)">0</button>
                            <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===10 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===10 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(10)">10</button>
                            <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===25 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===25 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(25)">25</button>
                            <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===50 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===50 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(50)">50</button>
                            <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===100 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===100 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(100)">100</button>
                            <button class="stake-btn combo-btn ${window.selectedCombiQuickStake===250 ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake===250 ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiQuickStake(250)">250</button>
                            <button class="stake-btn combo-btn ${window.selectedCombiQuickStake==='MAX' ? 'active' : ''}" aria-pressed="${window.selectedCombiQuickStake==='MAX' ? 'true' : 'false'}" onmousedown="window._captureComboQuickFocus && window._captureComboQuickFocus()" onclick="setCombiMaxStake()">MAX</button>
                        </div>
                    </div>
                `;
            }
            html += '<div class="bets-subheader">Einzel</div>';
            window.betSlip.forEach((bet, index) => {
                const potentialWin = (bet.stake * bet.odds).toFixed(2);
                const type = getBetType(bet.id);
                const marketLabel = (type === 'double_chance')
                    ? 'Doppelte Chance'
                    : (type === 'match_result'
                        ? 'Endergebnis'
                        : (type === 'total_goals'
                            ? 'Über/Unter'
                            : (type === 'btts' ? 'Beide Teams treffen' : 'Wette')));
                const marketTag = (type === 'double_chance'
                    ? 'DC'
                    : (type === 'match_result'
                        ? '1X2'
                        : (type === 'total_goals'
                            ? 'O/U'
                            : (type === 'btts' ? 'BTTS' : ''))));
                html += `
                    <div class="bet-item" onmousedown="_captureRowFocus(${index})" ontouchstart="_captureRowFocus(${index})" onclick="focusStakeInput(${index}, event)">
                        <button class="bet-remove" onclick="event.stopPropagation(); removeBet('${bet.id}')">×</button>
                        <div class="bet-info">
                            <div class="bet-details">
                                <div class="bet-team">${bet.selection}</div>
                                <div class="bet-market">${marketLabel}${marketTag ? (' <span class="market-tag ' + type + '">' + marketTag + '</span>') : ''}</div>
                                <div class="bet-match-info">${bet.match}</div>
                            </div>
                            <div class="bet-odds-stake">
                                <span class="bet-odds">${bet.odds.toFixed(2)}</span>
                                <div class="stake-input-group">
                                    <input type="number" 
                                           class="stake-input"
                                           id="stake-${index}"
                                           value="${bet.stake ?? ''}" 
                                           min="0" 
                                           max="${(window.getCurrentCoins ? window.getCurrentCoins() : window.coins)}"
                                           placeholder="0"
                                           inputmode="numeric"
                                           step="1"
                                           onfocus="setFocusedStakeIndex(${index})"
                                           onblur="clearFocusedStakeIndex(${index})"
                                           oninput="updateStake(${index}, this.value, true)">
                                </div>
                            </div>
                            <span class="potential-win" id="potential-win-${index}">Gewinn: ${potentialWin} coins</span>
                        </div>
                    </div>
                `;
            });
            html += '</div>';

            // Single bet quick stakes (less prominent)
            const singlesCountForLabel = Array.isArray(window.betSlip) ? window.betSlip.length : 0;
            const quickStakeContextLabel = (singlesCountForLabel > 1)
                ? 'Schnelleinsatz: Alle Wetten'
                : 'Schnelleinsatz: Diese Wette';
            html += `
                <div class="singles-quick-wrap">
                    <div id="singles-quick-stake-label" style="font-size: 12px; color: #666; margin-bottom: 6px;">${quickStakeContextLabel}</div>
                    <div class="quick-stakes" id="singles-quick-stakes">
                        <button class="stake-btn ${window.selectedSinglesQuickStake===0 ? 'active' : ''}" aria-pressed="${window.selectedSinglesQuickStake===0 ? 'true' : 'false'}" onmousedown="window._captureSinglesQuickFocus()" onclick="setQuickStake(0)">0</button>
                        <button class="stake-btn ${window.selectedSinglesQuickStake===5 ? 'active' : ''}" aria-pressed="${window.selectedSinglesQuickStake===5 ? 'true' : 'false'}" onmousedown="window._captureSinglesQuickFocus()" onclick="setQuickStake(5)">5</button>
                        <button class="stake-btn ${window.selectedSinglesQuickStake===10 ? 'active' : ''}" aria-pressed="${window.selectedSinglesQuickStake===10 ? 'true' : 'false'}" onmousedown="window._captureSinglesQuickFocus()" onclick="setQuickStake(10)">10</button>
                        <button class="stake-btn ${window.selectedSinglesQuickStake===25 ? 'active' : ''}" aria-pressed="${window.selectedSinglesQuickStake===25 ? 'true' : 'false'}" onmousedown="window._captureSinglesQuickFocus()" onclick="setQuickStake(25)">25</button>
                        <button class="stake-btn ${window.selectedSinglesQuickStake===50 ? 'active' : ''}" aria-pressed="${window.selectedSinglesQuickStake===50 ? 'true' : 'false'}" onmousedown="window._captureSinglesQuickFocus()" onclick="setQuickStake(50)">50</button>
                        <button class="stake-btn ${window.selectedSinglesQuickStake===100 ? 'active' : ''}" aria-pressed="${window.selectedSinglesQuickStake===100 ? 'true' : 'false'}" onmousedown="window._captureSinglesQuickFocus()" onclick="setQuickStake(100)">100</button>
                        <button class="stake-btn ${window.selectedSinglesQuickStake==='MAX' ? 'active' : ''}" aria-pressed="${window.selectedSinglesQuickStake==='MAX' ? 'true' : 'false'}" onmousedown="window._captureSinglesQuickFocus()" onclick="setMaxStake()">MAX</button>
                    </div>
                </div>
            `;

            // Calculate totals
            const totalSinglesStake = window.betSlip.reduce((total, bet) => total + (Number(bet.stake) || 0), 0);
            const combiStake = window.combiStake || 0;
            const totalStake = totalSinglesStake + (window.betSlip.length > 1 ? combiStake : 0);
            const totalPotentialWin = window.betSlip.reduce((total, bet) => total + ((Number(bet.stake)||0) * bet.odds), 0) + 
                                      (window.betSlip.length > 1 ? combiStake * combiOdds : 0);
            
            // Place bet section with platform colors
            html += `
                <div class="place-bet-section">
                    <button id="place-bet-btn" class="place-bet-btn" onclick="placeBets()" ${(totalStake === 0 || totalStake > Number((window.getCurrentCoins ? window.getCurrentCoins() : window.coins)||0)) ? 'disabled' : ''}>
                        Wette platzieren - <span id="place-bet-total-coins">${totalStake.toFixed(0)}</span> coins
                    </button>
                    <div class="bet-totals">
                        <span>Gesamteinsatz: <span id="total-stake-coins">${totalStake.toFixed(0)}</span> coins</span>
                        <span>Möglicher Gewinn: <span id="total-potential-coins">${totalPotentialWin.toFixed(0)}</span> coins</span>
                    </div>
                </div>
            `;

            container.innerHTML = html;
            // After rendering slip view, refresh the open bets count badge asynchronously
            setTimeout(() => { if (typeof window.refreshOpenBetsCountBadge === 'function') window.refreshOpenBetsCountBadge(); }, 0);
            // Ensure outside-click/tap unfocus is active after render
            if (typeof setupBetSlipOutsideUnfocus === 'function') setupBetSlipOutsideUnfocus();
            // Reflect changes in the sticky mobile bet bar
            if (typeof updateBetBar === 'function') updateBetBar();
            // Apply post-render focus intent (set by toggleBet) when rendering Slip view
            try {
                if (window._focusAfterRender) {
                    const intent = window._focusAfterRender;
                    // Clear immediately to avoid reapplying on subsequent renders
                    window._focusAfterRender = null;
                    setTimeout(() => {
                        try {
                            if (intent.input === 'single' && typeof intent.index === 'number') {
                                const el = document.getElementById('stake-' + intent.index);
                                if (el) {
                                    window.focusedStakeIndex = intent.index;
                                    el.focus();
                                    if (el.type && el.type !== 'number') {
                                        try { if (el.select) el.select(); } catch (_) {}
                                    }
                                    // Visual focus on the row
                                    try {
                                        document.querySelectorAll('.bet-item.row-focused').forEach(n => n.classList.remove('row-focused'));
                                        const row = el.closest ? el.closest('.bet-item') : null;
                                        if (row) row.classList.add('row-focused');
                                    } catch (_) { /* noop */ }
                                    if (typeof updateQuickStakeLabel === 'function') updateQuickStakeLabel();
                                }
                            } else if (intent.input === 'combo') {
                                const combo = document.getElementById('combo-stake');
                                if (combo) {
                                    combo.focus();
                                    if (combo.type && combo.type !== 'number') {
                                        const end = combo.value.length;
                                        try { if (combo.setSelectionRange) combo.setSelectionRange(0, end); } catch (_) {}
                                    }
                                }
                            }
                        } catch (_) { /* noop */ }
                    }, 0);
                }
            } catch (_) { /* noop */ }
        }

        // Toggle bet slip view between current slip, open and recent bets
        window.setBetSlipView = function(view) {
            window.betslipViewMode = ((view === 'recent') || (view === 'open')) ? view : 'slip';
            // Any manual selection cancels auto-applied Open behavior
            window._betslipAutoOpenApplied = false;
            updateBetSlip();
        }

        // Load recent bets inline inside the bet slip tab (last 7 days, up to 10)
        window.loadRecentBetsInline = async function() {
            const wrap = document.getElementById('recent-bets-inline');
            if (!wrap) return;
            const sinceMs = 7 * 24 * 60 * 60 * 1000; // 7 days
            const sinceIso = new Date(Date.now() - sinceMs).toISOString();
            try {
                // Try Supabase first
                let entries = [];
                try {
                    if (typeof supabaseClient !== 'undefined' && supabaseClient && supabaseClient.auth) {
                        const { data: { user } } = await supabaseClient.auth.getUser();
                        if (user) {
                            const { data: slips, error } = await supabaseClient
                                .from('bet_slips')
                                .select('*, bet_slip_items(*)')
                                .eq('user_id', user.id)
                                .in('status', ['Won','Lost','won','lost'])
                                .gte('placed_at', sinceIso)
                                .order('placed_at', { ascending: false })
                                .limit(10);
                            if (!error && Array.isArray(slips) && slips.length) {
                                entries = slips.map(slip => ({ source: 'db', slip }));
                            }
                        }
                    }
                } catch (_) { /* ignore supabase errors and fall back */ }

                // Try Node server next
                if (!entries.length && typeof API_BASE !== 'undefined' && currentUser && currentUser.id) {
                    try {
                        const res = await fetch(`${API_BASE}/api/bets/user/${currentUser.id}`);
                        if (res.ok) {
                            const data = await res.json();
                            const list = (data && Array.isArray(data.bets)) ? data.bets : (Array.isArray(data) ? data : []);
                            const cutoff = Date.now() - sinceMs;
                            const finished = list
                                .filter(b => {
                                    const st = String(b.status || '').toLowerCase();
                                    const t = new Date(b.placedAt || b.timestamp).getTime();
                                    return (st === 'won' || st === 'lost') && isFinite(t) && t >= cutoff;
                                })
                                .sort((a, b) => {
                                    const ta = new Date(a.placedAt || a.timestamp || 0).getTime();
                                    const tb = new Date(b.placedAt || b.timestamp || 0).getTime();
                                    return (isFinite(tb) ? tb : 0) - (isFinite(ta) ? ta : 0);
                                })
                                .slice(0, 10);
                            if (finished.length) entries = finished.map(nb => ({ source: 'node', node: nb }));
                        }
                    } catch (_) { /* ignore */ }
                }

                // Fallback to localStorage if no entries found
                if (!entries.length) {
                    try {
                        const placedBets = JSON.parse(localStorage.getItem('placedBets') || '[]');
                        const legacyUserBets = JSON.parse(localStorage.getItem('userBets') || '[]');
                        const merged = [...(Array.isArray(placedBets) ? placedBets : []), ...(Array.isArray(legacyUserBets) ? legacyUserBets : [])];
                        const cutoff = Date.now() - sinceMs;
                        const filteredSorted = merged
                            .filter(b => {
                                if (!b) return false;
                                const st = String(b.status || '').toLowerCase();
                                const finished = st === 'won' || st === 'lost';
                                if (!finished) return false;
                                const t = new Date(b.timestamp).getTime();
                                if (!isFinite(t)) return false; // require timestamp to enforce window
                                return t >= cutoff;
                            })
                            .sort((a, b) => {
                                const ta = new Date(a.timestamp || 0).getTime();
                                const tb = new Date(b.timestamp || 0).getTime();
                                return (isFinite(tb) ? tb : 0) - (isFinite(ta) ? ta : 0);
                            })
                            .slice(0, 10);
                        entries = filteredSorted.map(lb => ({ source: 'local', local: lb }));
                    } catch (_) { /* ignore */ }
                }

                if (!entries.length) {
                    wrap.innerHTML = '<div style="padding:16px; color:#6b7280;">Keine abgeschlossenen Wetten.</div>';
                    return;
                }

                const html = entries.map((item, idx) => {
                    if (item.source === 'db') {
                        const s = item.slip;
                        const placed = s.placed_at ? new Date(s.placed_at) : null;
                        const disp = placed ? placed.toLocaleString('de-DE') : '';
                        const stake = Number(s.total_stake ?? s.totalStake ?? 0);
                        const odds = Number(s.total_odds ?? s.totalOdds ?? 1);
                        const potential = Number(s.potential_win ?? s.potentialWin ?? (stake * odds));
                        const statusClass = String(s.status || '').toLowerCase();
                        const statusUC = statusClass ? statusClass.charAt(0).toUpperCase() + statusClass.slice(1) : 'Won';
                        const sc = (statusClass === 'won') ? 'color:#16a34a;' : ((statusClass === 'lost') ? 'color:#dc2626;' : 'color:#6b7280;');
                        const itemsHtml = (Array.isArray(s.bet_slip_items) ? s.bet_slip_items.slice(0, 4).map(si => {
                            const match = [si.home_team, si.away_team].filter(Boolean).join(' vs ');
                            const sel = String(si.bet_type || '').toUpperCase();
                            const o = Number(si.odds || 1);
                            return `
                                <div class="rbi-line" style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin:2px 0;">
                                    <div class="rbi-match" style="font-size:12px; color:#111827;">${match}</div>
                                    <div class="rbi-right" style="display:flex; gap:6px; font-size:12px; color:#111827;">
                                        <span class="rbi-type" style="background:#E5E7EB; padding:2px 6px; border-radius:12px;">${sel}</span>
                                        <span class="rbi-odds">@ ${isNaN(o) ? '-' : o.toFixed(2)}</span>
                                    </div>
                                </div>`;
                        }).join('') : '');
                        return `
                            <div class="recent-bet-card" style="border:1px solid #E5E7EB; border-radius:10px; padding:10px; margin:8px 0; background:#ffffff;">
                                <div class="rbi-top" style="display:flex; justify-content:space-between; font-size:12px; color:#6b7280;">
                                    <span class="rbi-time">${disp}</span>
                                    <span class="rbi-status" style="${sc}">${statusUC}</span>
                                </div>
                                <div class="rbi-body" style="margin:8px 0;">${itemsHtml}</div>
                                <div class="rbi-bottom" style="display:flex; justify-content:space-between; font-size:12px; color:#111827;">
                                    <span>Einsatz: ${isNaN(stake) ? '-' : stake} • Quote: ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                    <span>Gewinn: ${isNaN(potential) ? '-' : potential.toFixed(0)}</span>
                                </div>
                            </div>`;
                    } else if (item.source === 'node') {
                        const b = item.node;
                        const disp = b.placedAt ? new Date(b.placedAt).toLocaleString('de-DE') : (b.timestamp ? new Date(b.timestamp).toLocaleString('de-DE') : '');
                        const stake = Number(b.stake || b.totalStake || 0);
                        const odds = Number(b.odds || b.totalOdds || 1);
                        const potential = Number(b.potentialWin ?? (stake * odds));
                        const statusClass = String(b.status || '').toLowerCase();
                        const statusUC = statusClass ? statusClass.charAt(0).toUpperCase() + statusClass.slice(1) : 'Won';
                        const sc = (statusClass === 'won') ? 'color:#16a34a;' : ((statusClass === 'lost') ? 'color:#dc2626;' : 'color:#6b7280;');
                        let matchStr = '';
                        try {
                            if (b.matchId && window.matchIndex && window.matchIndex[b.matchId]) {
                                const m = window.matchIndex[b.matchId];
                                matchStr = `${m.homeTeam || ''} vs ${m.awayTeam || ''}`;
                            } else if (b.match) {
                                matchStr = String(b.match);
                            }
                        } catch (_) { /* ignore */ }
                        if (!matchStr) {
                            try {
                                if (b.matchId) {
                                    matchStr = String(b.matchId).replace(/-/g, ' vs ');
                                }
                            } catch (_) { /* ignore */ }
                        }
                        const selectionText = (b.selection || b.market || '').toString().toUpperCase();
                        return `
                            <div class="recent-bet-card" style="border:1px solid #E5E7EB; border-radius:10px; padding:10px; margin:8px 0; background:#ffffff;">
                                <div class="rbi-top" style="display:flex; justify-content:space-between; font-size:12px; color:#6b7280;">
                                    <span class="rbi-time">${disp}</span>
                                    <span class="rbi-status" style="${sc}">${statusUC}</span>
                                </div>
                                <div class="rbi-body" style="margin:8px 0;">
                                    <div class="rbi-line" style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin:2px 0;">
                                        <div class="rbi-match" style="font-size:12px; color:#111827;">${matchStr}</div>
                                        <div class="rbi-right" style="display:flex; gap:6px; font-size:12px; color:#111827;">
                                            <span class="rbi-type" style="background:#E5E7EB; padding:2px 6px; border-radius:12px;">${selectionText}</span>
                                            <span class="rbi-odds">@ ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="rbi-bottom" style="display:flex; justify-content:space-between; font-size:12px; color:#111827;">
                                    <span>Einsatz: ${isNaN(stake) ? '-' : stake} • Quote: ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                    <span>Gewinn: ${isNaN(potential) ? '-' : potential.toFixed(0)}</span>
                                </div>
                            </div>`;
                    } else {
                        const l = item.local;
                        const disp = l.displayTime || (l.timestamp ? new Date(l.timestamp).toLocaleString('de-DE') : '');
                        const stake = Number(l.totalStake || 0);
                        const odds = Number(l.totalOdds || l.combiOdds || 1);
                        const potential = Number(l.potentialWin ?? (stake * odds));
                        const statusClass = String(l.status || '').toLowerCase();
                        const statusUC = statusClass ? statusClass.charAt(0).toUpperCase() + statusClass.slice(1) : 'Won';
                        const sc = (statusClass === 'won') ? 'color:#16a34a;' : ((statusClass === 'lost') ? 'color:#dc2626;' : 'color:#6b7280;');
                        const lines = Array.isArray(l.bets) ? l.bets.slice(0, 4).map(b => {
                            const o = Number(b.odds || 1);
                            return `
                                <div class="rbi-line" style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin:2px 0;">
                                    <div class="rbi-match" style="font-size:12px; color:#111827;">${b.match || ''}</div>
                                    <div class="rbi-right" style="display:flex; gap:6px; font-size:12px; color:#111827;">
                                        <span class="rbi-type" style="background:#E5E7EB; padding:2px 6px; border-radius:12px;">${String(b.selection || '').toUpperCase()}</span>
                                        <span class="rbi-odds">@ ${isNaN(o) ? '-' : o.toFixed(2)}</span>
                                    </div>
                                </div>`;
                        }).join('') : '';
                        return `
                            <div class="recent-bet-card" style="border:1px solid #E5E7EB; border-radius:10px; padding:10px; margin:8px 0; background:#ffffff;">
                                <div class="rbi-top" style="display:flex; justify-content:space-between; font-size:12px; color:#6b7280;">
                                    <span class="rbi-time">${disp}</span>
                                    <span class="rbi-status" style="${sc}">${statusUC}</span>
                                </div>
                                <div class="rbi-body" style="margin:8px 0;">${lines}</div>
                                <div class="rbi-bottom" style="display:flex; justify-content:space-between; font-size:12px; color:#111827;">
                                    <span>Einsatz: ${isNaN(stake) ? '-' : stake} • Quote: ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                    <span>Gewinn: ${isNaN(potential) ? '-' : potential.toFixed(0)}</span>
                                </div>
                            </div>`;
                    }
                }).join('');

                wrap.innerHTML = `<div class="recent-bets-list">${html}</div>`;
            } catch (e) {
                wrap.innerHTML = '<div style="padding:16px; color:#b91c1c;">Fehler beim Laden der kürzlichen Wetten.</div>';
            }
        }

        // Utility: fetch with timeout to prevent stuck "Laden..." if a request hangs
        window.fetchWithTimeout = async function(url, options = {}, timeoutMs = 7000) {
            const controller = new AbortController();
            const id = setTimeout(() => { try { controller.abort(); } catch (_) {} }, timeoutMs);
            try {
                return await fetch(url, Object.assign({}, options, { signal: controller.signal }));
            } finally {
                clearTimeout(id);
            }
        };

        // Helpers for Open Bets UI
        window.setOpenBetsLoading = function(isLoading) {
            try {
                const btn = document.getElementById('open-bets-refresh-btn');
                if (!btn) return;
                if (isLoading) {
                    if (!btn.dataset._orig) btn.dataset._orig = btn.textContent || 'Aktualisieren';
                    btn.textContent = 'Aktualisieren…';
                    btn.setAttribute('aria-busy', 'true');
                    btn.disabled = true;
                } else {
                    btn.textContent = btn.dataset._orig || 'Aktualisieren';
                    btn.removeAttribute('aria-busy');
                    btn.disabled = false;
                }
            } catch (_) { /* ignore */ }
        };

        window.updateOpenBetsLastUpdated = function(ts) {
            try {
                const el = document.getElementById('open-bets-last-updated');
                if (!el) return;
                const t = (typeof ts === 'number') ? new Date(ts) : (ts ? new Date(ts) : new Date());
                el.textContent = 'Zuletzt aktualisiert: ' + t.toLocaleTimeString('de-DE');
            } catch (_) { /* ignore */ }
        };

        // Load open (pending) bets inline inside the bet slip tab
        window.loadOpenBetsInline = async function(force = false) {
            const wrap = document.getElementById('open-bets-inline');
            if (!wrap) return;
            // Only do work if Open view is active, unless forced
            try { if (!force && window.betslipViewMode && window.betslipViewMode !== 'open') { return; } } catch (_) {}
            // Short TTL cache (10s): render cached HTML to avoid redundant network calls during bursts
            try {
                const now = Date.now();
                const ttlMs = 10000;
                if (!window._openBetsCache) {
                    try {
                        const persisted = localStorage.getItem('open_bets_cache');
                        if (persisted) window._openBetsCache = JSON.parse(persisted) || null;
                    } catch (_) { /* ignore */ }
                }
                const cache = window._openBetsCache;
                if (!force && cache && cache.ts && (now - cache.ts < ttlMs) && typeof cache.html === 'string') {
                    wrap.innerHTML = cache.html;
                    try { if (typeof window.setMeineWettenCountBadge === 'function') window.setMeineWettenCountBadge(Number(cache.count) || 0); } catch (_) {}
                    try { if (typeof window.updateOpenBetsLastUpdated === 'function') window.updateOpenBetsLastUpdated(cache.ts); } catch (_) {}
                    try { if (typeof window.setOpenBetsLoading === 'function') window.setOpenBetsLoading(false); } catch (_) {}
                    return;
                }
            } catch (_) { /* ignore */ }
            // In-flight dedupe: skip if a load is already in progress (unless forced)
            if (!force && window._openBetsLoading) { return; }
            window._openBetsLoading = true;
            try {
                try { if (wrap) wrap.setAttribute('data-loading', '1'); } catch (_) {}
                try { if (typeof window.setOpenBetsLoading === 'function') window.setOpenBetsLoading(true); } catch (_) {}
                try { console.debug('[openBets] start', { userId: (window.currentUser && window.currentUser.id) ? window.currentUser.id : null, hasIndex: (window.matchIndex && Object.keys(window.matchIndex).length) ? true : false }); } catch (_) {}
                // Ensure we have a match index for mapping matchId -> match name (home vs away)
                try {
                    const needsIndex = !window.matchIndex || (typeof window.matchIndex === 'object' && Object.keys(window.matchIndex).length === 0);
                    if (needsIndex && typeof API_BASE !== 'undefined') {
                        const r = await window.fetchWithTimeout(`${API_BASE}/api/matches`, {}, 5000);
                        if (r && r.ok) {
                            const d = await r.json();
                            const arr = (d && Array.isArray(d.matches)) ? d.matches : (Array.isArray(d) ? d : []);
                            const idx = {};
                            (arr || []).forEach(m => { if (m && m.id) idx[m.id] = m; });
                            window.matchIndex = idx;
                        }
                    }
                } catch (_) { /* non-fatal */ }
                let entries = [];
                // 1) Try Supabase (preferred)
                try {
                    if (typeof supabaseClient !== 'undefined' && supabaseClient && supabaseClient.auth) {
                        const { data: { user } } = await supabaseClient.auth.getUser();
                        if (user) {
                            const { data: slips, error } = await supabaseClient
                                .from('bet_slips')
                                .select('*, bet_slip_items(*)')
                                .eq('user_id', user.id)
                                .in('status', ['pending','Pending'])
                                .order('placed_at', { ascending: false })
                                .limit(10);
                            if (!error && Array.isArray(slips) && slips.length) {
                                entries = slips.map(slip => ({ source: 'db', slip }));
                            }
                        }
                    }
                } catch (_) { /* ignore */ }

                // 2) Try backend server API (Python/Node)
                if (!entries.length && typeof API_BASE !== 'undefined') {
                    // Ensure we have a backend user id; attempt lightweight re-auth if missing
                    try {
                        if ((!window.currentUser || !window.currentUser.id) && window.currentUser && window.currentUser.username) {
                            const authRes = await window.fetchWithTimeout(`${API_BASE}/api/auth/login`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ username: window.currentUser.username })
                            }, 5000);
                            if (authRes && authRes.ok) {
                                const authData = await authRes.json();
                                if (authData && authData.user) {
                                    window.currentUser = authData.user;
                                    try { localStorage.setItem('scoreLeagueUser', JSON.stringify(window.currentUser)); } catch (_) {}
                                }
                            }
                        }
                    } catch (_) { /* ignore */ }
                    if (window.currentUser && window.currentUser.id) {
                        try {
                            const url = `${API_BASE}/api/bets/user/${window.currentUser.id}`;
                            try { console.debug('[openBets] fetch', url); } catch (_) {}
                            const res = await window.fetchWithTimeout(url, {}, 6000);
                            if (res.ok) {
                                const data = await res.json();
                                const list = (data && Array.isArray(data.bets)) ? data.bets : (Array.isArray(data) ? data : []);
                                const pending = list.filter(b => {
                                    const st = String(b.status || 'pending').toLowerCase();
                                    return st === 'pending' || st === 'open';
                                }).slice(0, 10);
                                try { console.debug('[openBets] backend result', { all: (Array.isArray(list) ? list.length : 0), pending: pending.length }); } catch (_) {}
                                if (pending.length) entries = pending.map(nb => ({ source: 'node', node: nb }));
                            } else {
                                try { console.warn('[openBets] backend non-OK status', res.status); } catch (_) {}
                            }
                        } catch (_) { /* ignore */ }
                    }
                }

                // 3) Fallback to localStorage
                if (!entries.length) {
                    try {
                        const placedBets = JSON.parse(localStorage.getItem('placedBets') || '[]');
                        const pending = (Array.isArray(placedBets) ? placedBets : []).filter(b => String(b.status || '').toLowerCase() === 'pending');
                        entries = pending.map(lb => ({ source: 'local', local: lb }));
                    } catch (_) { /* ignore */ }
                }

                if (!entries.length) {
                    wrap.innerHTML = '<div style="padding:16px; color:#6b7280;">Keine offenen Wetten.</div>';
                    try { if (typeof window.setMeineWettenCountBadge === 'function') window.setMeineWettenCountBadge(0); } catch (_) {}
                    try { window._openBetsCache = { ts: Date.now(), html: wrap.innerHTML, count: 0 }; localStorage.setItem('open_bets_cache', JSON.stringify(window._openBetsCache)); } catch (_) {}
                    try { if (typeof window.updateOpenBetsLastUpdated === 'function') window.updateOpenBetsLastUpdated(window._openBetsCache && window._openBetsCache.ts ? window._openBetsCache.ts : Date.now()); } catch (_) {}
                    return;
                }

                // Normalize timestamps and sort by most recent first
                try {
                    const ts = (it) => {
                        if (!it) return 0;
                        if (it.source === 'db') return new Date((it.slip && (it.slip.placed_at || it.slip.created_at)) || 0).getTime();
                        if (it.source === 'node') return new Date((it.node && (it.node.placedAt || it.node.timestamp)) || 0).getTime();
                        return new Date((it.local && (it.local.timestamp || it.local.displayTime)) || 0).getTime();
                    };
                    entries.sort((a, b) => (ts(b) || 0) - (ts(a) || 0));
                } catch (_) { /* ignore */ }

                const html = entries.map((item, idx) => {
                    if (item.source === 'db') {
                        const s = item.slip;
                        const placed = s.placed_at ? new Date(s.placed_at) : null;
                        const disp = placed ? placed.toLocaleString('de-DE') : '';
                        const stake = Number(s.total_stake ?? s.totalStake ?? 0);
                        const odds = Number(s.total_odds ?? s.totalOdds ?? 1);
                        const potential = Number(s.potential_win ?? s.potentialWin ?? (stake * odds));
                        const isSingle = Array.isArray(s.bet_slip_items) && s.bet_slip_items.length === 1;
                        const detailsId = `obd-db-${idx}`;
                        let headerMatchStr = '';
                        let headerMarketLabel = '';
                        let headerSelectionLabel = '';
                        if (isSingle) {
                            const si0 = s.bet_slip_items[0];
                            headerMatchStr = [si0.home_team, si0.away_team].filter(Boolean).join(' vs ');
                            const c = String(si0.bet_type || '').toLowerCase();
                            const market = (['1', 'x', '2', 'home', 'draw', 'away'].includes(c) ? 'match_result'
                                : (['1x', '12', 'x2'].includes(c) ? 'double_chance'
                                : (['over', 'under'].includes(c) ? 'total_goals'
                                : (['yes', 'no'].includes(c) ? 'btts' : ''))));
                            headerMarketLabel = displayMarketLabel(market);
                            headerSelectionLabel = selectionLabelFromCode(si0.bet_type);
                        } else {
                            const cnt = Array.isArray(s.bet_slip_items) ? s.bet_slip_items.length : 0;
                            headerMatchStr = `Kombi (${cnt})`;
                        }
                        const itemsHtml = (Array.isArray(s.bet_slip_items) ? s.bet_slip_items.map(si => {
                            const match = [si.home_team, si.away_team].filter(Boolean).join(' vs ');
                            const sel = String(si.bet_type || '').toUpperCase();
                            const o = Number(si.odds || 1);
                            return `
                                <div class="obi-line" style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin:2px 0;">
                                    <div class="obi-match" style="font-size:12px; color:#111827;">${match}</div>
                                    <div class="obi-right" style="display:flex; gap:6px; font-size:12px; color:#111827;">
                                        <span class="obi-type" style="background:#FEF3C7; color:#92400E; padding:2px 6px; border-radius:12px;">${sel}</span>
                                        <span class="obi-odds">@ ${isNaN(o) ? '-' : o.toFixed(2)}</span>
                                    </div>
                                </div>`;
                        }).join('') : '');
                        return `
                            <div class="open-bet-card" style="border:1px solid #FDE68A; border-radius:10px; padding:10px; margin:8px 0; background:#FFFBEB;">
                                <div class="obi-top" style="display:flex; justify-content:space-between; align-items:center; gap:8px; font-size:12px; color:#92400E; cursor:pointer;" onclick="window.toggleOpenBetDetails('${detailsId}')">
                                    <div class="obi-top-left" style="display:flex; flex-direction:column;">
                                        <span class="obi-time" style="line-height:1.2;">${disp}</span>
                                        <span class="obi-match" style="font-size:12px; color:#111827; line-height:1.2;">${headerMatchStr}</span>
                                    </div>
                                    <div class="obi-top-right" style="display:flex; align-items:center; gap:8px; color:#111827;">
                                        ${isSingle ? `<span class=\"obi-market\" style=\"background:#FEF3C7; color:#92400E; padding:2px 6px; border-radius:12px;\">${headerMarketLabel}</span>` : `<span class=\"obi-market\" style=\"background:#FEF3C7; color:#92400E; padding:2px 6px; border-radius:12px;\">Kombi</span>`}
                                        ${isSingle ? `<span class=\"obi-type\" style=\"background:#FFF7ED; color:#7C2D12; padding:2px 6px; border-radius:12px;\">${headerSelectionLabel}</span>` : ''}
                                        <span class="obi-odds">@ ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                        <span class="obi-caret" data-caret-for="${detailsId}" style="display:inline-block; transition:transform 0.2s;">⌄</span>
                                    </div>
                                </div>
                                <div id="${detailsId}" class="obi-details" style="display:none; margin:8px 0 0 0; padding-top:6px; border-top:1px dashed #FCD34D;">
                                    <div style="font-size:12px; color:#111827; display:flex; flex-direction:column; gap:4px;">
                                        ${isSingle ? '' : `<div style=\"color:#6b7280;\">${Array.isArray(s.bet_slip_items) ? s.bet_slip_items.length : 0} Auswahlen</div>`}
                                        ${itemsHtml}
                                    </div>
                                </div>
                                <div class="obi-bottom" style="display:flex; justify-content:space-between; font-size:12px; color:#111827; margin-top:8px;">
                                    <span>Einsatz: ${isNaN(stake) ? '-' : stake} • Quote: ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                    <span>Möglicher Gewinn: ${isNaN(potential) ? '-' : potential.toFixed(0)}</span>
                                </div>
                            </div>`;
                    } else if (item.source === 'node') {
                        const b = item.node;
                        const disp = b.placedAt ? new Date(b.placedAt).toLocaleString('de-DE') : '';
                        const stake = Number(b.stake || b.totalStake || 0);
                        const odds = Number(b.odds || b.totalOdds || 1);
                        const potential = Number(b.potentialWin ?? (stake * odds));
                        let matchStr = '';
                        try {
                            if (b.matchId && window.matchIndex && window.matchIndex[b.matchId]) {
                                const m = window.matchIndex[b.matchId];
                                matchStr = `${m.homeTeam || ''} vs ${m.awayTeam || ''}`;
                            } else if (b.match) {
                                matchStr = String(b.match);
                            }
                        } catch (_) { /* ignore */ }
                        if (!matchStr) {
                            try {
                                if (b.matchId) {
                                    matchStr = String(b.matchId).replace(/-/g, ' vs ');
                                }
                            } catch (_) { /* ignore */ }
                        }
                        const marketLabel = displayMarketLabel(b.market);
                        const selectionLabel = selectionLabelFromCode(b.selection);
                        const detailsId = `obd-node-${idx}`;
                        const canRebet = b.market && b.market !== 'combi' && b.matchId && b.selection;
                        return `
                            <div class="open-bet-card" style="border:1px solid #FDE68A; border-radius:10px; padding:10px; margin:8px 0; background:#FFFBEB;">
                                <div class="obi-top" style="display:flex; justify-content:space-between; align-items:center; gap:8px; font-size:12px; color:#92400E; cursor:pointer;" onclick="window.toggleOpenBetDetails('${detailsId}')">
                                    <div class="obi-top-left" style="display:flex; flex-direction:column;">
                                        <span class="obi-time" style="line-height:1.2;">${disp}</span>
                                        <span class="obi-match" style="font-size:12px; color:#111827; line-height:1.2;">${matchStr}</span>
                                    </div>
                                    <div class="obi-top-right" style="display:flex; align-items:center; gap:8px; color:#111827;">
                                        <span class="obi-market" style="background:#FEF3C7; color:#92400E; padding:2px 6px; border-radius:12px;">${marketLabel}</span>
                                        <span class="obi-type" style="background:#FFF7ED; color:#7C2D12; padding:2px 6px; border-radius:12px;">${selectionLabel}</span>
                                        <span class="obi-odds">@ ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                        <span class="obi-caret" data-caret-for="${detailsId}" style="display:inline-block; transition:transform 0.2s;">⌄</span>
                                    </div>
                                </div>
                                <div id="${detailsId}" class="obi-details" style="display:none; margin:8px 0 0 0; padding-top:6px; border-top:1px dashed #FCD34D;">
                                    <div style="font-size:12px; color:#111827; display:flex; flex-direction:column; gap:4px;">
                                        <div><strong>Markt:</strong> ${marketLabel}</div>
                                        <div><strong>Auswahl:</strong> ${selectionLabel}</div>
                                        <div><strong>Quote:</strong> ${isNaN(odds) ? '-' : odds.toFixed(2)}</div>
                                        ${b.matchId ? `<div style="color:#6b7280;">Match-ID: ${b.matchId}</div>` : ''}
                                        ${canRebet ? `<div style="margin-top:6px;"><button class="rebet-btn" style="background:#F59E0B; color:#111827; border:none; border-radius:8px; padding:6px 10px; cursor:pointer;" onclick="event.stopPropagation(); window.rebetFromOpen('${String(b.matchId).replace(/'/g, "&#39;")}', '${matchStr.replace(/'/g, "&#39;")}', '${String(b.selection).replace(/'/g, "&#39;")}', ${isNaN(odds) ? 1 : odds.toFixed(2)})">Wette erneut</button></div>` : ''}
                                        ${(window.IS_ADMIN && String(b.status || 'pending').toLowerCase() === 'pending') ? `<div class="admin-controls" style="margin-top:6px; display:flex; gap:6px;"><button class="settle-win-btn" style="background:#10B981; color:white; border:none; border-radius:8px; padding:6px 10px; cursor:pointer;" onclick="event.stopPropagation(); window.settleBet('${String(b.id).replace(/'/g, "&#39;")}', 'won')">Gewonnen</button><button class="settle-lose-btn" style="background:#EF4444; color:white; border:none; border-radius:8px; padding:6px 10px; cursor:pointer;" onclick="event.stopPropagation(); window.settleBet('${String(b.id).replace(/'/g, "&#39;")}', 'lost')">Verloren</button></div>` : ''}
                                    </div>
                                </div>
                                <div class="obi-bottom" style="display:flex; justify-content:space-between; font-size:12px; color:#111827; margin-top:8px;">
                                    <span>Einsatz: ${isNaN(stake) ? '-' : stake} • Quote: ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                    <span>Möglicher Gewinn: ${isNaN(potential) ? '-' : potential.toFixed(0)}</span>
                                </div>
                            </div>`;
                    } else {
                        const l = item.local;
                        const disp = l.displayTime || (l.timestamp ? new Date(l.timestamp).toLocaleString('de-DE') : '');
                        const stake = Number(l.totalStake || 0);
                        const odds = Number(l.totalOdds || l.combiOdds || 1);
                        const potential = Number(l.potentialWin ?? (stake * odds));
                        const detailsId = `obd-local-${idx}`;
                        const isSingle = Array.isArray(l.bets) && l.bets.length === 1;
                        let headerMatchStr = '';
                        let headerMarketLabel = '';
                        let headerSelectionLabel = '';
                        if (isSingle) {
                            const first = l.bets[0] || {};
                            headerMatchStr = String(first.match || '');
                            const c = String(first.selection || '').toLowerCase();
                            const market = (['1', 'x', '2', 'home', 'draw', 'away'].includes(c) ? 'match_result'
                                : (['1x', '12', 'x2'].includes(c) ? 'double_chance'
                                : (['over', 'under'].includes(c) ? 'total_goals'
                                : (['yes', 'no'].includes(c) ? 'btts' : ''))));
                            headerMarketLabel = displayMarketLabel(market);
                            headerSelectionLabel = selectionLabelFromCode(first.selection);
                        } else {
                            const cnt = Array.isArray(l.bets) ? l.bets.length : 0;
                            headerMatchStr = `Kombi (${cnt})`;
                        }
                        const lines = Array.isArray(l.bets) ? l.bets.map(b => {
                            const o = Number(b.odds || 1);
                            const matchName = String(b.match || '');
                            let mid = '';
                            try {
                                if (window.matchIndex && typeof window.matchIndex === 'object') {
                                    for (const [id, m] of Object.entries(window.matchIndex)) {
                                        const name = `${m.homeTeam || ''} vs ${m.awayTeam || ''}`.trim();
                                        if (name === matchName.trim()) { mid = id; break; }
                                    }
                                }
                            } catch (_) { /* ignore */ }
                            const selLabel = selectionLabelFromCode(b.selection);
                            const canRebet = !!(mid && b.selection);
                            return `
                                <div class="obi-line" style="display:flex; align-items:center; justify-content:space-between; gap:8px; margin:2px 0;">
                                    <div class="obi-match" style="font-size:12px; color:#111827;">${matchName}</div>
                                    <div class="obi-right" style="display:flex; align-items:center; gap:6px; font-size:12px; color:#111827;">
                                        <span class="obi-type" style="background:#FEF3C7; color:#92400E; padding:2px 6px; border-radius:12px;">${selLabel}</span>
                                        <span class="obi-odds">@ ${isNaN(o) ? '-' : o.toFixed(2)}</span>
                                        ${mid ? `<span style=\"color:#6b7280;\">Match-ID: ${String(mid)}</span>` : ''}
                                        ${canRebet ? `<button class="rebet-btn" style="background:#F59E0B; color:#111827; border:none; border-radius:8px; padding:4px 8px; cursor:pointer;" onclick="event.stopPropagation(); window.rebetFromOpen('${String(mid).replace(/'/g, '&#39;')}', '${matchName.replace(/'/g, '&#39;')}', '${String(b.selection).replace(/'/g, "&#39;")}', ${isNaN(o) ? 1 : o.toFixed(2)})">Wette erneut</button>` : ''}
                                    </div>
                                </div>`;
                        }).join('') : '';
                        return `
                            <div class="open-bet-card" style="border:1px solid #FDE68A; border-radius:10px; padding:10px; margin:8px 0; background:#FFFBEB;">
                                <div class="obi-top" style="display:flex; justify-content:space-between; align-items:center; gap:8px; font-size:12px; color:#92400E; cursor:pointer;" onclick="window.toggleOpenBetDetails('${detailsId}')">
                                    <div class="obi-top-left" style="display:flex; flex-direction:column;">
                                        <span class="obi-time" style="line-height:1.2;">${disp}</span>
                                        <span class="obi-match" style="font-size:12px; color:#111827; line-height:1.2;">${headerMatchStr}</span>
                                    </div>
                                    <div class="obi-top-right" style="display:flex; align-items:center; gap:8px; color:#111827;">
                                        ${isSingle ? `<span class=\"obi-market\" style=\"background:#FEF3C7; color:#92400E; padding:2px 6px; border-radius:12px;\">${headerMarketLabel}</span>` : `<span class=\"obi-market\" style=\"background:#FEF3C7; color:#92400E; padding:2px 6px; border-radius:12px;\">Kombi</span>`}
                                        ${isSingle ? `<span class=\"obi-type\" style=\"background:#FFF7ED; color:#7C2D12; padding:2px 6px; border-radius:12px;\">${headerSelectionLabel}</span>` : ''}
                                        <span class="obi-odds">@ ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                        <span class="obi-caret" data-caret-for="${detailsId}" style="display:inline-block; transition:transform 0.2s;">⌄</span>
                                    </div>
                                </div>
                                <div id="${detailsId}" class="obi-details" style="display:none; margin:8px 0 0 0; padding-top:6px; border-top:1px dashed #FCD34D;">
                                    <div style="font-size:12px; color:#111827; display:flex; flex-direction:column; gap:4px;">
                                        ${isSingle ? '' : `<div style=\"color:#6b7280;\">${Array.isArray(l.bets) ? l.bets.length : 0} Auswahlen</div>`}
                                        ${lines}
                                    </div>
                                </div>
                                <div class="obi-bottom" style="display:flex; justify-content:space-between; font-size:12px; color:#111827; margin-top:8px;">
                                    <span>Einsatz: ${isNaN(stake) ? '-' : stake} • Quote: ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                    <span>Möglicher Gewinn: ${isNaN(potential) ? '-' : potential.toFixed(0)}</span>
                                </div>
                            </div>`;
                    }
                }).join('');

                // Update MEINE WETTEN badge count with current open entries length
                try { if (typeof window.setMeineWettenCountBadge === 'function') window.setMeineWettenCountBadge(entries.length); } catch (_) {}

                wrap.innerHTML = `<div class="open-bets-list">${html}</div>`;
                try { window._openBetsCache = { ts: Date.now(), html: wrap.innerHTML, count: entries.length }; localStorage.setItem('open_bets_cache', JSON.stringify(window._openBetsCache)); } catch (_) {}
                try { if (typeof window.updateOpenBetsLastUpdated === 'function') window.updateOpenBetsLastUpdated(window._openBetsCache && window._openBetsCache.ts ? window._openBetsCache.ts : Date.now()); } catch (_) {}
            } catch (e) {
                wrap.innerHTML = '<div style="padding:16px; color:#b91c1c;">Fehler beim Laden der offenen Wetten.</div>';
            } finally {
                try { if (wrap) wrap.removeAttribute('data-loading'); } catch (_) {}
                try { if (typeof window.setOpenBetsLoading === 'function') window.setOpenBetsLoading(false); } catch (_) {}
                window._openBetsLoading = false;
            }
        }

        // Expose a global to clear the cached Open Bets (in-memory + persisted)
        window.clearOpenBetsCache = function() {
            try { window._openBetsCache = null; } catch (_) {}
            try { localStorage.removeItem('open_bets_cache'); } catch (_) {}
        }

        // If another tab clears the cache via diagnostics, drop our in-memory copy
        try {
            window.addEventListener('storage', (e) => {
                try {
                    if (e && e.key === 'open_bets_cache' && e.newValue === null) {
                        window._openBetsCache = null;
                    }
                } catch (_) { /* ignore */ }
            });
        } catch (_) { /* ignore */ }

        // Update the MEINE WETTEN count badge next to the chip
        window.setMeineWettenCountBadge = function(count) {
            try {
                const el = document.getElementById('meine-wetten-count-badge');
                if (!el) return;
                const v = Math.max(0, Number(count) || 0);
                if (v > 0) {
                    el.textContent = (v > 99) ? '99+' : String(v);
                    el.style.display = 'inline-block';
                } else {
                    el.textContent = '0';
                    el.style.display = 'none';
                }
            } catch (_) { /* ignore */ }
        }

        // Lightweight count refresh for open bets (Supabase -> Node -> local fallback)
        window.refreshOpenBetsCountBadge = async function() {
            // 1) Supabase exact count if available
            try {
                if (typeof supabaseClient !== 'undefined' && supabaseClient && supabaseClient.auth) {
                    const { data: { user } } = await supabaseClient.auth.getUser();
                    if (user) {
                        const { data, error, count } = await supabaseClient
                            .from('bet_slips')
                            .select('id', { count: 'exact' })
                            .eq('user_id', user.id)
                            .in('status', ['pending','Pending']);
                        if (!error) {
                            const c = (typeof count === 'number') ? count : (Array.isArray(data) ? data.length : 0);
                            if (typeof window.setMeineWettenCountBadge === 'function') window.setMeineWettenCountBadge(c);
                            return;
                        }
                    }
                }
            } catch (_) { /* ignore */ }
            // 2) Node API
            try {
                if (typeof API_BASE !== 'undefined' && currentUser && currentUser.id) {
                    const res = await fetch(`${API_BASE}/api/bets/user/${currentUser.id}`);
                    if (res.ok) {
                        const data = await res.json();
                        const list = (data && Array.isArray(data.bets)) ? data.bets : (Array.isArray(data) ? data : []);
                        const pending = list.filter(b => {
                            const st = String(b.status || 'pending').toLowerCase();
                            return st === 'pending' || st === 'open';
                        });
                        if (typeof window.setMeineWettenCountBadge === 'function') window.setMeineWettenCountBadge(pending.length);
                        return;
                    }
                }
            } catch (_) { /* ignore */ }
            // 3) localStorage fallback
            try {
                const placedBets = JSON.parse(localStorage.getItem('placedBets') || '[]');
                const pending = (Array.isArray(placedBets) ? placedBets : []).filter(b => String(b.status || '').toLowerCase() === 'pending');
                if (typeof window.setMeineWettenCountBadge === 'function') window.setMeineWettenCountBadge(pending.length);
            } catch (_) {
                if (typeof window.setMeineWettenCountBadge === 'function') window.setMeineWettenCountBadge(0);
            }
        }

        // New function to set quick stake for all single bets
        window.setQuickStake = function(amount) {
            // remember selection for highlight
            window.selectedSinglesQuickStake = amount;
            const idx = (Number.isInteger(window.focusedStakeIndex)) ? window.focusedStakeIndex : null;
            // Update quick-stake button highlights
            const singlesQS = document.getElementById('singles-quick-stakes');
            if (singlesQS) {
                singlesQS.querySelectorAll('.stake-btn').forEach(btn => {
                    btn.classList.remove('active');
                    btn.setAttribute('aria-pressed', 'false');
                    const label = btn.textContent.trim();
                    if ((Number(label) === amount) || (label === 'MAX' && amount === 'MAX')) {
                        btn.classList.add('active');
                        btn.setAttribute('aria-pressed', 'true');
                    }
                });
            }
            // Determine application scope: when multiple singles are selected, always apply to all
            const hasSingles = Array.isArray(window.betSlip) && window.betSlip.length > 0;
            const applyToAll = hasSingles && window.betSlip.length > 1;
            if (!hasSingles) return;

            if (applyToAll) {
                // Apply to all single bets and re-render slip
                window.betSlip.forEach((bet) => { bet.stake = amount; });
                updateBetSlip();
                // Smart focus restore to previously focused single, if any
                const targetIdx = window._preQSFocusedIndex;
                const shouldFocusBack = (window.autoRefocusMode === 'always') || (window.autoRefocusMode === 'smart' && window._preQSFocused);
                if (Number.isInteger(targetIdx) && shouldFocusBack) {
                    setTimeout(() => {
                        const input = document.getElementById('stake-' + targetIdx);
                        if (input) {
                            input.focus();
                            if (input.type && input.type !== 'number') {
                                const end = input.value.length;
                                try { if (input.setSelectionRange) input.setSelectionRange(end, end); } catch (_) {}
                            }
                        }
                    }, 50);
                }
            } else if (idx !== null) {
                // Only one single present or explicit row focus: apply to that single without full re-render
                const input = document.getElementById('stake-' + idx);
                if (input) { input.value = String(amount); }
                updateStake(idx, amount, false);
                // Optional focus keep
                const shouldFocusBack = (window.autoRefocusMode === 'always') || (window.autoRefocusMode === 'smart' && window._preQSFocused);
                if (shouldFocusBack && input) {
                    setTimeout(() => {
                        input.focus();
                        if (input.type && input.type !== 'number') {
                            const end = input.value.length;
                            try { if (input.setSelectionRange) input.setSelectionRange(end, end); } catch (_) {}
                        }
                    }, 0);
                }
            } else {
                // Single bet but no explicit focus: set it via re-render for consistency
                window.betSlip.forEach((bet) => { bet.stake = amount; });
                updateBetSlip();
                const targetIdx = 0;
                const shouldFocusBack = (window.autoRefocusMode === 'always') || (window.autoRefocusMode === 'smart' && window._preQSFocused);
                if (shouldFocusBack) {
                    setTimeout(() => {
                        const input = document.getElementById('stake-' + targetIdx);
                        if (input) {
                            input.focus();
                            if (input.type && input.type !== 'number') {
                                const end = input.value.length;
                                try { if (input.setSelectionRange) input.setSelectionRange(end, end); } catch (_) {}
                            }
                        }
                    }, 50);
                }
            }
            // cleanup flags similar to MAX path
            setTimeout(() => { window._qsClicking = false; window._preQSFocused = false; window._preQSFocusedIndex = null; }, 0);
        }

        // Set MAX stake for single bets: allocate remaining balance
        window.setMaxStake = function() {
            if (!Array.isArray(window.betSlip) || window.betSlip.length === 0) return;
            window.selectedSinglesQuickStake = 'MAX';

            const balance = (typeof window.getCurrentCoins === 'function') ? window.getCurrentCoins() : Number(window.coins || 0);
            const combiActive = (window.betSlip.length > 1) ? (Number(window.combiStake) || 0) : 0;

            const idx = (Number.isInteger(window.focusedStakeIndex)) ? window.focusedStakeIndex : null;
            // Update quick-stake button highlights
            const singlesQS = document.getElementById('singles-quick-stakes');
            if (singlesQS) {
                singlesQS.querySelectorAll('.stake-btn').forEach(btn => {
                    const label = btn.textContent.trim();
                    const isActive = (label === 'MAX');
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });
            }

            if (idx !== null) {
                // Focused single: give it all remaining after other singles + combi
                const otherSum = window.betSlip.reduce((t, b, i) => t + (i === idx ? 0 : (Number(b.stake) || 0)), 0);
                const remaining = Math.max(0, Math.floor(balance - combiActive - otherSum));
                const input = document.getElementById('stake-' + idx);
                if (input) { input.value = String(remaining); }
                updateStake(idx, remaining, false);
                // Smart focus restore
                const shouldFocusBack = (window.autoRefocusMode === 'always') || (window.autoRefocusMode === 'smart' && window._preQSFocused);
                if (shouldFocusBack && input) {
                    setTimeout(() => {
                        input.focus();
                        if (input.type && input.type !== 'number') {
                            const end = input.value.length;
                            try { if (input.setSelectionRange) input.setSelectionRange(end, end); } catch (_) {}
                        }
                    }, 0);
                }
            } else {
                // No focused row: distribute equally across all singles
                const singlesCount = window.betSlip.length;
                const remaining = Math.max(0, Math.floor(balance - combiActive));
                const base = Math.floor(remaining / singlesCount);
                const extra = remaining % singlesCount;
                window.betSlip.forEach((bet, i) => {
                    bet.stake = base + (i < extra ? 1 : 0);
                });
                updateBetSlip();
                // Optional focus restore to previously focused index
                const targetIdx = window._preQSFocusedIndex;
                if (Number.isInteger(targetIdx)) {
                    setTimeout(() => {
                        const input = document.getElementById('stake-' + targetIdx);
                        if (input) {
                            input.focus();
                            if (input.type && input.type !== 'number') {
                                const end = input.value.length;
                                try { if (input.setSelectionRange) input.setSelectionRange(end, end); } catch (_) {}
                            }
                        }
                    }, 50);
                }
            }
            // cleanup flags
            setTimeout(() => { window._qsClicking = false; window._preQSFocused = false; window._preQSFocusedIndex = null; }, 0);
        }

        // Quick-set combo stake from preset chips, respecting remaining coins
        window.setCombiQuickStake = function(amount) {
            if (amount === 'MAX') {
                return window.setCombiMaxStake && window.setCombiMaxStake();
            }
            window.selectedCombiQuickStake = amount;
            const totalSinglesStake = (window.betSlip || []).reduce((t, b) => t + (Number(b.stake) || 0), 0);
            const balance = (typeof window.getCurrentCoins === 'function') ? window.getCurrentCoins() : Number(window.coins || 0);
            const remaining = Math.max(0, balance - totalSinglesStake);
            const v = Math.max(0, Math.min(remaining, Math.floor(Number(amount) || 0)));
            window.combiStake = v;
            // Update input value
            const input = document.getElementById('combo-stake');
            if (input) { input.value = String(v); }
            // Update quick-stake highlights
            const comboQS = document.getElementById('combo-quick-stakes');
            if (comboQS) {
                comboQS.querySelectorAll('.stake-btn').forEach(btn => {
                    const label = btn.textContent.trim();
                    const isActive = (Number(label) === Number(amount));
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-pressed', isActive ? 'true' : 'false');
                });
            }
            updateTotalsAndComboPotential();
            // Smart focus restore for combo input
            const shouldFocusBack = (window.autoRefocusMode === 'always') || (window.autoRefocusMode === 'smart' && window._preComboFocused);
            if (shouldFocusBack && input) {
                setTimeout(() => {
                    input.focus();
                    if (input.type && input.type !== 'number') {
                        const end = input.value.length;
                        try { if (input.setSelectionRange) input.setSelectionRange(end, end); } catch (_) {}
                    }
                }, 0);
            }
        }

        window.setBettingMode = function(mode) {
            currentBettingMode = mode;
            updateBetSlip();
        }

        // Smart focus mode: 'smart' | 'always' | 'never'
        window.autoRefocusMode = window.autoRefocusMode || 'smart';

        // Capture pre-click focus state for singles quick-stake buttons
        window._captureSinglesQuickFocus = function() {
            window._qsClicking = true; // prevent blur clearing
            const ae = document.activeElement;
            const isStakeInput = !!(ae && ae.classList && ae.classList.contains('stake-input'));
            window._preQSFocused = isStakeInput;
            window._preQSFocusedIndex = isStakeInput ? window.focusedStakeIndex : null;
        }

        // Capture pre-click focus state for combo quick-stake buttons
        window._captureComboQuickFocus = function() {
            const comboEl = document.getElementById('combo-stake');
            window._preComboFocused = (document.activeElement === comboEl);
        }

        // Capture pre-click row focus to handle toggle-off reliably (blur may fire before click)
        window._captureRowFocus = function(index) {
            window._rowWasFocused = (window.focusedStakeIndex === index);
        }

        // Recalculate and update totals and combo potential without re-rendering
        function updateTotalsAndComboPotential() {
            try {
                const combiOdds = window.betSlip.reduce((total, bet) => total * (Number(bet.odds) || 1), 1);
                const totalSinglesStake = window.betSlip.reduce((total, bet) => total + (Number(bet.stake) || 0), 0);
                const combiStakeActive = window.betSlip.length > 1 ? (Number(window.combiStake) || 0) : 0;
                const totalStake = totalSinglesStake + combiStakeActive;
                const singlesWin = window.betSlip.reduce((total, bet) => total + ((Number(bet.stake) || 0) * (Number(bet.odds) || 0)), 0);
                const combiWin = window.betSlip.length > 1 ? (combiStakeActive * combiOdds) : 0;
                const totalPotential = singlesWin + combiWin;

                // Update place bet button and totals
                const placeBtn = document.getElementById('place-bet-btn');
                const placeBtnCoins = document.getElementById('place-bet-total-coins');
                if (placeBtnCoins) placeBtnCoins.textContent = totalStake.toFixed(0);
                if (placeBtn) {
                    const balance = (typeof window.getCurrentCoins === 'function') ? window.getCurrentCoins() : Number(window.coins || 0);
                    const overBudget = totalStake > balance;
                    if (totalStake === 0 || overBudget) {
                        placeBtn.setAttribute('disabled', '');
                    } else {
                        placeBtn.removeAttribute('disabled');
                    }
                }
                const totalStakeEl = document.getElementById('total-stake-coins');
                if (totalStakeEl) {
                    totalStakeEl.textContent = totalStake.toFixed(0);
                    const balance = (typeof window.getCurrentCoins === 'function') ? window.getCurrentCoins() : Number(window.coins || 0);
                    totalStakeEl.style.color = (totalStake > balance) ? '#b91c1c' : '';
                }
                const totalPotentialEl = document.getElementById('total-potential-coins');
                if (totalPotentialEl) totalPotentialEl.textContent = totalPotential.toFixed(0);

                // Update combo potential if visible
                const comboPotEl = document.getElementById('combo-potential-amount');
                if (comboPotEl) {
                    const combiStake = Number(window.combiStake) || 0;
                    comboPotEl.textContent = (combiStake * combiOdds).toFixed(2);
                }
                // Also update sticky mobile bet bar with fresh totals
                if (typeof updateBetBar === 'function') updateBetBar();
            } catch (e) {
                console.warn('updateTotalsAndComboPotential error', e);
            }
        }

        window.updateStake = function(index, newStake, isManual) {
            // Clamp stake to non-negative integer
            let v = Math.floor(Number(newStake));
            if (isNaN(v) || v < 0) v = 0;
            window.betSlip[index].stake = v;
            // Reflect clamped value in the input if needed
            const inputEl = document.getElementById('stake-' + index);
            if (inputEl && String(inputEl.value) !== String(v)) {
                inputEl.value = String(v);
            }
            // If user typed manually, clear quick stake highlight visually
            if (isManual) {
                window.selectedSinglesQuickStake = null;
                const singlesQS = document.getElementById('singles-quick-stakes');
                if (singlesQS) {
                    singlesQS.querySelectorAll('.stake-btn.active').forEach(btn => {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-pressed', 'false');
                    });
                }
            }
            // Update this row's potential win text
            const potEl = document.getElementById('potential-win-' + index);
            if (potEl) {
                const bet = window.betSlip[index];
                const amount = (Number(bet.stake) || 0) * (Number(bet.odds) || 0);
                potEl.textContent = 'Gewinn: ' + amount.toFixed(2) + ' coins';
            }
            // Update totals (and combo potential if present)
            updateTotalsAndComboPotential();
        }
        
        // Helper function to show more betting options
        function showBetOptions() {
            alert('Additional betting options coming soon!');
        }
        
        // Helper function to show more bet types
        function showMoreBets() {
            alert('System bets and other combinations coming soon!');
        }
        
        // Update all single bet stakes at once
        function updateAllSinglesStake(stake) {
            const stakeValue = parseInt(stake) || 10;
            window.betSlip.forEach(bet => {
                bet.stake = stakeValue;
            });
            updateBetSlip();
        }
        
        // Update combination stake
        window.updateCombiStake = function(stake, isManual) {
            // Clamp to non-negative integer (allow 0 for singles-only setups)
            let v = Math.floor(Number(stake));
            if (isNaN(v) || v < 0) v = 0;
            window.combiStake = v;
            // Reflect clamped value in the combo input if present
            const comboInput = document.getElementById('combo-stake');
            if (comboInput && String(comboInput.value) !== String(v)) {
                comboInput.value = String(v);
            }
            if (isManual) {
                window.selectedCombiQuickStake = null;
                const comboQS = document.getElementById('combo-quick-stakes');
                if (comboQS) {
                    comboQS.querySelectorAll('.stake-btn.active').forEach(btn => {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-pressed', 'false');
                    });
                }
            }
            updateTotalsAndComboPotential();
        }

        // Offline placement + coin helpers
        window.getCurrentCoins = function() {
            const span = document.getElementById('coins');
            const val = span ? Number(span.textContent) : Number(window.coins || 0);
            const n = isNaN(val) ? 0 : Math.max(0, Math.floor(val));
            // keep window.coins in sync
            window.coins = n;
            return n;
        }

        window.setCurrentCoins = function(amount) {
            const n = Math.max(0, Math.floor(Number(amount) || 0));
            window.coins = n;
            const span = document.getElementById('coins');
            if (span) span.textContent = String(n);
            const spanProfile = document.getElementById('profile-coins');
            if (spanProfile) spanProfile.textContent = String(n);
            const spanRanking = document.getElementById('coins-ranking');
            if (spanRanking) spanRanking.textContent = String(n);
            if (typeof updateBetBar === 'function') updateBetBar();
        }

        // Focus helpers for singles stake UX
        function updateQuickStakeLabel() {
            const label = document.getElementById('singles-quick-stake-label');
            if (label) {
                const singlesCountForLabel = Array.isArray(window.betSlip) ? window.betSlip.length : 0;
                label.textContent = (singlesCountForLabel > 1)
                    ? 'Schnelleinsatz: Alle Wetten'
                    : 'Schnelleinsatz: Diese Wette';
            }
        }
        window.setFocusedStakeIndex = function(index) {
            window.focusedStakeIndex = index;
            // Apply visual focus to this row and remove from others
            try {
                document.querySelectorAll('.bet-item.row-focused').forEach(el => el.classList.remove('row-focused'));
                const inputEl = document.getElementById('stake-' + index);
                const row = inputEl && inputEl.closest ? inputEl.closest('.bet-item') : null;
                if (row) row.classList.add('row-focused');
            } catch (e) { /* noop */ }
            updateQuickStakeLabel();
        }
        window.clearFocusedStakeIndex = function(index) {
            if (window._qsClicking) { return; }
            if (window.focusedStakeIndex === index) {
                window.focusedStakeIndex = null;
                // Remove visual focus from this row
                try {
                    const inputEl = document.getElementById('stake-' + index);
                    const row = inputEl && inputEl.closest ? inputEl.closest('.bet-item') : null;
                    if (row) row.classList.remove('row-focused');
                } catch (e) { /* noop */ }
                updateQuickStakeLabel();
            }
        }
        window.focusStakeInput = function(index, evt) {
            const target = evt && evt.target;
            // Treat only direct clicks on the input as "input clicks"; clicking the wrapper should toggle
            const clickedInput = !!(target && target.closest && target.closest('.stake-input'));
            // Use pre-captured state because input blur may clear focusedStakeIndex before click runs
            const wasFocused = (window._rowWasFocused !== undefined)
                ? !!window._rowWasFocused
                : (window.focusedStakeIndex === index);
            window._rowWasFocused = false;

            // If clicking inside the input area, just ensure focus index is set and label is correct
            if (clickedInput) {
                window.focusedStakeIndex = index;
                // Ensure visual focus
                try {
                    document.querySelectorAll('.bet-item.row-focused').forEach(el => el.classList.remove('row-focused'));
                    const inputEl = document.getElementById('stake-' + index);
                    const row = inputEl && inputEl.closest ? inputEl.closest('.bet-item') : null;
                    if (row) row.classList.add('row-focused');
                } catch (e) { /* noop */ }
                updateQuickStakeLabel();
                return;
            }

            // Toggle off when clicking the same row again (outside the input)
            if (wasFocused) {
                if (evt) { try { evt.preventDefault(); evt.stopPropagation(); } catch (e) {} }
                const el = document.getElementById('stake-' + index);
                if (el) { el.blur(); }
                // Fallback: if any other element inside the row has focus, blur it too
                try {
                    const rowEl = target && target.closest && target.closest('.bet-item');
                    if (rowEl && document.activeElement && rowEl.contains(document.activeElement)) {
                        document.activeElement.blur();
                    }
                    // Remove visual focus class
                    if (rowEl) rowEl.classList.remove('row-focused');
                } catch (e) { /* noop */ }
                window.focusedStakeIndex = null;
                updateQuickStakeLabel();
                return;
            }

            // Otherwise, focus this single
            window.focusedStakeIndex = index;
            setTimeout(() => {
                const el = document.getElementById('stake-' + index);
                if (el) {
                    el.focus();
                    if (el.type && el.type !== 'number') {
                        try { if (el.select) el.select(); } catch (_) {}
                    }
                }
                // Ensure only this row has visual focus
                try {
                    document.querySelectorAll('.bet-item.row-focused').forEach(el2 => el2.classList.remove('row-focused'));
                    const row = el && el.closest ? el.closest('.bet-item') : null;
                    if (row) row.classList.add('row-focused');
                } catch (e) { /* noop */ }
                updateQuickStakeLabel();
            }, 0);
        }

        // Unfocus when tapping/clicking outside of any bet row or stake inputs within the bet slip
        function setupBetSlipOutsideUnfocus() {
            try {
                const cont = document.getElementById('bet-slip-content');
                if (!cont || cont._outsideUnfocusBound) return;
                const handler = function(evt) {
                    const t = evt && evt.target;
                    if (!t) return;
                    // Do not clear focus if clicking inside a bet row, stake inputs, or quick-stake areas
                    if (t.closest && (
                        t.closest('.bet-item') ||
                        t.closest('#singles-quick-stakes') ||
                        t.closest('#combo-quick-stakes') ||
                        t.closest('.stake-input') ||
                        t.closest('#combo-stake')
                    )) {
                        return;
                    }
                    if (window.focusedStakeIndex !== undefined && window.focusedStakeIndex !== null) {
                        try {
                            document.querySelectorAll('.bet-item.row-focused').forEach(el => el.classList.remove('row-focused'));
                        } catch (e) { /* noop */ }
                        window.focusedStakeIndex = null;
                        updateQuickStakeLabel();
                    }
                };
                cont.addEventListener('mousedown', handler, true);
                cont.addEventListener('touchstart', handler, true);
                cont._outsideUnfocusBound = true;

                // Bind a single document-level ESC handler to clear focused row without deleting it
                if (!window._escUnfocusBound) {
                    const escHandler = function(e) {
                        const key = e && (e.key || e.code);
                        if (key === 'Escape' || key === 'Esc' || (e && e.keyCode === 27)) {
                            if (window.focusedStakeIndex !== undefined && window.focusedStakeIndex !== null) {
                                try { e.preventDefault(); e.stopPropagation(); } catch (_) {}
                                const idx = window.focusedStakeIndex;
                                try {
                                    const inputEl = document.getElementById('stake-' + idx);
                                    if (inputEl) inputEl.blur();
                                    document.querySelectorAll('.bet-item.row-focused').forEach(el => el.classList.remove('row-focused'));
                                } catch (_) { /* noop */ }
                                window.focusedStakeIndex = null;
                                updateQuickStakeLabel();
                            }
                        }
                    };
                    document.addEventListener('keydown', escHandler, true);
                    window._escUnfocusBound = true;
                }
                // Bind singles-only Tab/Shift+Tab cycling (no wrap-around)
                if (!window._singlesTabBound) {
                    const tabHandler = function(e) {
                        const isTab = e && ((e.key && e.key === 'Tab') || e.keyCode === 9);
                        if (!isTab) return;
                        const t = e.target;
                        if (!t || !t.id || typeof t.id !== 'string') return;
                        // Only intercept when focused element is a single's stake input (id="stake-<n>")
                        if (!t.id.startsWith('stake-')) return;
                        const cont2 = document.getElementById('bet-slip-content');
                        if (!cont2 || !cont2.contains(t)) return;
                        const singles = Array.from(cont2.querySelectorAll('.bet-item:not(.combi) input.stake-input'));
                        if (!singles.length) return;
                        const currentIndex = singles.indexOf(t);
                        if (currentIndex === -1) return;
                        const backwards = !!e.shiftKey;
                        if (backwards) {
                            if (currentIndex > 0) {
                                try { e.preventDefault(); e.stopPropagation(); } catch (_) {}
                                const prev = singles[currentIndex - 1];
                                if (prev && prev.focus) { 
                                    prev.focus(); 
                                    if (prev.type && prev.type !== 'number') { try { if (prev.select) prev.select(); } catch (_) {} }
                                }
                            } else {
                                // allow native to move before singles list
                            }
                        } else {
                            if (currentIndex < singles.length - 1) {
                                try { e.preventDefault(); e.stopPropagation(); } catch (_) {}
                                const next = singles[currentIndex + 1];
                                if (next && next.focus) { 
                                    next.focus(); 
                                    if (next.type && next.type !== 'number') { try { if (next.select) next.select(); } catch (_) {} }
                                }
                            } else {
                                // allow native to move after singles list (combo, CTA, etc.)
                            }
                        }
                    };
                    document.addEventListener('keydown', tabHandler, true);
                    window._singlesTabBound = true;
                }
            } catch (e) { /* noop */ }
        }

        window.removeBet = function(betId) {
            const betIndex = window.betSlip.findIndex(bet => bet.id === betId);
            if (betIndex > -1) {
                const removedBet = window.betSlip[betIndex];
                window.betSlip.splice(betIndex, 1);
                // Remove selected class from button
                document.querySelectorAll('.odds-button').forEach(btn => {
                    if (btn.getAttribute('onclick') && btn.getAttribute('onclick').includes(betId)) {
                        btn.classList.remove('selected');
                    }
                });
                updateBetSlip();
            }
        }

        window.clearBetSlip = function() {
            if (typeof window.clearAllBets === 'function') {
                window.clearAllBets();
            } else {
                window.betSlip = [];
                document.querySelectorAll('.odds-button.selected').forEach(btn => btn.classList.remove('selected'));
                window.selectedSinglesQuickStake = null;
                window.selectedCombiQuickStake = null;
                window.focusedStakeIndex = null;
                // Reset combination stake and its quick-stake UI state
                window.combiStake = 0;
                const comboQS = document.getElementById('combo-quick-stakes');
                if (comboQS) {
                    comboQS.querySelectorAll('.stake-btn').forEach(btn => {
                        btn.classList.remove('active');
                        btn.setAttribute('aria-pressed', 'false');
                    });
                }
                updateBetSlip();
            }
        }

        // Unified place bets wrapper (auto-routes to online or offline)
        window.placeBets = function() {
            try {
                const isOnlineUser = (typeof currentUser !== 'undefined') && currentUser && (typeof currentUser === 'object') && ('id' in currentUser) && (typeof currentUser.coins !== 'undefined');
                if (isOnlineMode && isOnlineUser && (typeof placeBetsMultiUser === 'function')) {
                    return placeBetsMultiUser();
                }
            } catch (e) {
                console.warn('placeBets online path failed, fallback to offline', e);
            }
            if (typeof window.placeBetsOffline === 'function') {
                return window.placeBetsOffline();
            }
        }

        // Simple, direct bet placement function
        window.placeBetsOffline = function() {
            try {
                console.log('=== PLACING BETS ===');
                // Keep existing placedBets history; do not clear
                
                // Check if we have bets
                if (!window.betSlip || window.betSlip.length === 0) {
                    alert('Bitte wählen Sie mindestens eine Wette aus!');
                    return;
                }

                // Calculate stakes
                const totalSinglesStake = window.betSlip.reduce((total, bet) => total + (bet.stake || 0), 0);
                const combiStake = (window.betSlip.length > 1 && window.combiStake) ? window.combiStake : 0;
                const totalStake = totalSinglesStake + combiStake;
                
                // Check if any bets configured
                if (totalStake === 0) {
                    alert('Bitte wählen Sie einen Einsatz für Ihre Wetten!');
                    return;
                }
                
                // Check coins
                const balance = (typeof window.getCurrentCoins === 'function') ? window.getCurrentCoins() : Number(window.coins || 0);
                if (totalStake > balance) {
                    alert('Nicht genügend Coins! Sie haben nur ' + balance + ' Coins.');
                    return;
                }

                // Build bet HTML with STRONG VISIBILITY
                let betHtml = '<div style="background: #4F46E5; color: white; padding: 15px; margin: 10px 0; border-radius: 10px; border: 3px solid #333; font-size: 16px; box-shadow: 0 4px 8px rgba(0,0,0,0.3);">';
                betHtml += '<strong style="font-size: 18px;">🎯 NEUE WETTE PLATZIERT!</strong><br>';
                betHtml += `<small style="color: #ccc;">Zeit: ${new Date().toLocaleString('de-DE')}</small><br><br>`;
                
                // Show single bets
                const singlesWithStake = window.betSlip.filter(bet => bet.stake > 0);
                if (singlesWithStake.length > 0) {
                    betHtml += '<strong>Einzelwetten:</strong><br>';
                    singlesWithStake.forEach(bet => {
                        betHtml += `• ${bet.selection} @ ${bet.odds.toFixed(2)} - Einsatz: ${bet.stake} coins<br>`;
                    });
                }
                
                // Show combination bet
                if (window.betSlip.length > 1 && combiStake > 0) {
                    const combiOdds = window.betSlip.reduce((total, bet) => total * bet.odds, 1);
                    betHtml += `<br><strong>Kombi-Wette (${window.betSlip.length}er):</strong><br>`;
                    betHtml += `Quote: ${combiOdds.toFixed(2)} - Einsatz: ${combiStake} coins<br>`;
                }
                
                betHtml += `<br><strong>Gesamt: ${totalStake} coins</strong>`;
                betHtml += '</div>';

                // Update coins (consistent helper)
                const coinsBefore = (typeof window.getCurrentCoins === 'function') ? window.getCurrentCoins() : Number(window.coins || 0);
                if (typeof window.setCurrentCoins === 'function') {
                    window.setCurrentCoins(coinsBefore - totalStake);
                } else {
                    window.coins = Math.max(0, Math.floor(coinsBefore - totalStake));
                    if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                }
                // Keep currentUser.coins in sync for consistency across modes
                try {
                    if (typeof currentUser === 'object' && currentUser) {
                        currentUser.coins = (typeof window.getCurrentCoins === 'function') ? window.getCurrentCoins() : Number(window.coins || 0);
                        localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser));
                    }
                } catch (_) { /* ignore */ }
                
                // Build an array of bet objects to save (one per single bet + optional combination)
                const newBetsToSave = [];

                // 1) Individual single bets
                singlesWithStake.forEach((single, idx) => {
                    newBetsToSave.push({
                        id: `${Date.now()}-${idx}`,
                        timestamp: new Date().toISOString(),
                        displayTime: new Date().toLocaleString('de-DE'),
                        totalStake: single.stake,
                        bets: [{
                            match: single.match,
                            selection: single.selection,
                            odds: single.odds,
                            stake: single.stake
                        }],
                        combiStake: 0,
                        combiOdds: 0,
                        totalOdds: single.odds,
                        status: 'Pending',
                        type: 'Single'
                    });
                });

                // 2) Combination bet (if any)
                if (window.betSlip.length > 1 && combiStake > 0) {
                    const combiOdds = window.betSlip.reduce((total, bet) => total * bet.odds, 1);
                    newBetsToSave.push({
                        id: `${Date.now()}-combo`,
                        timestamp: new Date().toISOString(),
                        displayTime: new Date().toLocaleString('de-DE'),
                        totalStake: combiStake,
                        bets: window.betSlip.map(bet => ({
                            match: bet.match,
                            selection: bet.selection,
                            odds: bet.odds,
                            stake: bet.stake || 0
                        })),
                        combiStake: combiStake,
                        combiOdds: combiOdds,
                        totalOdds: combiOdds,
                        status: 'Pending',
                        type: 'Combination'
                    });
                }

                // Retrieve existing bets, prepend new ones, and save back
                const existingBets = JSON.parse(localStorage.getItem('placedBets') || '[]');
                newBetsToSave.reverse().forEach(b => existingBets.unshift(b));
                localStorage.setItem('placedBets', JSON.stringify(existingBets));

                console.log('Bets saved to localStorage:', newBetsToSave);
                
                // Refresh "My Bets" section now that it is safe
                if (typeof updateMyBets === 'function') {
                    updateMyBets();
                    console.log('✅ My Bets section refreshed!');
                }
                console.log('✅ Bet saved successfully, My Bets update disabled for now');

                // If Open Bets tab is active, refresh it now
                try {
                    if (window.betslipViewMode === 'open' && typeof window.loadOpenBetsInline === 'function') {
                        window.loadOpenBetsInline();
                    }
                } catch (_) { /* ignore */ }

                // Add to my bets - WITH DEBUGGING
                const myBetsContainer = document.getElementById('my-bets-content');
                console.log('myBetsContainer found:', myBetsContainer);
                console.log('Current HTML before:', myBetsContainer ? myBetsContainer.innerHTML : 'ELEMENT NOT FOUND');
                
                if (myBetsContainer) {
                    // Clear the "no bets" message if present
                    if (myBetsContainer.innerHTML.includes('No bets')) {
                        console.log('Clearing "No bets" message');
                        myBetsContainer.innerHTML = '';
                    }
                    
                    // Add new bet at the top
                    console.log('Adding bet HTML:', betHtml);
                    myBetsContainer.innerHTML = betHtml + myBetsContainer.innerHTML;
                    
                    console.log('HTML after update:', myBetsContainer.innerHTML);
                    
                    // Force the tab to be visible if not already
                    const myBetsTab = document.getElementById('mybets-tab');
                    if (myBetsTab) {
                        // Keep My Bets hidden for MVP (league-only winnings focus)
                        myBetsTab.style.display = 'none';
                        console.log('Keeping mybets-tab hidden (MVP)');
                    }
                } else {
                    console.error('Could not find my-bets-content element!');
                    // Try alternative method
                    const alternativeContainer = document.querySelector('#my-bets-content, .my-bets-content, [data-tab="mybets"]');
                    console.log('Alternative search result:', alternativeContainer);
                }

                // Clear bet slip (use canonical function)
                if (typeof clearAllBets === 'function') {
                    clearAllBets();
                } else {
                    window.betSlip = [];
                    window.combiStake = 0;
                    document.querySelectorAll('.odds-button.selected').forEach(btn => btn.classList.remove('selected'));
                    if (typeof updateBetSlip === 'function') updateBetSlip();
                }

                // Auto-switch to Bet Slip Open view and refresh
                try {
                    showTab('betslip');
                    if (typeof window.setBetSlipView === 'function') {
                        window.setBetSlipView('open');
                    } else {
                        window.betslipViewMode = 'open';
                        if (typeof updateBetSlip === 'function') updateBetSlip();
                    }
                    // Immediately refresh Open Bets content
                    try { if (typeof window.loadOpenBetsInline === 'function') window.loadOpenBetsInline(); } catch (_) {}
                    // Smoothly scroll to the Open Bets section so the user sees their new bet immediately
                    setTimeout(() => {
                        try {
                            const wrap = document.getElementById('open-bets-inline');
                            if (wrap && wrap.scrollIntoView) wrap.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        } catch (_) {}
                    }, 100);
                } catch (_) {}

                // Success message
                alert(`✅ Wette erfolgreich platziert!\n💰 ${totalStake} Coins abgezogen`);
                
            } catch (error) {
                console.error('Error placing bet:', error);
                alert('Fehler beim Platzieren der Wette. Bitte versuchen Sie es erneut.');
            }
        }

        async function updateMyBets() {
            const myBetsContent = document.getElementById('my-bets-content');
            const onlineCapable = isOnlineMode && !!supabaseClient && !!currentUser;
            
            try {
                if (onlineCapable) {
                    // Fetch slips from Supabase
                    const { data: { user } } = await supabaseClient.auth.getUser();
                    if (!user) throw new Error('No auth user');
                    const { data: slips, error } = await supabaseClient
                        .from('bet_slips')
                        .select('*, bet_slip_items(*)')
                        .eq('user_id', user.id)
                        .order('placed_at', { ascending: false });
                    if (error) throw error;

                    if (!slips || !slips.length) {
                        // Fallback to local if no remote history yet
                        throw new Error('No remote bets');
                    }

                    let html = '<div class="my-bets-header">';
                    html += '<h3>📋 Your Betting History</h3>';
                    html += `<div class="bets-summary">${slips.length} bet${slips.length !== 1 ? 's' : ''} saved</div>`;
                    html += '</div>';
                    html += '<div class="bet-history-cards">';

                    slips.forEach((slip, index) => {
                        const statusRaw = String(slip.status || 'pending');
                        const statusClass = statusRaw.toLowerCase();
                        const statusUC = statusClass.charAt(0).toUpperCase() + statusClass.slice(1);
                        const statusIcon = { pending: '⏳', won: '✅', lost: '❌' }[statusClass] || '⏳';
                        const statusColor = { pending: '#f39c12', won: '#27ae60', lost: '#e74c3c' }[statusClass] || '#f39c12';
                        const stakeAmount = Number(slip.total_stake || 0);
                        const totalOdds = Number(slip.total_odds || 1);
                        const potentialWin = Number(slip.potential_win || Math.round(stakeAmount * totalOdds));
                        const placed = slip.placed_at ? new Date(slip.placed_at) : new Date();
                        const dateStr = placed.toLocaleString('de-DE');

                        html += `
                            <div class="professional-bet-card" style="animation-delay: ${index * 0.1}s">
                                <div class="bet-card-header">
                                    <div class="bet-card-title">
                                        <span class="bet-id">Slip #${slip.id}</span>
                                        <span class="bet-date">${dateStr}</span>
                                    </div>
                                    <div class="bet-status-badge" style="background: ${statusColor}">
                                        <span class="status-icon">${statusIcon}</span>
                                        <span class="status-text">${statusUC}</span>
                                    </div>
                                </div>
                                <div class="bet-card-content">
                                    <div class="bet-selections">
                                        ${Array.isArray(slip.bet_slip_items) ? slip.bet_slip_items.map(item => {
                                            const match = `${item.home_team} vs ${item.away_team}`;
                                            const type = String(item.bet_type || '').toLowerCase();
                                            const odds = Number(item.odds || 1);
                                            let selectionText = '';
                                            let marketTag = '';
                                            if (type === 'home' || type === 'draw' || type === 'away') {
                                                marketTag = '1X2';
                                                selectionText = type === 'home' ? `${item.home_team} Sieg` : (type === 'away' ? `${item.away_team} Sieg` : 'Unentschieden');
                                            } else if (type === '1x' || type === '12' || type === 'x2') {
                                                marketTag = 'DC';
                                                selectionText = type.toUpperCase();
                                            } else {
                                                selectionText = type.toUpperCase();
                                            }
                                            return `
                                                <div class="bet-selection-item">
                                                    <div class="selection-match">${match}</div>
                                                    <div class="selection-details">
                                                        <span class="selection-text">${selectionText}</span>
                                                        <span class="market-tag">${marketTag}</span>
                                                        <span class="selection-odds">@ ${isNaN(odds) ? '-' : odds.toFixed(2)}</span>
                                                    </div>
                                                </div>
                                            `;
                                        }).join('') : ''}
                                    </div>
                                    <div class="bet-card-footer">
                                        <div class="bet-financial-info">
                                            <div class="bet-stake"><span class="label">Stake:</span><span class="value">${isNaN(stakeAmount) ? '-' : stakeAmount} coins</span></div>
                                            <div class="bet-odds"><span class="label">Combined Odds:</span><span class="value">${isNaN(totalOdds) ? '-' : totalOdds.toFixed(2)}</span></div>
                                            <div class="bet-potential ${statusClass}"><span class="label">${statusUC === 'Won' ? 'Won:' : 'Potential:'}</span><span class="value">${isNaN(potentialWin) ? '-' : potentialWin.toFixed(0)} coins</span></div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        `;
                    });
                    html += '</div>';
                    myBetsContent.innerHTML = html;
                    return;
                }
            } catch (e) {
                // fall through to local storage
            }

            // Local fallback (merge legacy keys)
            const placedBets = JSON.parse(localStorage.getItem('placedBets') || '[]');
            const legacyUserBets = JSON.parse(localStorage.getItem('userBets') || '[]');
            const allLocalBets = [...placedBets, ...legacyUserBets];
            if (!allLocalBets.length) {
                myBetsContent.innerHTML = `
                    <div class="empty-bets-state">
                        <div class="empty-bets-icon">🎯</div>
                        <div class="empty-bets-title">No Bets Yet</div>
                        <div class="empty-bets-subtitle">Start betting on matches to see your bet history here</div>
                    </div>
                `;
                return;
            }
            let html = '<div class="my-bets-header">';
            html += '<h3>📋 Your Betting History</h3>';
            html += `<div class="bets-summary">${allLocalBets.length} bet${allLocalBets.length !== 1 ? 's' : ''} placed</div>`;
            html += '</div>';
            html += '<div class="bet-history-cards">';
            allLocalBets.slice().reverse().forEach((bet, index) => {
                const statusClass = String(bet.status || 'Pending').toLowerCase();
                const statusIcon = { pending: '⏳', won: '✅', lost: '❌' }[statusClass] || '⏳';
                const statusColor = { pending: '#f39c12', won: '#27ae60', lost: '#e74c3c' }[statusClass] || '#f39c12';
                const selections = bet.bets || [];
                const totalOdds = Number(bet.totalOdds ?? bet.combiOdds ?? (selections.length ? selections.reduce((t, b) => t * (b.odds || 1), 1) : 1));
                const stakeAmount = Number(bet.totalStake ?? bet.combiStake ?? bet.stake ?? 0);
                const potentialWin = Number(bet.potentialWin ?? (stakeAmount * totalOdds));
                const dateStr = bet.displayTime || '';
                const statusUC = statusClass.charAt(0).toUpperCase() + statusClass.slice(1);
                html += `
                    <div class="professional-bet-card" style="animation-delay: ${index * 0.1}s">
                        <div class="bet-card-header">
                            <div class="bet-card-title">
                                <span class="bet-id">Bet #${bet.id}</span>
                                <span class="bet-date">${dateStr}</span>
                            </div>
                            <div class="bet-status-badge" style="background: ${statusColor}">
                                <span class="status-icon">${statusIcon}</span>
                                <span class="status-text">${statusUC}</span>
                            </div>
                        </div>
                        <div class="bet-card-content">
                            <div class="bet-selections">
                                ${(selections).map(b => `
                                    <div class="bet-selection-item">
                                        <div class="selection-match">${b.match}</div>
                                        <div class="selection-details">
                                            <span class="selection-text">${b.selection}</span>
                                            <span class="selection-odds">@ ${b.odds}</span>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                            <div class="bet-card-footer">
                                <div class="bet-financial-info">
                                    <div class="bet-stake"><span class="label">Stake:</span><span class="value">${isNaN(stakeAmount) ? '-' : stakeAmount} coins</span></div>
                                    <div class="bet-odds"><span class="label">Combined Odds:</span><span class="value">${isNaN(totalOdds) ? '-' : totalOdds.toFixed(2)}</span></div>
                                    <div class="bet-potential ${statusClass}"><span class="label">${statusUC === 'Won' ? 'Won:' : 'Potential:'}</span><span class="value">${isNaN(potentialWin) ? '-' : potentialWin.toFixed(0)} coins</span></div>
                                </div>
                            </div>
                        </div>
                    </div>
                `;
            });
            html += '</div>';
            myBetsContent.innerHTML = html;
        }

        function showProfile() {
            // Pre-fill API key field (mask middle for privacy)
            const keyField = document.getElementById('api-key-input');
            if (window.oddsAPIService && keyField) {
                const currentKey = window.oddsAPIService.apiKey || '';
                keyField.value = currentKey;
            }
            const modal = document.getElementById('profileModal');
            const placedBets = JSON.parse(localStorage.getItem('placedBets') || '[]');
            
            // Calculate positive-only statistics
            const stats = calculatePositiveStats(placedBets);
            
            // Update balance display (use current DOM/state coins)
            const balanceForProfile = (typeof window.getCurrentCoins === 'function')
                ? window.getCurrentCoins()
                : Number(window.coins ?? window.userCoins ?? 1000);
            document.getElementById('profile-coins').textContent = balanceForProfile;
            
            // Update positive statistics
            document.getElementById('profile-total-winnings').textContent = stats.totalWinnings;
            document.getElementById('profile-biggest-win').textContent = stats.biggestWin;
            document.getElementById('profile-current-streak').textContent = stats.currentStreak;
            document.getElementById('profile-best-odds').textContent = stats.bestOdds.toFixed(2);
            document.getElementById('profile-successful-bets').textContent = stats.successfulBets;
            document.getElementById('profile-milestones').textContent = stats.milestones;
            document.getElementById('profile-total-combined-odds').textContent = stats.totalCombinedOdds.toFixed(2);
            
            // Update achievement badges
            updateAchievementBadges(stats);
            
            // Update progress tracking
            updateProgressTracking(stats);
            
            // Update motivational message
            updateMotivationalMessage(stats);
            
            // Update data management info
            updateDataManagementInfo();
            
            modal.style.display = 'block';
            setTimeout(() => {
                modal.classList.add('show');
            }, 10);
        }
        
        function calculatePositiveStats(placedBets) {
            const wonBets = placedBets.filter(bet => bet.status === 'Won');
            
            let totalWinnings = 0;
            let biggestWin = 0;
            let bestOdds = 1.0;
            let totalCombinedOdds = 0;
            let currentStreak = 0;
            let milestones = 0;
            
            // Calculate total winnings, biggest win, and total combined odds
            wonBets.forEach(bet => {
                const winAmount = bet.potentialWin - bet.stake; // Profit only
                totalWinnings += winAmount;
                if (winAmount > biggestWin) {
                    biggestWin = winAmount;
                }
                if (bet.totalOdds > bestOdds) {
                    bestOdds = bet.totalOdds;
                }
                // Add all successful odds together
                totalCombinedOdds += bet.totalOdds;
            });
            
            // Calculate current win streak (from most recent bets)
            const recentBets = [...placedBets].reverse(); // Most recent first
            for (let bet of recentBets) {
                if (bet.status === 'Won') {
                    currentStreak++;
                } else if (bet.status === 'Lost') {
                    break; // Streak broken
                }
                // Ignore pending bets for streak calculation
            }
            
            // Calculate milestones reached
            if (totalWinnings >= 100) milestones++;
            if (totalWinnings >= 500) milestones++;
            if (totalWinnings >= 1000) milestones++;
            if (biggestWin >= 100) milestones++;
            if (bestOdds >= 3.0) milestones++;
            if (totalCombinedOdds >= 10.0) milestones++; // New milestone for combined odds
            if (totalCombinedOdds >= 25.0) milestones++; // Another combined odds milestone
            if (currentStreak >= 3) milestones++;
            if (wonBets.length >= 5) milestones++;
            if (wonBets.length >= 10) milestones++;
            
            return {
                totalWinnings: Math.round(totalWinnings),
                biggestWin: Math.round(biggestWin),
                bestOdds: bestOdds,
                totalCombinedOdds: totalCombinedOdds,
                currentStreak: currentStreak,
                successfulBets: wonBets.length,
                milestones: milestones
            };
        }
        
        function updateAchievementBadges(stats) {
            const badgesContainer = document.getElementById('achievement-badges');
            let badges = [];
            
            // Achievement badges based on positive accomplishments
            if (stats.successfulBets >= 1) badges.push({ text: '🎯 First Win', class: '' });
            if (stats.successfulBets >= 5) badges.push({ text: '🔥 Hot Streak', class: '' });
            if (stats.successfulBets >= 10) badges.push({ text: '⭐ Betting Pro', class: 'premium' });
            if (stats.totalWinnings >= 100) badges.push({ text: '💰 Big Earner', class: '' });
            if (stats.totalWinnings >= 500) badges.push({ text: '💎 High Roller', class: 'premium' });
            if (stats.biggestWin >= 100) badges.push({ text: '🚀 Jackpot Hit', class: 'premium' });
            if (stats.bestOdds >= 3.0) badges.push({ text: '⚡ Odds Master', class: '' });
            if (stats.bestOdds >= 5.0) badges.push({ text: '🎲 Risk Taker', class: 'premium' });
            if (stats.totalCombinedOdds >= 10.0) badges.push({ text: '🔄 Odds Collector', class: '' });
            if (stats.totalCombinedOdds >= 25.0) badges.push({ text: '🎆 Odds Master', class: 'premium' });
            if (stats.currentStreak >= 3) badges.push({ text: '🔥 On Fire', class: '' });
            if (stats.currentStreak >= 5) badges.push({ text: '👑 Unstoppable', class: 'premium' });
            
            if (badges.length === 0) {
                badgesContainer.innerHTML = '<div style="color: #7f8c8d; font-style: italic;">🎯 Place your first winning bet to earn achievements!</div>';
            } else {
                badgesContainer.innerHTML = badges.map(badge => 
                    `<div class="achievement-badge ${badge.class}">${badge.text}</div>`
                ).join('');
            }
        }
        
        function updateProgressTracking(stats) {
            const progressBar = document.getElementById('achievement-progress-bar');
            const progressText = document.getElementById('next-achievement-progress');
            const progressLabel = document.getElementById('next-achievement-label');
            
            let nextGoal, current, goalText;
            
            // Determine next achievement goal
            if (stats.totalWinnings < 100) {
                nextGoal = 100;
                current = stats.totalWinnings;
                goalText = 'Reach 100 total winnings for "Big Earner" badge';
            } else if (stats.totalWinnings < 500) {
                nextGoal = 500;
                current = stats.totalWinnings;
                goalText = 'Reach 500 total winnings for "High Roller" badge';
            } else if (stats.successfulBets < 10) {
                nextGoal = 10;
                current = stats.successfulBets;
                goalText = 'Win 10 bets for "Betting Pro" badge';
            } else if (stats.currentStreak < 5) {
                nextGoal = 5;
                current = stats.currentStreak;
                goalText = 'Win 5 in a row for "Unstoppable" badge';
            } else {
                nextGoal = stats.totalWinnings + 100;
                current = stats.totalWinnings;
                goalText = 'Keep winning to unlock more achievements!';
            }
            
            const progress = Math.min((current / nextGoal) * 100, 100);
            progressBar.style.width = progress + '%';
            progressText.textContent = `${current}/${nextGoal}`;
            progressLabel.textContent = goalText;
        }
        
        function updateMotivationalMessage(stats) {
            const messageElement = document.getElementById('motivational-message');
            const messages = [
                '🌟 Keep up the great work! Your betting skills are improving!',
                '🎯 You\'re on fire! Every bet is a chance to win big!',
                '💪 Your winning streak shows real skill - keep it going!',
                '🚀 Amazing progress! You\'re becoming a betting expert!',
                '⭐ Fantastic wins! Your strategy is paying off!',
                '🔥 Incredible performance! You\'re a natural at this!',
                '💎 Outstanding results! Your betting journey is inspiring!'
            ];
            
            // Choose message based on performance
            let messageIndex = 0;
            if (stats.currentStreak >= 3) messageIndex = 2;
            if (stats.totalWinnings >= 100) messageIndex = 3;
            if (stats.successfulBets >= 5) messageIndex = 4;
            if (stats.bestOdds >= 3.0) messageIndex = 5;
            if (stats.milestones >= 3) messageIndex = 6;
            
            messageElement.textContent = messages[messageIndex];
        }

        function closeProfile() {
            document.getElementById('profileModal').style.display = 'none';
        }

        // Save the user-provided Odds API key, persist it and refresh odds
        function saveApiKey() {
            const input = document.getElementById('api-key-input');
            const statusEl = document.getElementById('api-key-status');
            if (!input || !window.oddsAPIService) return;
            const newKey = input.value.trim();
            window.oddsAPIService.setApiKey(newKey);
            statusEl.textContent = newKey ? '✅ Key saved. Live odds will refresh shortly.' : '🔄 Key cleared. Using demo key.';
            // Immediately try to refresh live odds with new key
            loadRealMatches();
            // Hide message after a few seconds
            setTimeout(() => statusEl.textContent = '', 4000);
        }


        // Create success ripple effect
        function createSuccessRipple(event) {
            const ripple = document.createElement('div');
            ripple.className = 'success-ripple';
            
            // Position ripple at click location or center of screen
            const x = event ? event.clientX : window.innerWidth / 2;
            const y = event ? event.clientY : window.innerHeight / 2;
            
            ripple.style.left = (x - 150) + 'px';
            ripple.style.top = (y - 150) + 'px';
            
            document.body.appendChild(ripple);
            
            // Remove ripple after animation
            setTimeout(() => {
                if (ripple.parentNode) {
                    ripple.parentNode.removeChild(ripple);
                }
            }, 800);
        }

        // Enhanced loading overlay
        function showLoadingOverlay(text = 'Processing...') {
            const overlay = document.createElement('div');
            overlay.className = 'loading-overlay';
            overlay.innerHTML = `
                <div class="loading-spinner"></div>
                <div class="loading-text">${text}</div>
            `;
            document.body.appendChild(overlay);
            return overlay;
        }

        function hideLoadingOverlay(overlay) {
            if (overlay && overlay.parentNode) {
                overlay.parentNode.removeChild(overlay);
            }
        }

        function showMessage(text, type) {
            const message = document.getElementById('message');
            message.textContent = text;
            message.className = `message ${type} show`;
            
            setTimeout(() => {
                message.classList.remove('show');
            }, 3000);
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log('✅ COMPLETE ScoreLeague Version Ready!');
            updateBetSlip();
            // Enable tap/click outside to unfocus bet rows
            if (typeof setupBetSlipOutsideUnfocus === 'function') {
                setupBetSlipOutsideUnfocus();
            }
        });

        // Close modal when clicking outside
        window.onclick = function(event) {
            const modal = document.getElementById('profileModal');
            if (event.target === modal) {
                closeProfile();
            }
        }
        
        // =============================================================================
        // DATA MANAGEMENT FUNCTIONS
        // =============================================================================
        
        // Update data management info in profile modal
        function updateDataManagementInfo() {
            document.getElementById('app-version-display').textContent = APP_VERSION;
            document.getElementById('data-version-display').textContent = gameData.version;
            
            const lastUpdated = new Date(gameData.lastUpdated).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'short',
                day: 'numeric',
                hour: '2-digit',
                minute: '2-digit'
            });
            document.getElementById('last-updated-display').textContent = lastUpdated;
        }
        
        // Export game data
        function exportGameData() {
            // Save current state before export
            saveGameState();
            
            if (DataManager.exportData()) {
                showMessage('📤 Data exported successfully! Check your downloads folder.', 'success');
            } else {
                showMessage('❌ Failed to export data. Please try again.', 'error');
            }
        }
        
        // Trigger file input for import
        function triggerImportData() {
            document.getElementById('importFileInput').click();
        }
        
        // Handle file import
        function handleImportData(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            if (file.type !== 'application/json') {
                showMessage('❌ Please select a valid JSON backup file.', 'error');
                return;
            }
            
            // Confirm import (will overwrite current data)
            if (!confirm('⚠️ This will replace all your current data with the imported data. Are you sure?')) {
                event.target.value = ''; // Clear file input
                return;
            }
            
            DataManager.importData(file)
                .then(importedData => {
                    // Update global variables with imported data
                    Object.assign(gameData, importedData);
                    betSlip = gameData.betSlip || [];
                    coins = gameData.userData.coins || 1000;
                    currentStake = gameData.currentStake || 0;
                    totalBetsPlaced = gameData.userData.totalBetsPlaced || 0;
                    
                    // Update UI
                    updateCoinDisplay();
                    showTab('matches');
                    updateBetSlip();
                    updateDataManagementInfo();
                    
                    // Refresh current tab content
                    const activeTab = document.querySelector('.nav-tab.active');
                    if (activeTab) {
                        const tabName = activeTab.textContent.toLowerCase().trim();
                        if (tabName.includes('social')) {
                            updateMyLeagues();
                            updateRankings();
                        } else if (tabName.includes('my bets')) {
                            updateMyBets();
                        }
                    }
                    
                    showMessage('✅ Data imported successfully! Your game state has been restored.', 'success');
                    console.log('🔄 Game state restored from backup:', importedData.version);
                })
                .catch(error => {
                    console.error('Import error:', error);
                    showMessage('❌ Failed to import data. Please check the file format.', 'error');
                })
                .finally(() => {
                    event.target.value = ''; // Clear file input
                });
        }
        
        // Enhanced save function that uses the versioned data system
        function saveGameStateEnhanced() {
            // Update all current state in gameData
            gameData.betSlip = betSlip;
            gameData.userData.coins = coins;
            gameData.currentStake = currentStake;
            gameData.userData.totalBetsPlaced = totalBetsPlaced;
            
            // Save bets from localStorage to versioned structure
            const placedBets = JSON.parse(localStorage.getItem('placedBets') || '[]');
            gameData.bets = placedBets;
            
            // Save leagues from localStorage to versioned structure
            const userLeagues = JSON.parse(localStorage.getItem('userLeagues') || '[]');
            gameData.leagues = userLeagues;
            
            // Save tournament data
            const tournamentStats = JSON.parse(localStorage.getItem('tournamentStats') || '{}');
            gameData.tournaments = tournamentStats;
            
            return DataManager.saveToStorage(gameData);
        }
        
        // Override the original saveGameState with enhanced version
        saveGameState = saveGameStateEnhanced;
        
        // Auto-save every 30 seconds during active use
        setInterval(() => {
            if (document.visibilityState === 'visible') {
                saveGameState();
                console.log('🔄 Auto-saved game state');
            }
        }, 30000);
        
        // Save on page unload
        window.addEventListener('beforeunload', () => {
            saveGameState();
        });
        
        // Data integrity check on startup
        function performDataIntegrityCheck() {
            const issues = [];
            
            // Check for data corruption
            if (!gameData.version) issues.push('Missing data version');
            if (!gameData.userData) issues.push('Missing user data');
            if (!Array.isArray(gameData.betSlip)) issues.push('Invalid bet slip data');
            
            // Check localStorage vs versioned data sync
            const localBets = JSON.parse(localStorage.getItem('placedBets') || '[]');
            if (localBets.length !== gameData.bets.length) {
                console.warn('⚠️ Bet data out of sync between localStorage and versioned data');
            }
            
            if (issues.length > 0) {
                console.warn('⚠️ Data integrity issues found:', issues);
                showMessage('⚠️ Some data issues detected. Consider exporting a backup.', 'warning');
            } else {
                console.log('✅ Data integrity check passed');
            }
        }
        
        // Run integrity check on startup
        setTimeout(performDataIntegrityCheck, 1000);
        
        console.log('🎯 Versioned Data System v' + APP_VERSION + ' fully initialized!');
        console.log('💾 Data management features: Export, Import, Auto-save, Integrity checks');
        console.log('🔧 Safe development mode: Ready for live updates during testing');
        
        // =============================================================================
        // REAL MATCH DATA INTEGRATION
        // =============================================================================
        
        // Global variable to store real matches
        let realMatches = [];
        
        // Admin helpers: settle matches via backend (Python/Node parity)
        function safeId(id) {
            try { return String(id || '').replace(/[^a-zA-Z0-9_-]/g, '_'); } catch (_) { return String(id || 'id'); }
        }
        
        // Preserve admin input values across re-renders
        function captureAdminInputs() {
            const map = {};
            try {
                const nodes = document.querySelectorAll('input[id^="settle-home-"], input[id^="settle-away-"]');
                nodes.forEach(inp => {
                    const m = (inp.id || '').match(/^settle-(home|away)-(.+)$/);
                    if (!m) return;
                    const side = m[1];
                    const sid = m[2];
                    if (!map[sid]) map[sid] = {};
                    map[sid][side] = inp.value;
                });
            } catch (_) {}
            return map;
        }
        
        function restoreAdminInputs(saved) {
            try {
                Object.keys(saved || {}).forEach(sid => {
                    const v = saved[sid] || {};
                    if (Object.prototype.hasOwnProperty.call(v, 'home')) {
                        const elH = document.getElementById(`settle-home-${sid}`);
                        if (elH && (elH.value === '' || elH.value === null)) elH.value = v.home;
                    }
                    if (Object.prototype.hasOwnProperty.call(v, 'away')) {
                        const elA = document.getElementById(`settle-away-${sid}`);
                        if (elA && (elA.value === '' || elA.value === null)) elA.value = v.away;
                    }
                });
            } catch (_) {}
        }
        
        function captureActiveAdminElement() {
            try {
                const ae = document.activeElement;
                if (ae && typeof ae.id === 'string' && /^settle-(home|away)-/.test(ae.id)) return ae.id;
            } catch (_) {}
            return null;
        }
        
        function restoreActiveAdminElement(id) {
            if (!id) return;
            try {
                const el = document.getElementById(id);
                if (el) {
                    el.focus();
                    try { if (typeof el.setSelectionRange === 'function') el.setSelectionRange(el.value.length, el.value.length); } catch (_) {}
                }
            } catch (_) {}
        }
        
        // Persist admin inputs in localStorage and merge with captured values
        function getPersistedAdminInputs() {
            try {
                const raw = localStorage.getItem('admin_inputs');
                const obj = JSON.parse(raw || '{}');
                return obj && typeof obj === 'object' ? obj : {};
            } catch (_) {
                return {};
            }
        }
        function persistAdminInput(sid, side, value) {
            try {
                const map = getPersistedAdminInputs();
                if (!map[sid]) map[sid] = {};
                map[sid][side] = String(value ?? '');
                localStorage.setItem('admin_inputs', JSON.stringify(map));
            } catch (_) { /* ignore */ }
        }
        function mergeAdminSavedInputs(captured) {
            try {
                const persisted = getPersistedAdminInputs();
                const out = {};
                // start with persisted
                Object.keys(persisted || {}).forEach(sid => {
                    out[sid] = Object.assign({}, persisted[sid]);
                });
                // overlay captured (non-empty only)
                Object.keys(captured || {}).forEach(sid => {
                    const v = captured[sid] || {};
                    if (!out[sid]) out[sid] = {};
                    ['home','away'].forEach(side => {
                        if (Object.prototype.hasOwnProperty.call(v, side)) {
                            const val = v[side];
                            if (val !== '' && val !== null && typeof val !== 'undefined') {
                                out[sid][side] = val;
                            }
                        }
                    });
                });
                return out;
            } catch (_) {
                return captured || {};
            }
        }
        
        // Clear persisted inputs for a specific match id
        function clearPersistedAdminInputsFor(sid) {
            try {
                const map = getPersistedAdminInputs();
                if (map && Object.prototype.hasOwnProperty.call(map, sid)) {
                    delete map[sid];
                    localStorage.setItem('admin_inputs', JSON.stringify(map));
                }
            } catch (_) { /* ignore */ }
        }
        
        // Prevent lower-priority renders from overwriting higher-priority views
        function beginRender(source) {
            try {
                const priorities = { fallback: 0, live: 1, node: 2, real: 3 };
                const pr = (Object.prototype.hasOwnProperty.call(priorities, source)) ? priorities[source] : 0;
                window._renderState = window._renderState || { priority: -1, seq: 0, last: null };
                const seq = ++window._renderState.seq;
                if (pr < window._renderState.priority) {
                    try { console.log(`[render:${source}] skipped (priority ${pr} < current ${window._renderState.priority})`); } catch (_) {}
                    return { allowed: false, pr, seq };
                }
                window._renderState.priority = pr;
                window._renderState.last = source;
                return { allowed: true, pr, seq };
            } catch (_) {
                return { allowed: true, pr: 0, seq: 0 };
            }
        }
        
        // Build headers including admin token when available
        function buildAdminHeaders() {
            const h = { 'Content-Type': 'application/json' };
            try { if (window.ADMIN_TOKEN) h['X-Admin-Token'] = window.ADMIN_TOKEN; } catch (_) {}
            return h;
        }
        
        // Call backend to settle all bets for a match by final score
        async function adminSettleForCard(rawMatchId) {
            try {
                const sid = safeId(rawMatchId);
                const homeEl = document.getElementById(`settle-home-${sid}`);
                const awayEl = document.getElementById(`settle-away-${sid}`);
                const btn = document.getElementById(`settle-btn-${sid}`);
                if (!homeEl || !awayEl) {
                    alert('Score inputs not found for this match card.');
                    return;
                }
                const homeGoals = Number(homeEl.value || 0);
                const awayGoals = Number(awayEl.value || 0);
                if (!Number.isFinite(homeGoals) || !Number.isFinite(awayGoals) || homeGoals < 0 || awayGoals < 0) {
                    alert('Please enter valid non-negative integers for goals.');
                    return;
                }
                if (btn) { btn.disabled = true; btn.textContent = 'Settling...'; }
                const res = await fetch(`${API_BASE}/api/matches/${encodeURIComponent(rawMatchId)}/settle`, {
                    method: 'POST',
                    headers: buildAdminHeaders(),
                    body: JSON.stringify({ homeGoals, awayGoals })
                });
                if (!res.ok) {
                    const err = await res.json().catch(() => ({}));
                    throw new Error(err?.error || `HTTP ${res.status}`);
                }
                const data = await res.json();
                const r = data?.results || {};
                alert(`✅ Match settled. Settled: ${data?.settled || 0}, Won: ${data?.won || 0}\nResults: 1X2=${r.match_result || '?'}, DC=${(r.double_chance || []).join(',')}, O/U=${r.total_goals || '?'}, BTTS=${r.btts || '?'}`);
                // Clear persisted admin inputs for this match after successful settlement
                try { clearPersistedAdminInputsFor(sid); } catch (_) {}
                
                // Refresh coins for current user by re-login (Python backend updates coins but has no sockets)
                try {
                    if (currentUser && currentUser.username) {
                        const resAuth = await fetch(`${API_BASE}/api/auth/login`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({ username: currentUser.username })
                        });
                        if (resAuth.ok) {
                            const u = await resAuth.json();
                            if (u && (u.id || u.userId)) {
                                currentUser = u;
                                try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                                if (typeof updateUserUI === 'function') updateUserUI();
                                if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                            }
                        }
                    }
                } catch (_) { /* non-fatal */ }
                
                // Try to refresh open/recent bets if those inline loaders exist
                try { if (window.betslipViewMode === 'open' && typeof window.loadOpenBetsInline === 'function') await window.loadOpenBetsInline(); } catch (_) {}
                try { if (window.betslipViewMode === 'recent' && typeof window.loadRecentBetsInline === 'function') await window.loadRecentBetsInline(); } catch (_) {}
            } catch (e) {
                console.error('adminSettleForCard error', e);
                alert('❌ Settlement failed: ' + (e?.message || String(e)));
            } finally {
                const sid = safeId(rawMatchId);
                const btn = document.getElementById(`settle-btn-${sid}`);
                if (btn) { btn.disabled = false; btn.textContent = 'Settle'; }
            }
        }
        // Expose for inline onclick usage
        window.adminSettleForCard = adminSettleForCard;
        
        // Load real matches from API
        async function loadRealMatches() {
            console.log('🔄 Loading real match data from API...');
            if (window._loadRealMatchesBusy) { try { console.log('[loadRealMatches] skipped: in-progress'); } catch (_) {} return; }
            window._loadRealMatchesBusy = true;
            
            // Update UI to show loading state
            document.getElementById('matches-title').textContent = '⚽ Loading Real Matches...';
            // Do not wipe existing content during refresh to avoid flicker/removing admin UI
            const _mc = document.getElementById('matches-container');
            if (_mc && _mc.children.length === 0) {
                _mc.innerHTML = '<div class="loading-matches"><p>📡 Fetching live match data from 2. Bundesliga and other leagues...</p></div>';
            }
            
            try {
                if (typeof window.oddsAPIService !== 'undefined' && typeof window.oddsAPIService.getMultipleLeagues === 'function') {
                    const matches = await window.oddsAPIService.getMultipleLeagues();
                    if (Array.isArray(matches) && matches.length > 0) {
                        renderRealMatches(matches);
                        try { console.log(`✅ Loaded ${matches.length} real matches successfully!`); } catch (_) {}
                    } else {
                        try { console.log('⚠️ No matches found, falling back to demo data'); } catch (_) {}
                        renderFallbackMatches();
                        try { renderNoOddsMessage(); } catch (_) {}
                    }
                } else {
                    try { console.error('❌ Odds API service not available'); } catch (_) {}
                    renderFallbackMatches();
                    try { renderNoOddsMessage(); } catch (_) {}
                }
            } catch (error) {
                try { console.error('❌ Error loading real matches:', error); } catch (_) {}
                renderFallbackMatches();
                try { renderNoOddsMessage(); } catch (_) {}
            } finally {
                window._loadRealMatchesBusy = false;
            }
        }
        
        // Render real matches from API
        function renderRealMatches(matches) {
            const container = document.getElementById('matches-container');
            const title = document.getElementById('matches-title');
            const refreshBtn = document.getElementById('refresh-matches');
            try { console.log('[renderRealMatches] IS_ADMIN=', !!window.IS_ADMIN); } catch (_) {}
            const __gate = beginRender('real');
            if (!__gate.allowed) return;
            const __savedAdminInputs = mergeAdminSavedInputs(captureAdminInputs());
            const __activeAdminElId = captureActiveAdminElement();
            
            // Update title and show refresh button
            title.textContent = `⚽ Live Matches (${matches.length} available)`;
            if (refreshBtn) refreshBtn.style.display = 'inline-block';
            
            // Group matches by league
            const matchesByLeague = {};
            (Array.isArray(matches) ? matches : []).forEach(match => {
                if (!matchesByLeague[match.league]) {
                    matchesByLeague[match.league] = [];
                }
                matchesByLeague[match.league].push(match);
            });
            
            let html = '';
            
            // Render each league section
            Object.keys(matchesByLeague).forEach(league => {
                const leagueMatches = matchesByLeague[league];
                html += `<div class="league-section">`;
                html += `<h3 class="league-title">🏆 ${league} (${leagueMatches.length} matches)</h3>`;
                
                leagueMatches.forEach(match => {
                    html += renderMatchCard(match);
                });
                
                html += `</div>`;
            });
            
            container.innerHTML = html;
            window._lastRender = { source: 'real', data: (Array.isArray(matches) ? matches.slice() : matches) };
            restoreAdminInputs(__savedAdminInputs);
            restoreActiveAdminElement(__activeAdminElId);
            try { scheduleAutoFillScan(); } catch (_) {}
        }
        
        // Render individual match card
        function renderMatchCard(match) {
            const statusIcon = match.status === 'live' ? '🔴' : (match.status === 'upcoming' ? '⏰' : '✅');
            const statusText = match.status === 'live' ? 'LIVE' : (match.status === 'upcoming' ? `${match.date} ${match.time}` : 'Finished');
            const sid = safeId(match.id);
            const adminUI = window.IS_ADMIN ? `
                <div class="admin-settle" style="margin-top:8px; padding-top:8px; border-top:1px dashed #ccc;">
                    <div style="font-weight:600; font-size:12px; margin-bottom:6px;">Admin: Final Score & Settle</div>
                    <div style="display:flex; align-items:center; gap:6px;">
                        <input id="settle-home-${sid}" type="number" min="0" placeholder="${match.homeTeam} goals" style="width:60px; padding:4px;" />
                        <span>:</span>
                        <input id="settle-away-${sid}" type="number" min="0" placeholder="${match.awayTeam} goals" style="width:60px; padding:4px;" />
                        <button id="settle-btn-${sid}" class="odds-button" style="padding:6px 10px;" onclick="adminSettleForCard('${match.id}')">Settle</button>
                    </div>
                </div>
            ` : '';
            
            return `
                <div class="match-card real-match" data-match-id="${match.id}" data-status="${match.status}" data-home-team="${match.homeTeam}" data-away-team="${match.awayTeam}">
                    <div class="match-header">
                        <div class="teams-display">
                            <div class="team">
                                <span class="team-logo">⚽</span>
                                <span class="team-name">${match.homeTeam}</span>
                            </div>
                            <div class="vs-divider">VS</div>
                            <div class="team">
                                <span class="team-logo">⚽</span>
                                <span class="team-name">${match.awayTeam}</span>
                            </div>
                        </div>
                        <div class="match-info">
                            <span class="match-time">${statusIcon} ${statusText}</span>
                            <span class="match-league">🏆 ${match.league}</span>
                        </div>
                    </div>
                    
                    <div class="market-section">
                        <div class="market-title">Match Result (1X2)</div>
                        <div class="market-odds">
                            <button class="odds-button" onclick="toggleBet('${match.id}-1', '${match.homeTeam} vs ${match.awayTeam}', '${match.homeTeam} Win', ${match.markets.match_result.home}, this, event)">1 (${match.markets.match_result.home})</button>
                            <button class="odds-button" onclick="toggleBet('${match.id}-x', '${match.homeTeam} vs ${match.awayTeam}', 'Draw', ${match.markets.match_result.draw}, this, event)">X (${match.markets.match_result.draw})</button>
                            <button class="odds-button" onclick="toggleBet('${match.id}-2', '${match.homeTeam} vs ${match.awayTeam}', '${match.awayTeam} Win', ${match.markets.match_result.away}, this, event)">2 (${match.markets.match_result.away})</button>
                        </div>
                    </div>
                    
                    <div class="market-section">
                        <div class="market-title">Doppelte Chance</div>
                        <div class="market-odds">
                            <button class="odds-button" onclick="toggleBet('${match.id}-1x', '${match.homeTeam} vs ${match.awayTeam}', '${match.homeTeam} oder Unentschieden', ${(1/((1/Number(match.markets.match_result.home)) + (1/Number(match.markets.match_result.draw)))).toFixed(2)}, this, event)">1X (${(1/((1/Number(match.markets.match_result.home)) + (1/Number(match.markets.match_result.draw)))).toFixed(2)})</button>
                            <button class="odds-button" onclick="toggleBet('${match.id}-12', '${match.homeTeam} vs ${match.awayTeam}', '${match.homeTeam} oder ${match.awayTeam}', ${(1/((1/Number(match.markets.match_result.home)) + (1/Number(match.markets.match_result.away)))).toFixed(2)}, this, event)">12 (${(1/((1/Number(match.markets.match_result.home)) + (1/Number(match.markets.match_result.away)))).toFixed(2)})</button>
                            <button class="odds-button" onclick="toggleBet('${match.id}-x2', '${match.homeTeam} vs ${match.awayTeam}', 'Unentschieden oder ${match.awayTeam}', ${(1/((1/Number(match.markets.match_result.draw)) + (1/Number(match.markets.match_result.away)))).toFixed(2)}, this, event)">X2 (${(1/((1/Number(match.markets.match_result.draw)) + (1/Number(match.markets.match_result.away)))).toFixed(2)})</button>
                        </div>
                    </div>
                    
                    <div class="market-section">
                        <div class="market-title">Total Goals</div>
                        <div class="market-odds">
                            <button class="odds-button" onclick="toggleBet('${match.id}-over', '${match.homeTeam} vs ${match.awayTeam}', 'Over 2.5 Goals', ${match.markets.total_goals.over}, this, event)">Over (${match.markets.total_goals.over})</button>
                            <button class="odds-button" onclick="toggleBet('${match.id}-under', '${match.homeTeam} vs ${match.awayTeam}', 'Under 2.5 Goals', ${match.markets.total_goals.under}, this, event)">Under (${match.markets.total_goals.under})</button>
                        </div>
                    </div>
                    
                    <div class="market-section">
                        <div class="market-title">Both Teams to Score</div>
                        <div class="market-odds">
                            <button class="odds-button" onclick="toggleBet('${match.id}-btts-yes', '${match.homeTeam} vs ${match.awayTeam}', 'Both Teams Score - Yes', ${match.markets.both_teams_score.yes}, this, event)">Yes (${match.markets.both_teams_score.yes})</button>
                            <button class="odds-button" onclick="toggleBet('${match.id}-btts-no', '${match.homeTeam} vs ${match.awayTeam}', 'Both Teams Score - No', ${match.markets.both_teams_score.no}, this, event)">No (${match.markets.both_teams_score.no})</button>
                        </div>
                    </div>
                    ${adminUI}
                </div>
            `;
        }
        
        // Fallback to demo matches if API fails
        function renderFallbackMatches() {
            const container = document.getElementById('matches-container');
            const title = document.getElementById('matches-title');
            const __gate = beginRender('fallback');
            if (!__gate.allowed) return;
            const __savedAdminInputs = mergeAdminSavedInputs(captureAdminInputs());
            const __activeAdminElId = captureActiveAdminElement();
            
            // Update title to show matches are loaded
            title.textContent = '⚽ Heute\'s Spiele';
            
            // Clear container and add organized matches
            const matches = [
                // 2. BUNDESLIGA - Friday matches (18:30)
                {
                    league: '2. Bundesliga',
                    leagueIcon: '🇩🇪',
                    matches: [
                        {
                            home: 'SC Preußen Münster',
                            away: 'SC Paderborn 07',
                            time: 'Fr 18:30',
                            homeOdds: 3.30,
                            drawOdds: 3.30,
                            awayOdds: 2.25,
                            overOdds: 2.10,
                            underOdds: 1.70
                        },
                        {
                            home: '1. FC Nürnberg',
                            away: 'Darmstadt 98',
                            time: 'Fr 18:30',
                            homeOdds: 2.87,
                            drawOdds: 3.40,
                            awayOdds: 2.50,
                            overOdds: 1.90,
                            underOdds: 1.90
                        },
                        {
                            home: 'Hannover 96',
                            away: 'Hamburger SV',
                            time: 'Fr 18:30',
                            homeOdds: 2.30,
                            drawOdds: 3.50,
                            awayOdds: 3.00,
                            overOdds: 1.85,
                            underOdds: 1.95
                        }
                    ]
                },
                // 2. BUNDESLIGA - Saturday matches
                {
                    league: '2. Bundesliga',
                    leagueIcon: '🇩🇪',
                    matches: [
                        {
                            home: 'Karlsruher SC',
                            away: '1. FC Köln',
                            time: 'Sa 13:00',
                            homeOdds: 2.65,
                            drawOdds: 3.30,
                            awayOdds: 2.70,
                            overOdds: 1.95,
                            underOdds: 1.85
                        },
                        {
                            home: 'Fortuna Düsseldorf',
                            away: 'Hertha BSC',
                            time: 'Sa 13:00',
                            homeOdds: 2.10,
                            drawOdds: 3.40,
                            awayOdds: 3.50,
                            overOdds: 1.80,
                            underOdds: 2.00
                        }
                    ]
                },
                // BUNDESLIGA - Saturday matches
                {
                    league: 'Bundesliga',
                    leagueIcon: '🏆',
                    matches: [
                        {
                            home: 'Bayern München',
                            away: 'Borussia Dortmund',
                            time: 'Sa 18:30',
                            homeOdds: 1.65,
                            drawOdds: 4.20,
                            awayOdds: 4.50,
                            overOdds: 1.45,
                            underOdds: 2.70
                        },
                        {
                            home: 'RB Leipzig',
                            away: 'Bayer Leverkusen',
                            time: 'Sa 15:30',
                            homeOdds: 2.20,
                            drawOdds: 3.60,
                            awayOdds: 3.10,
                            overOdds: 1.55,
                            underOdds: 2.40
                        }
                    ]
                }
            ];
            
            // Build HTML
            let html = '';
            
            matches.forEach((leagueGroup) => {
                // League header
                html += `
                    <div class="league-header" style="margin: 20px 0 10px; padding: 10px; background: linear-gradient(135deg, #2c3e50, #34495e); border-radius: 8px;">
                        <h3 style="color: white; margin: 0; font-size: 16px;">
                            ${leagueGroup.leagueIcon} ${leagueGroup.league}
                        </h3>
                    </div>
                `;
                
                (Array.isArray(leagueGroup.matches) ? leagueGroup.matches : []).forEach((match, idx) => {
                    const matchId = safeId(`${leagueGroup.league}-${idx}-${match.home}-${match.away}`);
                    html += `
                        <div class="match-card" data-match-id="${matchId}" data-status="" data-home-team="${match.home}" data-away-team="${match.away}">
                            <div class="match-header">
                                <div class="match-time">⏰ ${match.time}</div>
                                <div class="league-badge">${leagueGroup.league}</div>
                            </div>
                            <div class="teams">
                                <div class="team">
                                    <div class="team-name">${match.home}</div>
                                </div>
                                <div class="vs">VS</div>
                                <div class="team">
                                    <div class="team-name">${match.away}</div>
                                </div>
                            </div>
                            <div class="betting-markets">
                                <div class="market">
                                    <div class="market-title">Endergebnis</div>
                                    <div class="market-odds">
                                        <button class="odds-button" onclick="toggleBet('${matchId}-1', '${match.home} vs ${match.away}', '${match.home}', ${match.homeOdds}, this, event)">1 (${match.homeOdds.toFixed(2)})</button>
                                        <button class="odds-button" onclick="toggleBet('${matchId}-x', '${match.home} vs ${match.away}', 'Unentschieden', ${match.drawOdds}, this, event)">X (${match.drawOdds.toFixed(2)})</button>
                                        <button class="odds-button" onclick="toggleBet('${matchId}-2', '${match.home} vs ${match.away}', '${match.away}', ${match.awayOdds}, this, event)">2 (${match.awayOdds.toFixed(2)})</button>
                                    </div>
                                </div>
                                <div class="market">
                                    <div class="market-title">Doppelte Chance</div>
                                    <div class="market-odds">
                                        <button class="odds-button" onclick="toggleBet('${matchId}-1x', '${match.home} vs ${match.away}', '${match.home} oder Unentschieden', ${(1/((1/match.homeOdds) + (1/match.drawOdds))).toFixed(2)}, this, event)">1X (${(1/((1/match.homeOdds) + (1/match.drawOdds))).toFixed(2)})</button>
                                        <button class="odds-button" onclick="toggleBet('${matchId}-12', '${match.home} vs ${match.away}', '${match.home} oder ${match.away}', ${(1/((1/match.homeOdds) + (1/match.awayOdds))).toFixed(2)}, this, event)">12 (${(1/((1/match.homeOdds) + (1/match.awayOdds))).toFixed(2)})</button>
                                        <button class="odds-button" onclick="toggleBet('${matchId}-x2', '${match.home} vs ${match.away}', 'Unentschieden oder ${match.away}', ${(1/((1/match.drawOdds) + (1/match.awayOdds))).toFixed(2)}, this, event)">X2 (${(1/((1/match.drawOdds) + (1/match.awayOdds))).toFixed(2)})</button>
                                    </div>
                                </div>
                                <div class="market">
                                    <div class="market-title">Über/Unter 2.5 Tore</div>
                                    <div class="market-odds">
                                        <button class="odds-button" onclick="toggleBet('${matchId}-over', '${match.home} vs ${match.away}', 'Über 2.5', ${match.overOdds}, this, event)">Über (${match.overOdds.toFixed(2)})</button>
                                        <button class="odds-button" onclick="toggleBet('${matchId}-under', '${match.home} vs ${match.away}', 'Unter 2.5', ${match.underOdds}, this, event)">Unter (${match.underOdds.toFixed(2)})</button>
                                    </div>
                                </div>
                            </div>
                            ${window.IS_ADMIN ? `
                            <div class="admin-settle" style="margin-top:8px; padding-top:8px; border-top:1px dashed #ccc; opacity:0.7;">
                                <div style="font-weight:600; font-size:12px; margin-bottom:6px;">Admin: Final Score & Settle (Demo data)</div>
                                <div style="display:flex; align-items:center; gap:6px;">
                                    <input id="settle-home-${matchId}" type="number" min="0" placeholder="${match.home} goals" style="width:60px; padding:4px;" disabled />
                                    <span>:</span>
                                    <input id="settle-away-${matchId}" type="number" min="0" placeholder="${match.away} goals" style="width:60px; padding:4px;" disabled />
                                    <button id="settle-btn-${matchId}" class="odds-button" style="padding:6px 10px;" disabled title="Settlement disabled for demo matches">Settle</button>
                                </div>
                            </div>` : ''}
                        </div>
                    `;
                });
            });
            
            container.innerHTML = html;
            window._lastRender = { source: 'fallback', data: null };
            restoreAdminInputs(__savedAdminInputs);
            restoreActiveAdminElement(__activeAdminElId);
        }
        
        // Auto-load real matches on page load
        window.addEventListener('DOMContentLoaded', async function() {
            // Initialize Supabase first
            await initializeSupabase();
            
            // Check for existing session
            checkExistingSession();
            
            // Initialize with demo matches immediately
            renderFallbackMatches();
            
            // Try to load live odds from The Odds API
            initializeLiveOdds();
            
            // Then try to fetch real matches from API
            loadRealMatches();
            // Background refresh every 60 seconds
            setInterval(loadRealMatches, 60000);
            
            // Persist admin score inputs and auto-recover admin UI if removed by other updates
            try {
                const mc = document.getElementById('matches-container');
                if (mc) {
                    // Delegate input persistence
                    mc.addEventListener('input', function(e) {
                        const t = e.target;
                        if (!t || !t.id) return;
                        const m = String(t.id).match(/^settle-(home|away)-(.+)$/);
                        if (!m) return;
                        persistAdminInput(m[2], m[1], t.value);
                    });
                    
                    // Observe DOM to ensure admin UI presence for admins
                    let moTimer = null;
                    const obs = new MutationObserver(function() {
                        if (!window.IS_ADMIN) return;
                        if (moTimer) clearTimeout(moTimer);
                        moTimer = setTimeout(function() {
                            const hasMatch = mc.querySelector('.match-card');
                            const hasAdmin = mc.querySelector('.admin-settle');
                            if (hasMatch && !hasAdmin) {
                                const last = window._lastRender || {};
                                try {
                                    if (last.source === 'real' && Array.isArray(last.data)) renderRealMatches(last.data);
                                    else if (last.source === 'live' && Array.isArray(last.data)) renderLiveMatches(last.data);
                                    else if (last.source === 'node' && Array.isArray(last.data)) renderMatches(last.data);
                                    else if (last.source === 'fallback') renderFallbackMatches();
                                } catch (e) { try { console.warn('Admin UI recovery failed', e); } catch (_) {} }
                            } else {
                                try { restoreAdminInputs(getPersistedAdminInputs()); } catch (_) {}
                            }
                        }, 50);
                    });
                    obs.observe(mc, { childList: true, subtree: true });
                    window._adminUIMutationObserver = obs;
                }
            } catch (_) { /* non-fatal */ }
        });
        
        // =============================
        // Admin Auto-Fill Score Helpers
        // =============================
        window._autoFillInFlight = window._autoFillInFlight || new Set();
        window._autoFilledMatchIds = window._autoFilledMatchIds || new Set();
        window._autoSettledMatchIds = window._autoSettledMatchIds || new Set();
        window.AUTO_FILL_SCORES = (function(){ try { return localStorage.getItem('admin_auto_fill') === '1'; } catch(_) { return false; } })();
        window.AUTO_SETTLE = (function(){ try { return localStorage.getItem('admin_auto_settle') === '1'; } catch(_) { return false; } })();

        function setupAdminAutoControls() {
            const panel = document.getElementById('admin-auto-controls');
            if (!panel) return;
            if (!window.IS_ADMIN) { panel.style.display = 'none'; return; }
            panel.style.display = 'block';
            const cbFill = document.getElementById('toggle-auto-fill');
            const cbSettle = document.getElementById('toggle-auto-settle');
            if (cbFill) {
                cbFill.checked = !!window.AUTO_FILL_SCORES;
                cbFill.addEventListener('change', function() {
                    window.AUTO_FILL_SCORES = !!cbFill.checked;
                    try { localStorage.setItem('admin_auto_fill', cbFill.checked ? '1' : '0'); } catch(_) {}
                    if (window.AUTO_FILL_SCORES) {
                        if (!window._autoFillInterval) window._autoFillInterval = setInterval(scanAutoFillForFinished, 15000);
                        scheduleAutoFillScan();
                    } else {
                        if (window._autoFillInterval) { clearInterval(window._autoFillInterval); window._autoFillInterval = null; }
                    }
                });
            }
            if (cbSettle) {
                cbSettle.checked = !!window.AUTO_SETTLE;
                cbSettle.addEventListener('change', function() {
                    window.AUTO_SETTLE = !!cbSettle.checked;
                    try { localStorage.setItem('admin_auto_settle', cbSettle.checked ? '1' : '0'); } catch(_) {}
                });
            }
            if (window.AUTO_FILL_SCORES && !window._autoFillInterval) {
                window._autoFillInterval = setInterval(scanAutoFillForFinished, 15000);
                scheduleAutoFillScan();
            }
        }

        function scheduleAutoFillScan() {
            if (!window.IS_ADMIN || !window.AUTO_FILL_SCORES) return;
            if (window._scanAutoFillTimer) clearTimeout(window._scanAutoFillTimer);
            window._scanAutoFillTimer = setTimeout(scanAutoFillForFinished, 60);
        }

        async function scanAutoFillForFinished() {
            try {
                if (!window.IS_ADMIN || !window.AUTO_FILL_SCORES) return;
                if (typeof window.scoreService === 'undefined' || typeof window.scoreService.getFinalScore !== 'function') return;
                const cards = document.querySelectorAll('.match-card.real-match[data-status]');
                for (const card of cards) {
                    const status = String(card.getAttribute('data-status') || '').toLowerCase();
                    if (status !== 'finished') continue;
                    const mid = card.getAttribute('data-match-id') || '';
                    const homeTeam = card.getAttribute('data-home-team') || '';
                    const awayTeam = card.getAttribute('data-away-team') || '';
                    if (!mid) continue;
                    if (window._autoSettledMatchIds && window._autoSettledMatchIds.has(mid)) continue;
                    if (window._autoFillInFlight.has(mid)) continue;
                    const sid = safeId(mid);
                    const homeEl = document.getElementById(`settle-home-${sid}`);
                    const awayEl = document.getElementById(`settle-away-${sid}`);
                    if (!homeEl || !awayEl || homeEl.disabled || awayEl.disabled) continue;
                    const ae = document.activeElement;
                    if (ae && (ae === homeEl || ae === awayEl)) continue;
                    const hasValues = (homeEl.value !== '' && awayEl.value !== '');
                    if (hasValues) continue;
                    window._autoFillInFlight.add(mid);
                    try {
                        const res = await window.scoreService.getFinalScore(mid, homeTeam, awayTeam);
                        if (res && Number.isFinite(Number(res.home)) && Number.isFinite(Number(res.away))) {
                            if (!homeEl.value) { homeEl.value = Number(res.home); try { persistAdminInput(sid, 'home', homeEl.value); } catch(_) {} }
                            if (!awayEl.value) { awayEl.value = Number(res.away); try { persistAdminInput(sid, 'away', awayEl.value); } catch(_) {} }
                            try {
                                homeEl.style.backgroundColor = '#e8f7ef';
                                awayEl.style.backgroundColor = '#e8f7ef';
                                setTimeout(()=>{ homeEl.style.backgroundColor=''; awayEl.style.backgroundColor=''; }, 1500);
                            } catch(_) {}
                            if (window.AUTO_SETTLE && window.ADMIN_TOKEN) {
                                if (!window._autoSettledMatchIds.has(mid)) {
                                    window._autoSettledMatchIds.add(mid);
                                    setTimeout(()=>{ try { adminSettleForCard(mid); } catch(_) { window._autoSettledMatchIds.delete(mid); } }, 250);
                                }
                            }
                        }
                    } catch(_) {
                        // ignore
                    } finally {
                        window._autoFillInFlight.delete(mid);
                    }
                }
            } catch (e) {
                try { console.warn('[auto-fill] scan error', e); } catch(_) {}
            }
        }

        console.log('⚽ Real Match Data Integration v1.0.0 initialized!');
        console.log('🏈 Prioritizing 2. Bundesliga and Championship for immediate testing');
    </script>
    
    <!-- Post-Bet Tournament Selection Modal -->
    <div id="tournamentSelectionModal" class="league-modal" style="display: none;">
        <div class="league-modal-content">
            <div class="modal-header">
                <h3>🏆 Add Bet to Tournaments?</h3>
                <span class="close" onclick="closeTournamentSelection()">&times;</span>
            </div>
            <div class="modal-body">
                <div class="bet-summary">
                    <h4>Your Bet:</h4>
                    <div id="betSummaryContent"></div>
                </div>
                
                <div class="tournament-options">
                    <h4>Select Tournaments:</h4>
                    <div class="tournament-checkboxes" id="tournamentCheckboxes">
                        <!-- Dynamically populated -->
                    </div>
                    
                    <div class="weekly-bonus-info">
                        <div class="info-card">
                            <span class="info-icon">💰</span>
                            <div class="info-text">
                                <strong>Weekly Bonus Competitions</strong>
                                <p>Compete across all leagues for bonus coins every week!</p>
                            </div>
                            <label class="checkbox-label">
                                <input type="checkbox" id="weeklyBonusInclude" checked>
                                <span class="checkmark"></span>
                            </label>
                        </div>
                    </div>
                </div>
                
                <div class="modal-actions">
                    <button class="btn-secondary" onclick="skipTournaments()">Skip Tournaments</button>
                    <button class="btn-primary" onclick="addToSelectedTournaments()">Add to Tournaments</button>
                </div>
            </div>
        </div>
    </div>
    </div> <!-- Close mainApp div -->

    <script>
        // Multi-User Authentication and API Integration
        let currentUser = null;
        let userCoins = 1000; // Personal betting coins
        let leagueCoins = 1000; // Weekly league coins (reset each week)
        let currentLeague = null; // Preferred: league code
        let currentLeagueId = null; // Backing DB ID of current league (if online)
        let supabaseClient = null;
        let isOnlineMode = false;
        // Allow overriding API base (e.g., when serving frontend via static server but API runs elsewhere)
        // 1) URL param: ?api_base=http://host:port (or ?api=...)
        // 2) Global var (before script): window.API_BASE = 'http://host:port'
        try {
            const usp = new URLSearchParams(window.location.search);
            // Admin mode: show settle controls when ?admin=1
            try {
                const adminParam = usp.get('admin');
                if (adminParam !== null) {
                    window.IS_ADMIN = (adminParam === '1');
                    try { localStorage.setItem('admin_mode', window.IS_ADMIN ? '1' : '0'); } catch (_) {}
                } else {
                    const savedAdmin = localStorage.getItem('admin_mode');
                    window.IS_ADMIN = (savedAdmin === '1');
                }
            } catch (_) { window.IS_ADMIN = false; }
            // Admin token handling: load from storage or prompt once in admin mode
            try {
                const savedToken = localStorage.getItem('admin_token');
                if (savedToken) { window.ADMIN_TOKEN = savedToken; }
                if (window.IS_ADMIN && !window.ADMIN_TOKEN) {
                    const t = prompt('Admin token required to settle matches. Enter admin token:');
                    if (t && t.trim()) {
                        window.ADMIN_TOKEN = t.trim();
                        try { localStorage.setItem('admin_token', window.ADMIN_TOKEN); } catch (_) {}
                    }
                }
                // Expose helpers to manage token manually
                window.setAdminToken = function(token) {
                    window.ADMIN_TOKEN = token || '';
                    try { if (token) localStorage.setItem('admin_token', token); else localStorage.removeItem('admin_token'); } catch (_) {}
                    return true;
                };
                window.promptAdminToken = function() {
                    const t2 = prompt('Enter admin token');
                    if (t2 && t2.trim()) return window.setAdminToken(t2.trim());
                    return false;
                };
                window.clearAdminToken = function() {
                    window.ADMIN_TOKEN = '';
                    try { localStorage.removeItem('admin_token'); } catch (_) {}
                    return true;
                };
            } catch (_) { /* ignore token errors */ }
            const apiBaseParam = usp.get('api_base') || usp.get('api');
            if (apiBaseParam) {
                window.API_BASE = apiBaseParam;
                try { localStorage.setItem('api_base', apiBaseParam); } catch (_) {}
            } else {
                try {
                    const savedApi = localStorage.getItem('api_base');
                    if (savedApi) { window.API_BASE = savedApi; }
                } catch (_) { /* ignore */ }
            }
            // Using API_BASE as configured; no port self-heal
        } catch (e) {
            console.warn('API base param parse failed', e);
        }
        const API_BASE = window.API_BASE || window.location.origin;

        // Backend-backed final score provider hook for auto-fill
        // Uses a short-lived cache to avoid repeated network calls during scans
        (function(){
            if (typeof window.getFinalScoreHook === 'function') return; // don't override if app provided one
            let _cacheTs = 0;
            let _cache = null; // { [matchId]: { home, away } }
            const TTL_MS = 10000; // 10s
            // Per-ID small cache for the single-match endpoint
            const ID_TTL_MS = 7000; // 7s
            const _idCache = Object.create(null); // { [matchId]: { ts, val: {home, away} } }

            function _getIdCache(id) {
                const e = _idCache[String(id)];
                if (!e) return null;
                if ((Date.now() - e.ts) > ID_TTL_MS) return null;
                return e.val;
            }
            function _setIdCache(id, val) {
                _idCache[String(id)] = { ts: Date.now(), val };
            }
            async function fetchScoresOnce() {
                const now = Date.now();
                if (_cache && (now - _cacheTs) < TTL_MS) return _cache;
                try {
                    // Respect online/offline mode when available
                    if (typeof isOnlineMode !== 'undefined' && !isOnlineMode) return null;
                    const ctrl = new AbortController();
                    const to = setTimeout(() => ctrl.abort(), 2500);
                    const res = await fetch(`${API_BASE}/api/matches`, { signal: ctrl.signal });
                    clearTimeout(to);
                    if (!res || !res.ok) return null;
                    const data = await res.json();
                    const arr = (data && Array.isArray(data.matches)) ? data.matches : (Array.isArray(data) ? data : []);
                    const map = {};
                    for (const m of arr) {
                        try {
                            if (!m || !m.id) continue;
                            const st = String(m.status || '').toLowerCase();
                            const sc = m.score || {};
                            if (st === 'finished' && Number.isFinite(Number(sc.home)) && Number.isFinite(Number(sc.away))) {
                                map[String(m.id)] = { home: Number(sc.home), away: Number(sc.away) };
                            }
                        } catch (_) { /* ignore per-item */ }
                    }
                    _cache = map;
                    _cacheTs = now;
                    return _cache;
                } catch (_) {
                    return null;
                }
            }

            async function fetchSingleScore(matchId) {
                try {
                    // Respect online/offline mode when available
                    if (typeof isOnlineMode !== 'undefined' && !isOnlineMode) return null;
                    const cached = _getIdCache(matchId);
                    if (cached) return cached;
                    const ctrl = new AbortController();
                    const to = setTimeout(() => ctrl.abort(), 1500);
                    const url = `${API_BASE}/api/matches/${encodeURIComponent(String(matchId))}`;
                    const res = await fetch(url, { signal: ctrl.signal });
                    clearTimeout(to);
                    if (!res || !res.ok) return null;
                    const data = await res.json();
                    const m = data && (data.match || data);
                    if (!m || !m.id) return null;
                    const st = String(m.status || '').toLowerCase();
                    const sc = m.score || {};
                    if (st === 'finished' && Number.isFinite(Number(sc.home)) && Number.isFinite(Number(sc.away))) {
                        const val = { home: Number(sc.home), away: Number(sc.away) };
                        _setIdCache(matchId, val);
                        return val;
                    }
                    return null;
                } catch(_) { return null; }
            }

            window.getFinalScoreHook = async function({ matchId }){
                try {
                    if (!matchId) return null;
                    // 1) Try single-match endpoint first (fast, low payload)
                    const single = await fetchSingleScore(matchId);
                    if (single) return single;
                    // 2) Fallback to batch cache
                    const map = await fetchScoresOnce();
                    if (map && Object.prototype.hasOwnProperty.call(map, String(matchId))) return map[String(matchId)];
                    return null;
                } catch (_) {
                    return null;
                }
            };
        })();

        // Global coin display updater core (declared early so all code can safely call it)
        window._updateCoinDisplayCore = function () {
            const container = document.querySelector('.coins-display');
            if (!container) return;
            const coinsEl = container.querySelector('#coins');
            const coinsVal = (typeof window.getCurrentCoins === 'function')
                ? window.getCurrentCoins()
                : Number(window.coins ?? window.userCoins ?? 1000);
            if (coinsEl) {
                coinsEl.textContent = coinsVal;
            } else {
                container.textContent = `💰 ${coinsVal} coins`;
            }
        };

        // Current coins source-of-truth for display (league-only MVP)
        // Prefer league weekly coins when a league is active; fallback to personal/userCoins.
        window.getCurrentCoins = function () {
            try {
                if (window.currentLeague) {
                    return Number(window.leagueCoins ?? 0);
                }
                return Number(window.userCoins ?? window.coins ?? 0);
            } catch (_) {
                return 0;
            }
        };

        // Health check the API to auto-switch online/offline mode
        async function checkApiHealth() {
            try {
                const ctrl = new AbortController();
                const to = setTimeout(() => ctrl.abort(), 2500);
                const res = await fetch(`${API_BASE}/api/health`, { signal: ctrl.signal });
                clearTimeout(to);
                isOnlineMode = !!res && res.ok;
                console.log(`[health] ${API_BASE} => ${isOnlineMode ? 'online' : 'offline'}`);
            } catch (err) {
                isOnlineMode = false;
                console.warn('[health] offline (error)', err);
            }
        }

        // Initialize Socket.IO (Node backend) for live bet updates
        function initSocket() {
            try {
                if (!isOnlineMode) return; // only attempt when API is reachable
                const connect = () => {
                    if (window.socket || typeof io === 'undefined') {
                        if (typeof io === 'undefined') return; // script not loaded yet
                    }
                    try {
                        if (window.socket && window.socket.connected) return;
                        window.socket = io(API_BASE, { transports: ['websocket', 'polling'] });
                        window.socket.on('connect', () => console.log('🔌 Socket connected'));
                        window.socket.on('connect_error', (e) => console.warn('Socket connect_error', e && e.message));
                        window.socket.on('betPlaced', async (payload) => {
                            try {
                                const p = payload || {};
                                const u = p.user || {};
                                if (currentUser && u && (u.id === currentUser.id || u.userId === currentUser.id)) {
                                    currentUser = u;
                                    try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                                    if (typeof window.setCurrentCoins === 'function' && typeof u.coins !== 'undefined') {
                                        window.setCurrentCoins(Number(u.coins));
                                    }
                                    if (typeof updateUserUI === 'function') updateUserUI();
                                    if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                                }
                                if (window.betslipViewMode === 'open' && typeof window.loadOpenBetsInline === 'function') {
                                    await window.loadOpenBetsInline();
                                }
                            } catch (_) {}
                        });
                        window.socket.on('betSettled', async (payload) => {
                            try {
                                const p = payload || {};
                                const u = p.user || {};
                                // If the event concerns the current user, sync coins and UI
                                if (currentUser && u && (u.id === currentUser.id || u.userId === currentUser.id)) {
                                    currentUser = u;
                                    try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                                    if (typeof window.setCurrentCoins === 'function' && typeof u.coins !== 'undefined') {
                                        window.setCurrentCoins(Number(u.coins));
                                    }
                                    if (typeof updateUserUI === 'function') updateUserUI();
                                    if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                                }
                                if (window.betslipViewMode === 'open' && typeof window.loadOpenBetsInline === 'function') {
                                    await window.loadOpenBetsInline();
                                }
                                if (window.betslipViewMode === 'recent' && typeof window.loadRecentBetsInline === 'function') {
                                    await window.loadRecentBetsInline();
                                }
                            } catch (e) {
                                console.warn('betSettled handler failed', e);
                            }
                        });
                    } catch (e) {
                        console.warn('Socket init failed', e);
                    }
                };
                // Load socket.io client from API_BASE if not present
                if (typeof io === 'undefined') {
                    const s = document.createElement('script');
                    s.src = `${API_BASE}/socket.io/socket.io.js`;
                    s.async = true;
                    s.onload = () => connect();
                    s.onerror = () => console.warn('Failed to load socket.io client script');
                    document.head.appendChild(s);
                } else {
                    connect();
                }
            } catch (e) {
                console.warn('initSocket error', e);
            }
        }

        
        // Initialize Supabase if available
        async function initializeSupabase() {
            try {
                if (window.supabaseConfig && window.supabaseConfig.supabase) {
                    supabaseClient = window.supabaseConfig.supabase;
                    isOnlineMode = true;
                    console.log('✅ Online mode enabled with Supabase');
                    
                    // Check for existing session
                    const { data: { session } } = await supabaseClient.auth.getSession();
                    if (session) {
                        await handleSupabaseSession(session.user);
                    }
                    return true;
                }
            } catch (error) {
                console.error('Supabase init error:', error);
            }
            console.log('📴 Running in offline/demo mode');
            isOnlineMode = false;
            return false;
        }
        
        // Handle Supabase session
        async function handleSupabaseSession(user) {
            if (!user || !supabaseClient) return;
            
            try {
                // Fetch user profile
                const { data: profile } = await supabaseClient
                    .from('users')
                    .select('*')
                    .eq('id', user.id)
                    .single();
                
                if (profile) {
                    const userObj = {
                        id: user.id,
                        username: profile.username || (user.email || '').split('@')[0] || 'User',
                        coins: (typeof profile.coins !== 'undefined') ? Number(profile.coins) : 1000,
                        email: user.email || null,
                        joinedAt: profile.created_at || new Date().toISOString()
                    };
                    currentUser = userObj;
                    userCoins = userObj.coins;
                    try { localStorage.setItem('scoreLeagueUser', JSON.stringify(userObj)); } catch (_) {}
                    
                    // Ensure a private league and membership exist, and load weekly balance
                    try {
                        await ensurePrivateLeague();
                    } catch (e) {
                        console.warn('ensurePrivateLeague failed', e);
                    }

                    // Sync coins to UI state
                    if (typeof window.setCurrentCoins === 'function') {
                        window.setCurrentCoins(userCoins);
                    } else {
                        window.coins = userCoins;
                    }

                    // Hide login and show main app
                    const authEl = document.getElementById('authScreen');
                    if (authEl) authEl.style.display = 'none';
                    const mainEl = document.getElementById('mainApp');
                    if (mainEl) { mainEl.style.display = 'block'; mainEl.classList.remove('hidden'); }
                    
                    // Update UI and load data
                    updateUserUI();
                    updateCoinDisplay();
                    showTab('matches');
                    try { loadMatches(); } catch (e) { console.warn('loadMatches failed', e); }
                }
            } catch (error) {
                console.error('Session error:', error);
            }
        }

        // Authentication Functions
        async function login() {
            const username = document.getElementById('usernameInput').value.trim();
            const password = document.getElementById('passwordInput')?.value || '';
            
            if (!username) {
                alert('Please enter a username');
                return;
            }
            
            // Check if online mode with Supabase
            if (isOnlineMode && supabaseClient && password) {
                try {
                    // Try to sign in with email (username@scoreleague.com) and password
                    const email = username.includes('@') ? username : `${username}@scoreleague.com`;
                    const { data, error } = await supabaseClient.auth.signInWithPassword({
                        email,
                        password
                    });
                    
                    if (error) {
                        // If login fails, try to create new account
                        const { data: signupData, error: signupError } = await supabaseClient.auth.signUp({
                            email,
                            password,
                            options: {
                                data: { username }
                            }
                        });
                        
                        if (signupError) {
                            alert('Login failed: ' + signupError.message);
                            return;
                        }
                        
                        // Create user profile
                        await supabaseClient.from('users').insert({
                            id: signupData.user.id,
                            username,
                            coins: 1000
                        });
                        
                        await handleSupabaseSession(signupData.user);
                    } else {
                        await handleSupabaseSession(data.user);
                    }
                    return;
                } catch (error) {
                    console.error('Online login error:', error);
                    // Fall back to offline mode
                }
            }

            // If online but no Supabase, use Node server auth
            if (isOnlineMode && (!supabaseClient || !password)) {
                try {
                    const res = await fetch(`${API_BASE}/api/auth/login`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ username })
                    });
                    const data = await res.json();
                    if (!res.ok || !data || !data.user) {
                        throw new Error(data?.error || 'Login failed');
                    }
                    currentUser = data.user;
                    try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                    // Ensure we do not accidentally take Supabase branches in Node mode
                    try {
                        supabaseClient = null;
                        window.supabaseClient = null;
                        window.SCORELEAGUE_MODE = 'node';
                        console.log('[login] Node mode active: disabled Supabase client');
                    } catch (_) {}
                    
                    // Hide login and show main app
                    const authEl = document.getElementById('authScreen');
                    if (authEl) authEl.style.display = 'none';
                    const mainEl = document.getElementById('mainApp');
                    if (mainEl) { mainEl.style.display = 'block'; mainEl.classList.remove('hidden'); }
                    
                    updateUserUI();
                    updateCoinDisplay();
                    showTab('matches');
                    try { await loadMatches(); } catch (e) { console.warn('loadMatches failed', e); }
                    return;
                } catch (e) {
                    console.error('Node login error:', e);
                    // Fall back to offline mode
                }
            }

            // Offline/demo mode - no API required
            const userData = {
                id: Date.now().toString(),
                username: username,
                coins: 1000,
                joinedAt: new Date().toISOString(),
                stats: {
                    totalBets: 0,
                    wins: 0,
                    losses: 0,
                    winRate: 0
                }
            };
            
            currentUser = userData;
            // Use global variables that were already initialized
            window.betSlip = window.betSlip || [];
            window.coins = window.coins || 1000;
            window.currentBettingMode = window.currentBettingMode || 'personal'; // 'personal' or league ID
            
            // Store user session
            localStorage.setItem('scoreLeagueUser', JSON.stringify(userData));
            
            // Hide auth screen and show main app
            document.getElementById('authScreen').style.display = 'none';
            const mainAppEl = document.getElementById('mainApp');
            if (mainAppEl) { mainAppEl.style.display = 'block'; mainAppEl.classList.remove('hidden'); }
            
            // Update UI with user data
            updateUserUI();
            
            // Load matches and initialize app
            await loadMatches();
            
            console.log('✅ User authenticated:', userData.username);
        }

        async function placeBetsOnline() {
            if (!currentUser) {
                alert('Please log in first');
                return;
            }
            
            if (selectedBets.length === 0) {
                alert('Please select at least one bet');
                return;
            }
            
            const bettingMode = document.querySelector('input[name="betting-mode"]:checked')?.value || 'personal';
            const isLeagueBet = bettingMode === 'league';
            
            // Calculate total stake based on bet type
            let totalStake = 0;
            let totalOdds = 1;
            
            if (betType === 'single') {
                // For single bets, sum all individual stakes
                selectedBets.forEach(bet => {
                    const stakeInput = document.querySelector(`#stake-${bet.matchId}-${bet.betType}-${bet.selection}`);
                    const stake = parseFloat(stakeInput?.value) || 0;
                    totalStake += stake;
                });
            } else {
                // For combination bet, use the single stake input
                const combiStakeInput = document.querySelector('.combi-stake-input');
                totalStake = parseFloat(combiStakeInput?.value) || 0;
                
                // Calculate combined odds
                selectedBets.forEach(bet => {
                    totalOdds *= bet.odds;
                });
            }
            
            // Check which coin balance to use
            const availableCoins = isLeagueBet ? leagueCoins : userCoins;
            
            if (totalStake > availableCoins) {
                alert(`Insufficient ${isLeagueBet ? 'league' : 'personal'} coins! You have ${availableCoins} coins.`);
                return;
            }
            
            if (totalStake <= 0) {
                alert('Please enter a valid stake amount');
                return;
            }
            
            // Process the bets
            const betData = {
                user: currentUser,
                selections: selectedBets,
                totalStake: totalStake,
                totalOdds: betType === 'combi' ? totalOdds : 0,
                potentialWin: betType === 'combi' ? totalStake * totalOdds : 
                             selectedBets.reduce((sum, bet) => {
                                 const stakeInput = document.querySelector(`#stake-${bet.matchId}-${bet.betType}-${bet.selection}`);
                                 const stake = parseFloat(stakeInput?.value) || 0;
                                 return sum + (stake * bet.odds);
                             }, 0),
                betType: betType,
                timestamp: new Date().toISOString(),
                isLeagueBet: isLeagueBet,
                leagueId: isLeagueBet ? currentLeague : null,
                remainingCoins: availableCoins - totalStake
            };
            
            // Save to Supabase if online
            if (isOnlineMode && supabaseClient) {
                const savedBet = await saveBetToSupabase(betData);
                if (savedBet) {
                    console.log('✅ Bet saved to Supabase:', savedBet);
                    // Update leaderboard if it's a league bet
                    if (isLeagueBet) {
                        await updateLeaderboard();
                    }
                }
            }
            
            // Deduct coins
            if (isLeagueBet) {
                leagueCoins -= totalStake;
            } else {
                userCoins -= totalStake;
            }
            
            // Update display
            updateCoinDisplay();
                    showTab('matches');
            
            // Save to local storage as fallback
            let allBets = JSON.parse(localStorage.getItem('userBets')) || [];
            allBets.push(betData);
            localStorage.setItem('userBets', JSON.stringify(allBets));
            
            // Clear bet slip
            selectedBets = [];
            updateBetSlip();
            
            // Show success message
            showNotification(`✅ Bet${selectedBets.length > 1 ? 's' : ''} placed successfully!
                ${isLeagueBet ? '🏆 League bet' : '💰 Personal bet'}: ${totalStake} coins
                Potential win: ${Math.round(betData.potentialWin)} coins`, 'success');
            
            // Do not switch to My Bets tab (hidden in MVP). Stay on matches.
            if (typeof showTab === 'function') {
                showTab('matches');
            }
        }

        // Check for existing session on page load
        async function checkExistingSession() {
            const storedUser = localStorage.getItem('scoreLeagueUser');
            if (storedUser) {
                // Parse stored user JSON to object
                try {
                    currentUser = JSON.parse(storedUser);
                    // Auto re-authenticate to hydrate missing user id if username is present
                    try {
                        if (currentUser && !currentUser.id && currentUser.username && typeof API_BASE !== 'undefined') {
                            const res = await fetch(`${API_BASE}/api/auth/login`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ username: currentUser.username })
                            });
                            const data = await res.json().catch(() => ({}));
                            if (res.ok && data && (data.user || data.id)) {
                                currentUser = data.user || data;
                                try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                            }
                        }
                    } catch (_) { /* ignore best-effort */ }
                } catch (e) {
                    console.warn('Failed to parse stored user, clearing session');
                    localStorage.removeItem('scoreLeagueUser');
                    document.getElementById('authScreen').style.display = 'flex';
                    document.getElementById('mainApp').style.display = 'none';
                    document.getElementById('mainApp').classList.add('hidden');
                    return;
                }
                userCoins = parseInt(localStorage.getItem('userCoins')) || 1000;
                leagueCoins = parseInt(localStorage.getItem('leagueCoins')) || 1000;
                currentLeague = localStorage.getItem('currentLeague');
                currentLeagueId = localStorage.getItem('currentLeagueId') || null;
                console.log('Restored session for:', currentUser);
                // Auto-login with stored user
                document.getElementById('authScreen').style.display = 'none';
                document.getElementById('mainApp').style.display = 'block';
                document.getElementById('mainApp').classList.remove('hidden');
                updateCoinDisplay();
                showTab('matches');
                updateUserUI();
                try { loadMatches(); } catch (e) { console.warn('loadMatches failed', e); }
                // Ensure private league and sync membership coins when online
                try {
                    if (isOnlineMode && supabaseClient && typeof ensurePrivateLeague === 'function') {
                        await ensurePrivateLeague();
                    }
                } catch (e) {
                    console.warn('ensurePrivateLeague on session restore failed', e);
                }
            } else {
                // Show login screen if no session
                document.getElementById('authScreen').style.display = 'flex';
                document.getElementById('mainApp').style.display = 'none';
            }
        }

        // Coin display updater - globally accessible wrapper (calls the single source of truth)
        function updateCoinDisplay() {
            if (typeof window._updateCoinDisplayCore === 'function') {
                window._updateCoinDisplayCore();
            }
        }

        // Update UI with user information
        function updateUserUI() {
            if (currentUser) {
                try {
                    if (typeof currentUser.coins !== 'undefined') {
                        if (typeof window.setCurrentCoins === 'function') {
                            window.setCurrentCoins(Number(currentUser.coins));
                        } else {
                            window.coins = Number(currentUser.coins);
                        }
                    }
                } catch (_) { /* ignore */ }
                window.updateCoinDisplay();
                
                    showTab('matches');
                // Update any user-specific elements
                console.log('UI updated for user:', currentUser.username);
            }
        }

        // Load matches from server
        async function loadMatches() {
            try {
                const response = await fetch(`${API_BASE}/api/matches`);
                if (!response.ok) {
                    console.warn('Failed to load matches from server, using fallback');
                    return renderFallbackMatches();
                }
                const data = await response.json();
                const raw = Array.isArray(data) ? data : (data.matches || data.data || []);
                // If backend returned no matches, do not override fallback/real renders
                if (!Array.isArray(raw) || raw.length === 0) {
                    console.warn('No matches from server, using fallback');
                    return renderFallbackMatches();
                }
                // Normalize Node server format (markets -> odds)
                const normalized = (Array.isArray(raw) ? raw : []).map(m => {
                    if (m && !m.odds && m.markets && m.markets['1x2']) {
                        return {
                            ...m,
                            odds: {
                                home: Number(m.markets['1x2']['1']?.odds) || 0,
                                draw: Number(m.markets['1x2']['X']?.odds) || 0,
                                away: Number(m.markets['1x2']['2']?.odds) || 0
                            }
                        };
                    }
                    return m;
                });
                renderMatches(normalized);
            } catch (error) {
                console.error('Error loading matches:', error);
                renderFallbackMatches();
            }
        }

        // Render matches in the UI
        function renderMatches(matches) {
            const container = document.getElementById('matches-container');
            if (!container) return;
            const __gate = beginRender('node');
            if (!__gate.allowed) return;
            const __savedAdminInputs = mergeAdminSavedInputs(captureAdminInputs());
            const __activeAdminElId = captureActiveAdminElement();
            // Build a quick index for match metadata so other views (like Open Bets) can resolve team names
            try {
                const idx = {};
                (Array.isArray(matches) ? matches : []).forEach(m => {
                    if (m && m.id) idx[m.id] = m;
                });
                window.matchIndex = idx;
            } catch (_) { /* non-fatal */ }

            container.innerHTML = matches.map(match => `
                <div class="match-card real-match" data-match-id="${match.id}" data-status="${match.status || ''}" data-home-team="${match.homeTeam}" data-away-team="${match.awayTeam}">
                    <div class="match-header">
                        <div class="match-time">${match.date}</div>
                        <div class="league-badge">${match.league}</div>
                    </div>
                    <div class="teams">
                        <div class="team">
                            <div class="team-name">${match.homeTeam}</div>
                        </div>
                        <div class="vs">VS</div>
                        <div class="team">
                            <div class="team-name">${match.awayTeam}</div>
                        </div>
                    </div>
                    <div class="betting-markets">
                        <div class="market">
                            <div class="market-title">Match Result (1X2)</div>
                            <div class="market-odds">
                                <button class="odds-button" onclick="toggleBet('${match.id}-1', '${match.homeTeam} vs ${match.awayTeam}', '${match.homeTeam} Win', ${match.odds.home}, this)">
                                    1 (${match.odds.home})
                                </button>
                                <button class="odds-button" onclick="toggleBet('${match.id}-x', '${match.homeTeam} vs ${match.awayTeam}', 'Draw', ${match.odds.draw}, this)">
                                    X (${match.odds.draw})
                                </button>
                                <button class="odds-button" onclick="toggleBet('${match.id}-2', '${match.homeTeam} vs ${match.awayTeam}', '${match.awayTeam} Win', ${match.odds.away}, this)">
                                    2 (${match.odds.away})
                                </button>
                            </div>
                        </div>
                        <div class="market">
                            <div class="market-title">Doppelte Chance</div>
                            <div class="market-odds">
                                <button class="odds-button" onclick="toggleBet('${match.id}-1x', '${match.homeTeam} vs ${match.awayTeam}', '${match.homeTeam} oder Unentschieden', ${(1/((1/Number(match.odds.home)) + (1/Number(match.odds.draw)))).toFixed(2)}, this)">
                                    1X (${(1/((1/Number(match.odds.home)) + (1/Number(match.odds.draw)))).toFixed(2)})
                                </button>
                                <button class="odds-button" onclick="toggleBet('${match.id}-12', '${match.homeTeam} vs ${match.awayTeam}', '${match.homeTeam} oder ${match.awayTeam}', ${(1/((1/Number(match.odds.home)) + (1/Number(match.odds.away)))).toFixed(2)}, this)">
                                    12 (${(1/((1/Number(match.odds.home)) + (1/Number(match.odds.away)))).toFixed(2)})
                                </button>
                                <button class="odds-button" onclick="toggleBet('${match.id}-x2', '${match.homeTeam} vs ${match.awayTeam}', 'Unentschieden oder ${match.awayTeam}', ${(1/((1/Number(match.odds.draw)) + (1/Number(match.odds.away)))).toFixed(2)}, this)">
                                    X2 (${(1/((1/Number(match.odds.draw)) + (1/Number(match.odds.away)))).toFixed(2)})
                                </button>
                            </div>
                        </div>
                    </div>
                    ${window.IS_ADMIN ? `
                    <div class="admin-settle" style="margin-top:8px; padding-top:8px; border-top:1px dashed #ccc;">
                        <div style="font-weight:600; font-size:12px; margin-bottom:6px;">Admin: Final Score & Settle</div>
                        <div style="display:flex; align-items:center; gap:6px;">
                            <input id="settle-home-${safeId(match.id)}" type="number" min="0" placeholder="${match.homeTeam} goals" style="width:60px; padding:4px;" />
                            <span>:</span>
                            <input id="settle-away-${safeId(match.id)}" type="number" min="0" placeholder="${match.awayTeam} goals" style="width:60px; padding:4px;" />
                            <button id="settle-btn-${safeId(match.id)}" class="odds-button" style="padding:6px 10px;" onclick="adminSettleForCard('${match.id}')">Settle</button>
                        </div>
                    </div>` : ''}
                </div>
            `).join('');
            window._lastRender = { source: 'node', data: (Array.isArray(matches) ? matches.slice() : matches) };
            restoreAdminInputs(__savedAdminInputs);
            restoreActiveAdminElement(__activeAdminElId);
            try { scheduleAutoFillScan(); } catch (_) {}
        }

        // Save a single bet slip to Supabase (schema-aligned)
        async function saveSlipToSupabase({ totalStake, totalOdds, potentialWin, leagueId }) {
            if (!supabaseClient || !isOnlineMode) return null;
            try {
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (!user) return null;
                const insertObj = {
                    user_id: user.id,
                    total_stake: Math.round(Number(totalStake) || 0),
                    total_odds: Number(totalOdds || 0).toFixed(2),
                    potential_win: Math.round(Number(potentialWin) || 0),
                    status: 'pending'
                };
                if (leagueId) insertObj.league_id = leagueId;
                const { data: slip, error } = await supabaseClient
                    .from('bet_slips')
                    .insert(insertObj)
                    .select()
                    .single();
                if (error) throw error;
                return slip;
            } catch (e) {
                console.error('saveSlipToSupabase error:', e);
                return null;
            }
        }
        
        // Compatibility wrapper: older code may call saveBetToSupabase(betData)
        // We map it to a single slip insert using provided totals
        async function saveBetToSupabase(betData) {
            try {
                const totalStake = Math.round(Number(betData?.totalStake) || 0);
                const rawOdds = Number(betData?.totalOdds || 1);
                const totalOdds = (isFinite(rawOdds) && rawOdds > 0) ? rawOdds : 1;
                const potentialWin = Math.round(Number(betData?.potentialWin) || (totalStake * totalOdds));
                const leagueId = betData?.isLeagueBet ? (betData?.leagueId || null) : null;
                return await saveSlipToSupabase({ totalStake, totalOdds, potentialWin, leagueId });
            } catch (e) {
                console.error('saveBetToSupabase wrapper error:', e);
                return null;
            }
        }

        // Map a betId suffix to a normalized selection code for DB (home/draw/away, 1x/12/x2, over/under, yes/no)
        function getBetSelectionCode(betId) {
            const parts = String(betId || '').split('-');
            const last = (parts[parts.length - 1] || '').toLowerCase();
            const prev = (parts[parts.length - 2] || '').toLowerCase();
            if (last === '1') return 'home';
            if (last === 'x') return 'draw';
            if (last === '2') return 'away';
            if (['1x', '12', 'x2', 'over', 'under'].includes(last)) return last;
            if (prev === 'btts' && (last === 'yes' || last === 'no')) return last;
            return last || 'other';
        }

        // Insert bet selections for a given slip into bet_slip_items
        async function insertBetSlipItems(slipId, bets) {
            if (!isOnlineMode || !supabaseClient) return;
            if (!slipId || !Array.isArray(bets) || bets.length === 0) return;
            try {
                const rows = bets.map(b => {
                    const matchStr = String(b.match || '');
                    const [home, away] = matchStr.split(' vs ');
                    return {
                        bet_slip_id: slipId,
                        home_team: home || null,
                        away_team: away || null,
                        bet_type: getBetSelectionCode(b.id),
                        odds: Number(b.odds || 1)
                    };
                });
                const { error } = await supabaseClient
                    .from('bet_slip_items')
                    .insert(rows);
                if (error) console.error('insertBetSlipItems error:', error);
            } catch (e) {
                console.error('insertBetSlipItems exception:', e);
            }
        }
        
        async function updateLeaderboard() {
            if (!supabaseClient || !isOnlineMode) return;
            try {
                const { error } = await supabaseClient.rpc('refresh_leaderboard_cache');
                if (error) console.error('Leaderboard RPC error:', error);
            } catch (error) {
                console.error('Error updating leaderboard via RPC:', error);
            }
        }

        // Settle a bet slip and credit winnings to league membership weekly coins
        // Usage: await window.gradeSlip(slipId, 'won' | 'lost')
        async function gradeSlip(slipId, result) {
            if (!isOnlineMode || !supabaseClient) {
                alert('Abrechnung nur im Online-Modus möglich.');
                return { success: false, error: 'offline' };
            }
            if (!slipId || !['won', 'lost'].includes(String(result))) {
                alert('Ungültige Parameter für gradeSlip');
                return { success: false, error: 'bad_params' };
            }
            try {
                // Fetch slip
                const { data: slip, error: slipErr } = await supabaseClient
                    .from('bet_slips')
                    .select('id, status, total_stake, total_odds, potential_win, user_id, league_id')
                    .eq('id', slipId)
                    .single();
                if (slipErr || !slip) throw new Error('Bet-Slip nicht gefunden');

                // Prevent double-settlement
                const currentStatus = String(slip.status || 'pending').toLowerCase();
                if (currentStatus !== 'pending') {
                    alert('Dieser Schein wurde bereits abgerechnet.');
                    return { success: false, error: 'already_settled' };
                }

                // Update slip status
                const { error: updErr } = await supabaseClient
                    .from('bet_slips')
                    .update({ status: String(result) })
                    .eq('id', slipId);
                if (updErr) throw updErr;

                let credited = 0;
                if (String(result) === 'won') {
                    // Compute payout (stake * odds) or use potential_win
                    const stake = Math.round(Number(slip.total_stake || 0));
                    const odds = Number(slip.total_odds || 1);
                    const payout = Math.round(Number(slip.potential_win || 0) || (stake * (isFinite(odds) && odds > 0 ? odds : 1)));

                    // Load membership and credit weekly_coins and total_earnings
                    const { data: member, error: memErr } = await supabaseClient
                        .from('league_members')
                        .select('id, weekly_coins, total_earnings')
                        .eq('league_id', slip.league_id)
                        .eq('user_id', slip.user_id)
                        .single();
                    if (memErr || !member) throw new Error('League-Mitgliedschaft nicht gefunden');

                    const newCoins = Math.max(0, Math.round(Number(member.weekly_coins || 0)) + payout);
                    const newEarnings = Math.max(0, Math.round(Number(member.total_earnings || 0)) + payout);
                    const { error: credErr } = await supabaseClient
                        .from('league_members')
                        .update({ weekly_coins: newCoins, total_earnings: newEarnings })
                        .eq('id', member.id);
                    if (credErr) throw credErr;
                    credited = payout;

                    // If this is the logged-in user's active league, sync local UI state
                    try {
                        const { data: { user } } = await supabaseClient.auth.getUser();
                        if (user && user.id === slip.user_id && currentLeagueId && slip.league_id === currentLeagueId) {
                            leagueCoins = newCoins;
                            try { localStorage.setItem('leagueCoins', String(leagueCoins)); } catch (_) {}
                            if (typeof updateCoinDisplay === 'function') updateCoinDisplay();
                        }
                    } catch (_) { /* ignore UI sync errors */ }
                }

                // Refresh leaderboard cache
                try { await updateLeaderboard(); } catch (_) { /* non-fatal */ }

                return { success: true, credited };
            } catch (e) {
                console.error('gradeSlip error:', e);
                alert('Fehler bei der Abrechnung: ' + (e?.message || e));
                return { success: false, error: e?.message || String(e) };
            }
        }
        // Expose globally for admin/testing
        window.gradeSlip = gradeSlip;
        
        function getWeekNumber() {
            const now = new Date();
            const start = new Date(now.getFullYear(), 0, 1);
            const diff = now - start;
            const oneWeek = 1000 * 60 * 60 * 24 * 7;
            return Math.floor(diff / oneWeek) + 1;
        }
        
        // League Management Functions
        async function createLeague(leagueName) {
            if (!supabaseClient || !isOnlineMode) {
                // Offline mode - create local league
                const leagueCode = generateLeagueCode();
                currentLeague = leagueCode;
                localStorage.setItem('currentLeague', leagueCode);
                localStorage.setItem(`league_${leagueCode}`, JSON.stringify({
                    name: leagueName,
                    code: leagueCode,
                    created: new Date().toISOString(),
                    members: [currentUser]
                }));
                return { success: true, code: leagueCode };
            }
            
            try {
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (!user) return { success: false, error: 'Not authenticated' };
                
                const leagueCode = generateLeagueCode();
                
                // Create league in database
                const { data: league, error: leagueError } = await supabaseClient
                    .from('leagues')
                    .insert({
                        name: leagueName,
                        code: leagueCode,
                        created_by: user.id,
                        weekly_coins: 1000,
                        is_active: true,
                        created_at: new Date().toISOString()
                    })
                    .select()
                    .single();
                
                if (leagueError) throw leagueError;
                
                // Add creator as first member
                const { error: memberError } = await supabaseClient
                    .from('league_members')
                    .insert({
                        league_id: league.id,
                        user_id: user.id,
                        username: (currentUser && currentUser.username) ? currentUser.username : (user.email || 'User'),
                        weekly_coins: 1000,
                        total_earnings: 0,
                        is_active: true,
                        joined_at: new Date().toISOString()
                    });
                
                if (memberError) throw memberError;
                
                currentLeague = leagueCode;
                currentLeagueId = league.id;
                leagueCoins = 1000;
                try {
                    localStorage.setItem('currentLeague', leagueCode);
                    localStorage.setItem('currentLeagueId', String(league.id));
                    localStorage.setItem('leagueCoins', String(leagueCoins));
                } catch (_) {}
                
                return { success: true, code: leagueCode };
            } catch (error) {
                console.error('Error creating league:', error);
                return { success: false, error: error.message };
            }
        }
        
        async function joinLeague(leagueCode) {
            if (!leagueCode) return { success: false, error: 'Invalid league code' };
            
            if (!supabaseClient || !isOnlineMode) {
                // Offline mode
                currentLeague = leagueCode;
                localStorage.setItem('currentLeague', leagueCode);
                return { success: true };
            }
            
            try {
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (!user) return { success: false, error: 'Not authenticated' };
                
                // Find league by code
                const { data: league, error: leagueError } = await supabaseClient
                    .from('leagues')
                    .select('*')
                    .eq('code', leagueCode)
                    .eq('is_active', true)
                    .single();
                
                if (leagueError || !league) {
                    return { success: false, error: 'League not found' };
                }
                
                // Check if already a member
                const { data: existingMember } = await supabaseClient
                    .from('league_members')
                    .select('*')
                    .eq('league_id', league.id)
                    .eq('user_id', user.id)
                    .single();
                
                if (existingMember) {
                    // Update existing membership
                    await supabaseClient
                        .from('league_members')
                        .update({ is_active: true })
                        .eq('id', existingMember.id);
                } else {
                    // Add as new member
                    await supabaseClient
                        .from('league_members')
                        .insert({
                            league_id: league.id,
                            user_id: user.id,
                            username: (currentUser && currentUser.username) ? currentUser.username : (user.email || 'User'),
                            weekly_coins: 1000,
                            total_earnings: 0,
                            is_active: true,
                            joined_at: new Date().toISOString()
                        });
                }
                
                currentLeague = leagueCode;
                currentLeagueId = league.id;
                leagueCoins = 1000;
                try {
                    localStorage.setItem('currentLeague', leagueCode);
                    localStorage.setItem('currentLeagueId', String(league.id));
                    localStorage.setItem('leagueCoins', String(leagueCoins));
                } catch (_) {}
                
                return { success: true, leagueName: league.name };
            } catch (error) {
                console.error('Error joining league:', error);
                return { success: false, error: error.message };
            }
        }

        // Ensure a private league exists for the current user, join/create if needed, and load weekly balance
        async function ensurePrivateLeague() {
            if (!supabaseClient || !isOnlineMode || !currentUser) return { success: false };
            try {
                const { data: { user } } = await supabaseClient.auth.getUser();
                if (!user) return { success: false, error: 'Not authenticated' };

                // If already cached, verify membership exists; otherwise proceed
                if (currentLeagueId) {
                    try {
                        const { data: member } = await supabaseClient
                            .from('league_members')
                            .select('id, weekly_coins, league_id, leagues (code, is_active)')
                            .eq('user_id', user.id)
                            .eq('league_id', currentLeagueId)
                            .eq('is_active', true)
                            .single();
                        if (member) {
                            leagueCoins = Number(member.weekly_coins || 0);
                            try { localStorage.setItem('leagueCoins', String(leagueCoins)); } catch (_) {}
                            if (!currentLeague && member.leagues && member.leagues.code) {
                                currentLeague = member.leagues.code;
                                try { localStorage.setItem('currentLeague', currentLeague); } catch (_) {}
                            }
                            updateCoinDisplay();
                            return { success: true, leagueId: currentLeagueId };
                        }
                    } catch (_) { /* fallback to discovery */ }
                }

                // Discover an active membership (prefer most recent)
                const { data: existing, error: existErr } = await supabaseClient
                    .from('league_members')
                    .select('id, weekly_coins, league_id, leagues (id, code, is_active)')
                    .eq('user_id', user.id)
                    .eq('is_active', true)
                    .order('joined_at', { ascending: false })
                    .limit(1)
                    .single();
                if (!existErr && existing && existing.league_id) {
                    currentLeagueId = existing.league_id;
                    leagueCoins = Number(existing.weekly_coins || 0);
                    const code = existing.leagues && existing.leagues.code ? existing.leagues.code : null;
                    if (code) currentLeague = code;
                    try {
                        localStorage.setItem('currentLeagueId', String(currentLeagueId));
                        if (currentLeague) localStorage.setItem('currentLeague', currentLeague);
                        localStorage.setItem('leagueCoins', String(leagueCoins));
                    } catch (_) {}
                    updateCoinDisplay();
                    return { success: true, leagueId: currentLeagueId };
                }

                // Create a new private league for the user
                const privateName = (currentUser && currentUser.username) ? `${currentUser.username}'s League` : 'Private League';
                const created = await createLeague(privateName);
                if (created && created.success) {
                    updateCoinDisplay();
                    return { success: true, leagueId: currentLeagueId };
                }
                return { success: false, error: 'Failed to create or join a league' };
            } catch (e) {
                console.warn('ensurePrivateLeague error', e);
                return { success: false, error: e.message };
            }
        }
        
        async function fetchLeagueLeaderboard() {
            // Require a league context to fetch anything meaningful
            if (!currentLeague && !currentLeagueId) {
                return [
                    { username: (currentUser && currentUser.username) ? currentUser.username : 'Ich', coins_earned: 250, bets_won: 3, rank: 1 },
                    { username: 'Player2', coins_earned: 180, bets_won: 2, rank: 2 },
                    { username: 'Player3', coins_earned: 120, bets_won: 2, rank: 3 }
                ];
            }
            
            // Node backend mode (online but no Supabase client)
            if (isOnlineMode && (!supabaseClient || !supabaseClient.from)) {
                try {
                    const lid = currentLeagueId || currentLeague;
                    const res = await fetch(`${API_BASE}/api/leagues/${lid}/leaderboard`);
                    if (res.ok) {
                        const data = await res.json();
                        const list = Array.isArray(data?.leaderboard) ? data.leaderboard : (Array.isArray(data) ? data : []);
                        return list.map((entry, index) => ({
                            username: entry.username || entry.name || `User ${index + 1}`,
                            coins_earned: Number(entry.leagueStats?.winnings ?? entry.stats?.totalWinnings ?? entry.coins ?? 0),
                            bets_won: Number(entry.leagueStats?.bets ?? entry.stats?.betsWon ?? 0),
                            rank: index + 1
                        }));
                    }
                } catch (error) {
                    console.error('Error fetching Node leaderboard:', error);
                }
                return [];
            }
            
            // Supabase mode
            if (supabaseClient) {
                try {
                    const weekNumber = getWeekNumber();
                    const { data: leaderboard, error } = await supabaseClient
                        .from('leaderboard_cache')
                        .select(`
                            *,
                            users (username)
                        `)
                        .eq('league_id', currentLeagueId || currentLeague)
                        .eq('week_number', weekNumber)
                        .order('coins_earned', { ascending: false })
                        .limit(10);
                    if (error) throw error;
                    return leaderboard?.map((entry, index) => ({
                        username: entry.users?.username || 'Unknown',
                        coins_earned: entry.coins_earned || 0,
                        bets_won: entry.bets_won || 0,
                        rank: index + 1
                    })) || [];
                } catch (error) {
                    console.error('Error fetching Supabase leaderboard:', error);
                    return [];
                }
            }
            
            // Offline/demo fallback
            return [
                { username: (currentUser && currentUser.username) ? currentUser.username : 'Ich', coins_earned: 250, bets_won: 3, rank: 1 },
                { username: 'Player2', coins_earned: 180, bets_won: 2, rank: 2 },
                { username: 'Player3', coins_earned: 120, bets_won: 2, rank: 3 }
            ];
        }
        
        function generateLeagueCode() {
            const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789';
            let code = '';
            for (let i = 0; i < 6; i++) {
                code += chars.charAt(Math.floor(Math.random() * chars.length));
            }
            return code;
        }
        
        async function placeBetsMultiUser() {
            if (!currentUser) {
                alert('Please log in to place bets');
                return;
            }

            if (!window.betSlip || window.betSlip.length === 0) {
                alert('Please select at least one bet');
                return;
            }

            const singlesSum = (Array.isArray(window.betSlip) ? window.betSlip : []).reduce((sum, bet) => sum + (Number(bet.stake) || 0), 0);
            const combiStake = (window.betSlip.length > 1) ? (Number(window.combiStake) || 0) : 0;
            const totalStake = singlesSum + combiStake;
            const balance = (typeof window.getCurrentCoins === 'function')
                ? window.getCurrentCoins()
                : Number((currentUser && typeof currentUser.coins !== 'undefined') ? currentUser.coins : (window.coins || 0));
            if (totalStake > balance) {
                alert('Nicht genügend Coins! Sie haben nur ' + balance + ' Coins.');
                return;
            }

            // If Supabase online AND session exists, save slips directly to DB; else fallback to Node/offline
            let hasSupabaseSession = false;
            try {
                if (supabaseClient && supabaseClient.auth) {
                    const { data: authCheck } = await supabaseClient.auth.getUser();
                    hasSupabaseSession = !!(authCheck && authCheck.user);
                }
            } catch (_) {}
            if (isOnlineMode && supabaseClient && hasSupabaseSession) {
                console.log('[bets] Using Supabase bet flow');
                try {
                    // Build slips mirroring offline logic
                    const singlesWithStake = (Array.isArray(window.betSlip) ? window.betSlip : []).filter(b => Number(b.stake) > 0);
                    // Force league-only: resolve effective league ID
                    let leagueId = currentLeagueId;
                    if (!leagueId && window.currentLeague) {
                        const { data: leagueByCode } = await supabaseClient
                            .from('leagues')
                            .select('id, code')
                            .eq('code', window.currentLeague)
                            .single();
                        if (leagueByCode && leagueByCode.id) {
                            leagueId = leagueByCode.id;
                            currentLeagueId = leagueId;
                            try { localStorage.setItem('currentLeagueId', String(leagueId)); } catch (_) {}
                        }
                    }
                    if (!leagueId) {
                        // As a final fallback, ensure a private league exists
                        await ensurePrivateLeague();
                        leagueId = currentLeagueId;
                    }

                    // Fetch membership and debit weekly_coins atomically (best-effort)
                    const { data: auth } = await supabaseClient.auth.getUser();
                    const userId = auth && auth.user ? auth.user.id : null;
                    // If there is no Supabase session, fall back to Node mode below
                    if (!userId) {
                        throw new Error('NO_SUPABASE_SESSION');
                    }
                    // If league not yet resolved in Supabase mode, try to ensure it
                    if (!leagueId) {
                        await ensurePrivateLeague();
                        leagueId = currentLeagueId;
                        if (!leagueId) throw new Error('NO_LEAGUE_IN_SUPABASE');
                    }
                    const { data: member, error: memErr } = await supabaseClient
                        .from('league_members')
                        .select('id, weekly_coins')
                        .eq('league_id', leagueId)
                        .eq('user_id', userId)
                        .single();
                    if (memErr || !member) {
                        alert('Not a member of the league.');
                        return;
                    }
                    const beforeCoins = Number(member.weekly_coins || 0);
                    if (totalStake > beforeCoins) {
                        alert('Nicht genügend Coins! Sie haben nur ' + beforeCoins + ' Coins.');
                        return;
                    }
                    const newBalance = Math.max(0, Math.floor(beforeCoins - totalStake));
                    const { error: debitErr } = await supabaseClient
                        .from('league_members')
                        .update({ weekly_coins: newBalance })
                        .eq('id', member.id);
                    if (debitErr) throw debitErr;
                    leagueCoins = newBalance;
                    try { localStorage.setItem('leagueCoins', String(leagueCoins)); } catch (_) {}
                    updateCoinDisplay();

                    // Save each single as its own slip
                    for (const single of singlesWithStake) {
                        const stake = Number(single.stake) || 0;
                        const odds = Number(single.odds) || 1;
                        const singleSlip = await saveSlipToSupabase({
                            totalStake: stake,
                            totalOdds: odds,
                            potentialWin: Math.round(stake * odds),
                            leagueId
                        });
                        if (singleSlip && singleSlip.id) {
                            await insertBetSlipItems(singleSlip.id, [single]);
                            try { console.log('🧾 Single slip created:', singleSlip.id, single); } catch (_) {}
                        }
                    }
                    // Save combination slip if applicable
                    if (window.betSlip.length > 1 && combiStake > 0) {
                        const combiOdds = window.betSlip.reduce((t, b) => t * (Number(b.odds) || 1), 1);
                        const comboSlip = await saveSlipToSupabase({
                            totalStake: combiStake,
                            totalOdds: combiOdds,
                            potentialWin: Math.round(combiStake * combiOdds),
                            leagueId
                        });
                        if (comboSlip && comboSlip.id) {
                            await insertBetSlipItems(comboSlip.id, window.betSlip);
                            try { console.log('🧾 Combo slip created:', comboSlip.id, { combiStake, combiOdds }); } catch (_) {}
                        }
                    }
                    // Sync UI state after debit already applied to leagueCoins
                    updateUserUI();

                    // Also append to local history for rich detail view
                    try {
                        const existingBets = JSON.parse(localStorage.getItem('placedBets') || '[]');
                        // Reuse offline serialization for consistency
                        const nowIso = new Date().toISOString();
                        const nowDisp = new Date().toLocaleString('de-DE');
                        singlesWithStake.forEach((single, idx) => {
                            existingBets.unshift({
                                id: `${Date.now()}-${idx}`,
                                timestamp: nowIso,
                                displayTime: nowDisp,
                                totalStake: Number(single.stake) || 0,
                                bets: [{
                                    match: single.match,
                                    selection: single.selection,
                                    odds: single.odds,
                                    stake: Number(single.stake) || 0
                                }],
                                combiStake: 0,
                                combiOdds: 0,
                                totalOdds: Number(single.odds) || 1,
                                status: 'Pending',
                                type: 'Single'
                            });
                        });
                        if (window.betSlip.length > 1 && combiStake > 0) {
                            const combiOdds = window.betSlip.reduce((t, b) => t * (Number(b.odds) || 1), 1);
                            existingBets.unshift({
                                id: `${Date.now()}-combo`,
                                timestamp: nowIso,
                                displayTime: nowDisp,
                                totalStake: combiStake,
                                bets: window.betSlip.map(b => ({
                                    match: b.match,
                                    selection: b.selection,
                                    odds: b.odds,
                                    stake: Number(b.stake) || 0
                                })),
                                combiStake: combiStake,
                                combiOdds: combiOdds,
                                totalOdds: combiOdds,
                                status: 'Pending',
                                type: 'Combination'
                            });
                        }
                        localStorage.setItem('placedBets', JSON.stringify(existingBets));
                    } catch (_) {}

                    // Clear bet slip
                    if (typeof clearAllBets === 'function') {
                        clearAllBets();
                    } else {
                        window.betSlip = [];
                        window.combiStake = 0;
                        document.querySelectorAll('.odds-button.selected').forEach(btn => btn.classList.remove('selected'));
                        if (typeof updateBetSlip === 'function') updateBetSlip();
                    }

                    showMessage('Bets placed successfully!', 'success');
                    // Refresh leaderboard cache and My Bets
                    if (typeof updateLeaderboard === 'function') {
                        try { await updateLeaderboard(); } catch (_) {}
                    }
                    if (typeof updateMyBets === 'function') updateMyBets();
                    // Auto-switch to Bet Slip Open view
                    try {
                        showTab('betslip');
                        if (typeof window.setBetSlipView === 'function') {
                            window.setBetSlipView('open');
                        } else {
                            window.betslipViewMode = 'open';
                            if (typeof updateBetSlip === 'function') updateBetSlip();
                        }
                    } catch (_) {}
                    if (typeof window.loadOpenBetsInline === 'function') { try { if (window.betslipViewMode === 'open') await window.loadOpenBetsInline(); } catch (_) {} }
                    // Smooth scroll to Open Bets section
                    setTimeout(() => {
                        try {
                            const wrap = document.getElementById('open-bets-inline');
                            if (wrap && wrap.scrollIntoView) wrap.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        } catch (_) {}
                    }, 100);
                    return;
                } catch (err) {
                    console.warn('Supabase bet flow unavailable, falling back to Node mode:', (err && err.message) ? err.message : err);
                    // Intentionally do not return; continue to Node.js branch below
                }
            }

            console.log('[bets] Using Node bet flow');
            // Online mode with Node.js server (no Supabase)
            if (isOnlineMode) {
                try {
                    // Ensure the user exists on the Node server (id may differ from local/offline or Supabase id)
                    try {
                        if (currentUser && currentUser.username) {
                            const resAuth = await fetch(`${API_BASE}/api/auth/login`, {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                body: JSON.stringify({ username: currentUser.username })
                            });
                            const dataAuth = await resAuth.json();
                            if (resAuth.ok && dataAuth && dataAuth.success && dataAuth.user) {
                                if (!currentUser.id || dataAuth.user.id !== currentUser.id) {
                                    try { console.log('[bets] Synced Node user id', { from: currentUser.id, to: dataAuth.user.id }); } catch (_) {}
                                }
                                currentUser = dataAuth.user;
                                try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                            }
                        }
                    } catch (e) {
                        try { console.warn('Node auth sync failed', e && e.message ? e.message : e); } catch (_) {}
                    }
                    const singlesWithStake = (Array.isArray(window.betSlip) ? window.betSlip : []).filter(b => Number(b.stake) > 0);
                    for (const single of singlesWithStake) {
                        const betId = String(single.id || '');
                        const matchId = betId.split('-').slice(0, -1).join('-');
                        const market = getBetType(betId);
                        const selection = getBetSelectionCode(betId);
                        // Ensure we have a valid Node user id before each post
                        if (!currentUser || !currentUser.id) {
                            try {
                                const resAuth2 = await fetch(`${API_BASE}/api/auth/login`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ username: (currentUser && currentUser.username) ? currentUser.username : '' })
                                });
                                const dataAuth2 = await resAuth2.json();
                                if (resAuth2.ok && dataAuth2 && dataAuth2.user) {
                                    currentUser = dataAuth2.user;
                                    try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                                }
                            } catch (e) { /* continue with best-effort */ }
                        }
                        let payload = {
                            userId: currentUser && currentUser.id ? currentUser.id : undefined,
                            matchId,
                            match: String(single.match || ''),
                            market,
                            selection,
                            odds: Number(single.odds) || 1,
                            stake: Number(single.stake) || 0
                        };
                        try { console.log('[bets][node] POST /api/bets/place (single)', payload); } catch (_) {}
                        let res = await fetch(`${API_BASE}/api/bets/place`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        let data = await res.json();
                        // If the user was not found (e.g., server restarted), re-auth and retry once
                        if (!res.ok && (res.status === 404) && (data && /user not found/i.test(String(data.error || '')))) {
                            try { console.warn('[bets][node] User not found on first attempt; re-authenticating and retrying...'); } catch (_) {}
                            try {
                                const resAuth3 = await fetch(`${API_BASE}/api/auth/login`, {
                                    method: 'POST',
                                    headers: { 'Content-Type': 'application/json' },
                                    body: JSON.stringify({ username: (currentUser && currentUser.username) ? currentUser.username : '' })
                                });
                                const dataAuth3 = await resAuth3.json();
                                if (resAuth3.ok && dataAuth3 && dataAuth3.user) {
                                    currentUser = dataAuth3.user;
                                    try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                                    payload.userId = currentUser.id;
                                    try { console.log('[bets][node] Retry /api/bets/place with re-synced userId', payload.userId); } catch (_) {}
                                    res = await fetch(`${API_BASE}/api/bets/place`, {
                                        method: 'POST',
                                        headers: { 'Content-Type': 'application/json' },
                                        body: JSON.stringify(payload)
                                    });
                                    data = await res.json();
                                }
                            } catch (e) { /* fall through */ }
                        }
                        if (!res.ok || !data?.success) {
                            try { console.warn('[bets][node] place single failed', { status: res && res.status, error: data && data.error }); } catch (_) {}
                            throw new Error(data?.error || 'Failed to place bet');
                        }
                        currentUser = data.user;
                        try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                    }
                    if ((window.betSlip || []).length > 1 && (Number(combiStake) || 0) > 0) {
                        const combiOdds = (window.betSlip || []).reduce((t, b) => t * (Number(b.odds) || 1), 1);
                        const payload = {
                            userId: currentUser.id,
                            matchId: 'combo',
                            market: 'combi',
                            selection: `combo_${(window.betSlip || []).length}`,
                            odds: Number(combiOdds) || 1,
                            stake: Number(combiStake) || 0
                        };
                        const res = await fetch(`${API_BASE}/api/bets/place`, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify(payload)
                        });
                        const data = await res.json();
                        if (res.ok && data?.success && data.user) {
                            currentUser = data.user;
                            try { localStorage.setItem('scoreLeagueUser', JSON.stringify(currentUser)); } catch (_) {}
                        }
                    }
                    updateUserUI();
                    updateCoinDisplay();

                    // Clear bet slip
                    if (typeof clearAllBets === 'function') {
                        clearAllBets();
                    } else {
                        window.betSlip = [];
                        window.combiStake = 0;
                        document.querySelectorAll('.odds-button.selected').forEach(btn => btn.classList.remove('selected'));
                        if (typeof updateBetSlip === 'function') updateBetSlip();
                    }

                    showMessage('Bets placed successfully!', 'success');
                    if (typeof updateMyBets === 'function') updateMyBets();
                    // Auto-switch to Bet Slip Open view
                    try {
                        showTab('betslip');
                        if (typeof window.setBetSlipView === 'function') {
                            window.setBetSlipView('open');
                        } else {
                            window.betslipViewMode = 'open';
                            if (typeof updateBetSlip === 'function') updateBetSlip();
                        }
                    } catch (_) {}
                    if (typeof window.loadOpenBetsInline === 'function') { try { if (window.betslipViewMode === 'open') await window.loadOpenBetsInline(); } catch (_) {} }
                    // Smooth scroll to Open Bets section
                    setTimeout(() => {
                        try {
                            const wrap = document.getElementById('open-bets-inline');
                            if (wrap && wrap.scrollIntoView) wrap.scrollIntoView({ behavior: 'smooth', block: 'start' });
                        } catch (_) {}
                    }, 100);
                    return;
                } catch (err) {
                    console.error('Online (Node) bet placement error:', err);
                    alert((err && err.message) ? err.message : 'Connection error. Please try again.');
                    return;
                }
            }

            // Fallback to offline mode explicitly
            if (typeof window.placeBetsOffline === 'function') {
                return window.placeBetsOffline();
            }
        }

        // Function override removed to fix ReferenceError
        // placeBetsOffline is used for offline betting
        // placeBetsMultiUser is used for online multi-user betting

        // Initialize app on page load
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('🚀 ScoreLeague Multi-User Professional Version Loading...');
            try { setupAdminAutoControls(); } catch(_) {}
            checkExistingSession();
            // Initialize online/offline awareness early
            try {
                await checkApiHealth();
                // Initialize socket after health status is known
                initSocket();
            } catch (_) {}
            
            // Allow Enter key to login
            document.getElementById('usernameInput').addEventListener('keypress', function(e) {
                if (e.key === 'Enter') {
                    login();
                }
            });
        });

        // Logout function
        function logout() {
            currentUser = null;
            localStorage.removeItem('scoreLeagueUser');
            document.getElementById('authScreen').style.display = 'flex';
            document.getElementById('mainApp').classList.add('hidden');
            document.getElementById('usernameInput').value = '';
        }
    </script>
</body>
</html>
